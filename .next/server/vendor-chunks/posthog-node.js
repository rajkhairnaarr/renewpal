"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/posthog-node";
exports.ids = ["vendor-chunks/posthog-node"];
exports.modules = {

/***/ "(ssr)/./node_modules/posthog-node/lib/node/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/posthog-node/lib/node/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostHog: () => (/* binding */ PostHog),\n/* harmony export */   PostHogSentryIntegration: () => (/* binding */ PostHogSentryIntegration),\n/* harmony export */   createEventProcessor: () => (/* binding */ createEventProcessor),\n/* harmony export */   sentryIntegration: () => (/* binding */ sentryIntegration),\n/* harmony export */   setupExpressErrorHandler: () => (/* binding */ setupExpressErrorHandler)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_readline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:readline */ \"node:readline\");\n\n\n\n\n/**\r\n * @file Adapted from [posthog-js](https://github.com/PostHog/posthog-js/blob/8157df935a4d0e71d2fefef7127aa85ee51c82d1/src/extensions/sentry-integration.ts) with modifications for the Node SDK.\r\n */\n/**\r\n * Integrate Sentry with PostHog. This will add a direct link to the person in Sentry, and an $exception event in PostHog.\r\n *\r\n * ### Usage\r\n *\r\n *     Sentry.init({\r\n *          dsn: 'https://example',\r\n *          integrations: [\r\n *              new PostHogSentryIntegration(posthog)\r\n *          ]\r\n *     })\r\n *\r\n *     Sentry.setTag(PostHogSentryIntegration.POSTHOG_ID_TAG, 'some distinct id');\r\n *\r\n * @param {Object} [posthog] The posthog object\r\n * @param {string} [organization] Optional: The Sentry organization, used to send a direct link from PostHog to Sentry\r\n * @param {Number} [projectId] Optional: The Sentry project id, used to send a direct link from PostHog to Sentry\r\n * @param {string} [prefix] Optional: Url of a self-hosted sentry instance (default: https://sentry.io/organizations/)\r\n * @param {SeverityLevel[] | '*'} [severityAllowList] Optional: send events matching the provided levels. Use '*' to send all events (default: ['error'])\r\n */\nconst NAME = 'posthog-node';\nfunction createEventProcessor(_posthog, {\n  organization,\n  projectId,\n  prefix,\n  severityAllowList = ['error']\n} = {}) {\n  return event => {\n    const shouldProcessLevel = severityAllowList === '*' || severityAllowList.includes(event.level);\n    if (!shouldProcessLevel) {\n      return event;\n    }\n    if (!event.tags) {\n      event.tags = {};\n    }\n    // Get the PostHog user ID from a specific tag, which users can set on their Sentry scope as they need.\n    const userId = event.tags[PostHogSentryIntegration.POSTHOG_ID_TAG];\n    if (userId === undefined) {\n      // If we can't find a user ID, don't bother linking the event. We won't be able to send anything meaningful to PostHog without it.\n      return event;\n    }\n    const uiHost = _posthog.options.host ?? 'https://us.i.posthog.com';\n    const personUrl = new URL(`/project/${_posthog.apiKey}/person/${userId}`, uiHost).toString();\n    event.tags['PostHog Person URL'] = personUrl;\n    const exceptions = event.exception?.values || [];\n    const exceptionList = exceptions.map(exception => ({\n      ...exception,\n      stacktrace: exception.stacktrace ? {\n        ...exception.stacktrace,\n        type: 'raw',\n        frames: (exception.stacktrace.frames || []).map(frame => {\n          return {\n            ...frame,\n            platform: 'node:javascript'\n          };\n        })\n      } : undefined\n    }));\n    const properties = {\n      // PostHog Exception Properties,\n      $exception_message: exceptions[0]?.value || event.message,\n      $exception_type: exceptions[0]?.type,\n      $exception_personURL: personUrl,\n      $exception_level: event.level,\n      $exception_list: exceptionList,\n      // Sentry Exception Properties\n      $sentry_event_id: event.event_id,\n      $sentry_exception: event.exception,\n      $sentry_exception_message: exceptions[0]?.value || event.message,\n      $sentry_exception_type: exceptions[0]?.type,\n      $sentry_tags: event.tags\n    };\n    if (organization && projectId) {\n      properties['$sentry_url'] = (prefix || 'https://sentry.io/organizations/') + organization + '/issues/?project=' + projectId + '&query=' + event.event_id;\n    }\n    _posthog.capture({\n      event: '$exception',\n      distinctId: userId,\n      properties\n    });\n    return event;\n  };\n}\n// V8 integration - function based\nfunction sentryIntegration(_posthog, options) {\n  const processor = createEventProcessor(_posthog, options);\n  return {\n    name: NAME,\n    processEvent(event) {\n      return processor(event);\n    }\n  };\n}\n// V7 integration - class based\nclass PostHogSentryIntegration {\n  constructor(_posthog, organization, prefix, severityAllowList) {\n    this.name = NAME;\n    // setupOnce gets called by Sentry when it intializes the plugin\n    this.name = NAME;\n    this.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {\n      const projectId = getCurrentHub()?.getClient()?.getDsn()?.projectId;\n      addGlobalEventProcessor(createEventProcessor(_posthog, {\n        organization,\n        projectId,\n        prefix,\n        severityAllowList\n      }));\n    };\n  }\n}\nPostHogSentryIntegration.POSTHOG_ID_TAG = 'posthog_distinct_id';\n\n// vendor from: https://github.com/LiosK/uuidv7/blob/f30b7a7faff73afbce0b27a46c638310f96912ba/src/index.ts\r\n// https://github.com/LiosK/uuidv7#license\r\n/**\r\n * uuidv7: An experimental implementation of the proposed UUID Version 7\r\n *\r\n * @license Apache-2.0\r\n * @copyright 2021-2023 LiosK\r\n * @packageDocumentation\r\n */\r\nconst DIGITS = \"0123456789abcdef\";\r\n/** Represents a UUID as a 16-byte byte array. */\r\nclass UUID {\r\n    /** @param bytes - The 16-byte byte array representation. */\r\n    constructor(bytes) {\r\n        this.bytes = bytes;\r\n    }\r\n    /**\r\n     * Creates an object from the internal representation, a 16-byte byte array\r\n     * containing the binary UUID representation in the big-endian byte order.\r\n     *\r\n     * This method does NOT shallow-copy the argument, and thus the created object\r\n     * holds the reference to the underlying buffer.\r\n     *\r\n     * @throws TypeError if the length of the argument is not 16.\r\n     */\r\n    static ofInner(bytes) {\r\n        if (bytes.length !== 16) {\r\n            throw new TypeError(\"not 128-bit length\");\r\n        }\r\n        else {\r\n            return new UUID(bytes);\r\n        }\r\n    }\r\n    /**\r\n     * Builds a byte array from UUIDv7 field values.\r\n     *\r\n     * @param unixTsMs - A 48-bit `unix_ts_ms` field value.\r\n     * @param randA - A 12-bit `rand_a` field value.\r\n     * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.\r\n     * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.\r\n     * @throws RangeError if any field value is out of the specified range.\r\n     */\r\n    static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {\r\n        if (!Number.isInteger(unixTsMs) ||\r\n            !Number.isInteger(randA) ||\r\n            !Number.isInteger(randBHi) ||\r\n            !Number.isInteger(randBLo) ||\r\n            unixTsMs < 0 ||\r\n            randA < 0 ||\r\n            randBHi < 0 ||\r\n            randBLo < 0 ||\r\n            unixTsMs > 281474976710655 ||\r\n            randA > 0xfff ||\r\n            randBHi > 1073741823 ||\r\n            randBLo > 4294967295) {\r\n            throw new RangeError(\"invalid field value\");\r\n        }\r\n        const bytes = new Uint8Array(16);\r\n        bytes[0] = unixTsMs / 2 ** 40;\r\n        bytes[1] = unixTsMs / 2 ** 32;\r\n        bytes[2] = unixTsMs / 2 ** 24;\r\n        bytes[3] = unixTsMs / 2 ** 16;\r\n        bytes[4] = unixTsMs / 2 ** 8;\r\n        bytes[5] = unixTsMs;\r\n        bytes[6] = 0x70 | (randA >>> 8);\r\n        bytes[7] = randA;\r\n        bytes[8] = 0x80 | (randBHi >>> 24);\r\n        bytes[9] = randBHi >>> 16;\r\n        bytes[10] = randBHi >>> 8;\r\n        bytes[11] = randBHi;\r\n        bytes[12] = randBLo >>> 24;\r\n        bytes[13] = randBLo >>> 16;\r\n        bytes[14] = randBLo >>> 8;\r\n        bytes[15] = randBLo;\r\n        return new UUID(bytes);\r\n    }\r\n    /**\r\n     * Builds a byte array from a string representation.\r\n     *\r\n     * This method accepts the following formats:\r\n     *\r\n     * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`\r\n     * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`\r\n     * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`\r\n     * - RFC 4122 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`\r\n     *\r\n     * Leading and trailing whitespaces represents an error.\r\n     *\r\n     * @throws SyntaxError if the argument could not parse as a valid UUID string.\r\n     */\r\n    static parse(uuid) {\r\n        let hex = undefined;\r\n        switch (uuid.length) {\r\n            case 32:\r\n                hex = /^[0-9a-f]{32}$/i.exec(uuid)?.[0];\r\n                break;\r\n            case 36:\r\n                hex =\r\n                    /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\r\n                        .exec(uuid)\r\n                        ?.slice(1, 6)\r\n                        .join(\"\");\r\n                break;\r\n            case 38:\r\n                hex =\r\n                    /^\\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\\}$/i\r\n                        .exec(uuid)\r\n                        ?.slice(1, 6)\r\n                        .join(\"\");\r\n                break;\r\n            case 45:\r\n                hex =\r\n                    /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\r\n                        .exec(uuid)\r\n                        ?.slice(1, 6)\r\n                        .join(\"\");\r\n                break;\r\n        }\r\n        if (hex) {\r\n            const inner = new Uint8Array(16);\r\n            for (let i = 0; i < 16; i += 4) {\r\n                const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);\r\n                inner[i + 0] = n >>> 24;\r\n                inner[i + 1] = n >>> 16;\r\n                inner[i + 2] = n >>> 8;\r\n                inner[i + 3] = n;\r\n            }\r\n            return new UUID(inner);\r\n        }\r\n        else {\r\n            throw new SyntaxError(\"could not parse UUID string\");\r\n        }\r\n    }\r\n    /**\r\n     * @returns The 8-4-4-4-12 canonical hexadecimal string representation\r\n     * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).\r\n     */\r\n    toString() {\r\n        let text = \"\";\r\n        for (let i = 0; i < this.bytes.length; i++) {\r\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\r\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\r\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\r\n                text += \"-\";\r\n            }\r\n        }\r\n        return text;\r\n    }\r\n    /**\r\n     * @returns The 32-digit hexadecimal representation without hyphens\r\n     * (`0189dcd553117d408db09496a2eef37b`).\r\n     */\r\n    toHex() {\r\n        let text = \"\";\r\n        for (let i = 0; i < this.bytes.length; i++) {\r\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\r\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\r\n        }\r\n        return text;\r\n    }\r\n    /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */\r\n    toJSON() {\r\n        return this.toString();\r\n    }\r\n    /**\r\n     * Reports the variant field value of the UUID or, if appropriate, \"NIL\" or\r\n     * \"MAX\".\r\n     *\r\n     * For convenience, this method reports \"NIL\" or \"MAX\" if `this` represents\r\n     * the Nil or Max UUID, although the Nil and Max UUIDs are technically\r\n     * subsumed under the variants `0b0` and `0b111`, respectively.\r\n     */\r\n    getVariant() {\r\n        const n = this.bytes[8] >>> 4;\r\n        if (n < 0) {\r\n            throw new Error(\"unreachable\");\r\n        }\r\n        else if (n <= 0b0111) {\r\n            return this.bytes.every((e) => e === 0) ? \"NIL\" : \"VAR_0\";\r\n        }\r\n        else if (n <= 0b1011) {\r\n            return \"VAR_10\";\r\n        }\r\n        else if (n <= 0b1101) {\r\n            return \"VAR_110\";\r\n        }\r\n        else if (n <= 0b1111) {\r\n            return this.bytes.every((e) => e === 0xff) ? \"MAX\" : \"VAR_RESERVED\";\r\n        }\r\n        else {\r\n            throw new Error(\"unreachable\");\r\n        }\r\n    }\r\n    /**\r\n     * Returns the version field value of the UUID or `undefined` if the UUID does\r\n     * not have the variant field value of `0b10`.\r\n     */\r\n    getVersion() {\r\n        return this.getVariant() === \"VAR_10\" ? this.bytes[6] >>> 4 : undefined;\r\n    }\r\n    /** Creates an object from `this`. */\r\n    clone() {\r\n        return new UUID(this.bytes.slice(0));\r\n    }\r\n    /** Returns true if `this` is equivalent to `other`. */\r\n    equals(other) {\r\n        return this.compareTo(other) === 0;\r\n    }\r\n    /**\r\n     * Returns a negative integer, zero, or positive integer if `this` is less\r\n     * than, equal to, or greater than `other`, respectively.\r\n     */\r\n    compareTo(other) {\r\n        for (let i = 0; i < 16; i++) {\r\n            const diff = this.bytes[i] - other.bytes[i];\r\n            if (diff !== 0) {\r\n                return Math.sign(diff);\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n/**\r\n * Encapsulates the monotonic counter state.\r\n *\r\n * This class provides APIs to utilize a separate counter state from that of the\r\n * global generator used by {@link uuidv7} and {@link uuidv7obj}. In addition to\r\n * the default {@link generate} method, this class has {@link generateOrAbort}\r\n * that is useful to absolutely guarantee the monotonically increasing order of\r\n * generated UUIDs. See their respective documentation for details.\r\n */\r\nclass V7Generator {\r\n    /**\r\n     * Creates a generator object with the default random number generator, or\r\n     * with the specified one if passed as an argument. The specified random\r\n     * number generator should be cryptographically strong and securely seeded.\r\n     */\r\n    constructor(randomNumberGenerator) {\r\n        this.timestamp = 0;\r\n        this.counter = 0;\r\n        this.random = randomNumberGenerator ?? getDefaultRandom();\r\n    }\r\n    /**\r\n     * Generates a new UUIDv7 object from the current timestamp, or resets the\r\n     * generator upon significant timestamp rollback.\r\n     *\r\n     * This method returns a monotonically increasing UUID by reusing the previous\r\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\r\n     * preceding UUID's. However, when such a clock rollback is considered\r\n     * significant (i.e., by more than ten seconds), this method resets the\r\n     * generator and returns a new UUID based on the given timestamp, breaking the\r\n     * increasing order of UUIDs.\r\n     *\r\n     * See {@link generateOrAbort} for the other mode of generation and\r\n     * {@link generateOrResetCore} for the low-level primitive.\r\n     */\r\n    generate() {\r\n        return this.generateOrResetCore(Date.now(), 10000);\r\n    }\r\n    /**\r\n     * Generates a new UUIDv7 object from the current timestamp, or returns\r\n     * `undefined` upon significant timestamp rollback.\r\n     *\r\n     * This method returns a monotonically increasing UUID by reusing the previous\r\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\r\n     * preceding UUID's. However, when such a clock rollback is considered\r\n     * significant (i.e., by more than ten seconds), this method aborts and\r\n     * returns `undefined` immediately.\r\n     *\r\n     * See {@link generate} for the other mode of generation and\r\n     * {@link generateOrAbortCore} for the low-level primitive.\r\n     */\r\n    generateOrAbort() {\r\n        return this.generateOrAbortCore(Date.now(), 10000);\r\n    }\r\n    /**\r\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the\r\n     * generator upon significant timestamp rollback.\r\n     *\r\n     * This method is equivalent to {@link generate} except that it takes a custom\r\n     * timestamp and clock rollback allowance.\r\n     *\r\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\r\n     * considered significant. A suggested value is `10_000` (milliseconds).\r\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\r\n     */\r\n    generateOrResetCore(unixTsMs, rollbackAllowance) {\r\n        let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\r\n        if (value === undefined) {\r\n            // reset state and resume\r\n            this.timestamp = 0;\r\n            value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns\r\n     * `undefined` upon significant timestamp rollback.\r\n     *\r\n     * This method is equivalent to {@link generateOrAbort} except that it takes a\r\n     * custom timestamp and clock rollback allowance.\r\n     *\r\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\r\n     * considered significant. A suggested value is `10_000` (milliseconds).\r\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\r\n     */\r\n    generateOrAbortCore(unixTsMs, rollbackAllowance) {\r\n        const MAX_COUNTER = 4398046511103;\r\n        if (!Number.isInteger(unixTsMs) ||\r\n            unixTsMs < 1 ||\r\n            unixTsMs > 281474976710655) {\r\n            throw new RangeError(\"`unixTsMs` must be a 48-bit positive integer\");\r\n        }\r\n        else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {\r\n            throw new RangeError(\"`rollbackAllowance` out of reasonable range\");\r\n        }\r\n        if (unixTsMs > this.timestamp) {\r\n            this.timestamp = unixTsMs;\r\n            this.resetCounter();\r\n        }\r\n        else if (unixTsMs + rollbackAllowance >= this.timestamp) {\r\n            // go on with previous timestamp if new one is not much smaller\r\n            this.counter++;\r\n            if (this.counter > MAX_COUNTER) {\r\n                // increment timestamp at counter overflow\r\n                this.timestamp++;\r\n                this.resetCounter();\r\n            }\r\n        }\r\n        else {\r\n            // abort if clock went backwards to unbearable extent\r\n            return undefined;\r\n        }\r\n        return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & (2 ** 30 - 1), this.random.nextUint32());\r\n    }\r\n    /** Initializes the counter at a 42-bit random integer. */\r\n    resetCounter() {\r\n        this.counter =\r\n            this.random.nextUint32() * 0x400 + (this.random.nextUint32() & 0x3ff);\r\n    }\r\n    /**\r\n     * Generates a new UUIDv4 object utilizing the random number generator inside.\r\n     *\r\n     * @internal\r\n     */\r\n    generateV4() {\r\n        const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);\r\n        bytes[6] = 0x40 | (bytes[6] >>> 4);\r\n        bytes[8] = 0x80 | (bytes[8] >>> 2);\r\n        return UUID.ofInner(bytes);\r\n    }\r\n}\r\n/** A global flag to force use of cryptographically strong RNG. */\r\n// declare const UUIDV7_DENY_WEAK_RNG: boolean;\r\n/** Returns the default random number generator available in the environment. */\r\nconst getDefaultRandom = () => {\r\n    // fix: crypto isn't available in react-native, always use Math.random\r\n    //   // detect Web Crypto API\r\n    //   if (\r\n    //     typeof crypto !== \"undefined\" &&\r\n    //     typeof crypto.getRandomValues !== \"undefined\"\r\n    //   ) {\r\n    //     return new BufferedCryptoRandom();\r\n    //   } else {\r\n    //     // fall back on Math.random() unless the flag is set to true\r\n    //     if (typeof UUIDV7_DENY_WEAK_RNG !== \"undefined\" && UUIDV7_DENY_WEAK_RNG) {\r\n    //       throw new Error(\"no cryptographically strong RNG available\");\r\n    //     }\r\n    //     return {\r\n    //       nextUint32: (): number =>\r\n    //         Math.trunc(Math.random() * 0x1_0000) * 0x1_0000 +\r\n    //         Math.trunc(Math.random() * 0x1_0000),\r\n    //     };\r\n    //   }\r\n    return {\r\n        nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 +\r\n            Math.trunc(Math.random() * 65536),\r\n    };\r\n};\r\n// /**\r\n//  * Wraps `crypto.getRandomValues()` to enable buffering; this uses a small\r\n//  * buffer by default to avoid both unbearable throughput decline in some\r\n//  * environments and the waste of time and space for unused values.\r\n//  */\r\n// class BufferedCryptoRandom {\r\n//   private readonly buffer = new Uint32Array(8);\r\n//   private cursor = 0xffff;\r\n//   nextUint32(): number {\r\n//     if (this.cursor >= this.buffer.length) {\r\n//       crypto.getRandomValues(this.buffer);\r\n//       this.cursor = 0;\r\n//     }\r\n//     return this.buffer[this.cursor++];\r\n//   }\r\n// }\r\nlet defaultGenerator;\r\n/**\r\n * Generates a UUIDv7 string.\r\n *\r\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\r\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\r\n */\r\nconst uuidv7 = () => uuidv7obj().toString();\r\n/** Generates a UUIDv7 object. */\r\nconst uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();\n\n// Portions of this file are derived from getsentry/sentry-javascript by Software, Inc. dba Sentry\n// Licensed under the MIT License\nfunction makeUncaughtExceptionHandler(captureFn, onFatalFn) {\n  let calledFatalError = false;\n  return Object.assign(error => {\n    // Attaching a listener to `uncaughtException` will prevent the node process from exiting. We generally do not\n    // want to alter this behaviour so we check for other listeners that users may have attached themselves and adjust\n    // exit behaviour of the SDK accordingly:\n    // - If other listeners are attached, do not exit.\n    // - If the only listener attached is ours, exit.\n    const userProvidedListenersCount = global.process.listeners('uncaughtException').filter(listener => {\n      // There are 2 listeners we ignore:\n      return (\n        // as soon as we're using domains this listener is attached by node itself\n        listener.name !== 'domainUncaughtExceptionClear' &&\n        // the handler we register in this integration\n        listener._posthogErrorHandler !== true\n      );\n    }).length;\n    const processWouldExit = userProvidedListenersCount === 0;\n    captureFn(error, {\n      mechanism: {\n        type: 'onuncaughtexception',\n        handled: false\n      }\n    });\n    if (!calledFatalError && processWouldExit) {\n      calledFatalError = true;\n      onFatalFn();\n    }\n  }, {\n    _posthogErrorHandler: true\n  });\n}\nfunction addUncaughtExceptionListener(captureFn, onFatalFn) {\n  global.process.on('uncaughtException', makeUncaughtExceptionHandler(captureFn, onFatalFn));\n}\nfunction addUnhandledRejectionListener(captureFn) {\n  global.process.on('unhandledRejection', reason => {\n    captureFn(reason, {\n      mechanism: {\n        type: 'onunhandledrejection',\n        handled: false\n      }\n    });\n  });\n}\n\n// Portions of this file are derived from getsentry/sentry-javascript by Software, Inc. dba Sentry\n// Licensed under the MIT License\nlet parsedStackResults;\nlet lastKeysCount;\nlet cachedFilenameChunkIds;\nfunction getFilenameToChunkIdMap(stackParser) {\n  const chunkIdMap = globalThis._posthogChunkIds;\n  if (!chunkIdMap) {\n    console.error('No chunk id map found');\n    return {};\n  }\n  const chunkIdKeys = Object.keys(chunkIdMap);\n  if (cachedFilenameChunkIds && chunkIdKeys.length === lastKeysCount) {\n    return cachedFilenameChunkIds;\n  }\n  lastKeysCount = chunkIdKeys.length;\n  cachedFilenameChunkIds = chunkIdKeys.reduce((acc, stackKey) => {\n    if (!parsedStackResults) {\n      parsedStackResults = {};\n    }\n    const result = parsedStackResults[stackKey];\n    if (result) {\n      acc[result[0]] = result[1];\n    } else {\n      const parsedStack = stackParser(stackKey);\n      for (let i = parsedStack.length - 1; i >= 0; i--) {\n        const stackFrame = parsedStack[i];\n        const filename = stackFrame?.filename;\n        const chunkId = chunkIdMap[stackKey];\n        if (filename && chunkId) {\n          acc[filename] = chunkId;\n          parsedStackResults[stackKey] = [filename, chunkId];\n          break;\n        }\n      }\n    }\n    return acc;\n  }, {});\n  return cachedFilenameChunkIds;\n}\n\n// Portions of this file are derived from getsentry/sentry-javascript by Software, Inc. dba Sentry\n// Licensed under the MIT License\nfunction isEvent(candidate) {\n  return typeof Event !== 'undefined' && isInstanceOf(candidate, Event);\n}\nfunction isPlainObject(candidate) {\n  return isBuiltin(candidate, 'Object');\n}\nfunction isError(candidate) {\n  switch (Object.prototype.toString.call(candidate)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n    case '[object WebAssembly.Exception]':\n      return true;\n    default:\n      return isInstanceOf(candidate, Error);\n  }\n}\nfunction isInstanceOf(candidate, base) {\n  try {\n    return candidate instanceof base;\n  } catch {\n    return false;\n  }\n}\nfunction isErrorEvent(event) {\n  return isBuiltin(event, 'ErrorEvent');\n}\nfunction isBuiltin(candidate, className) {\n  return Object.prototype.toString.call(candidate) === `[object ${className}]`;\n}\n\n// Portions of this file are derived from getsentry/sentry-javascript by Software, Inc. dba Sentry\nasync function propertiesFromUnknownInput(stackParser, frameModifiers, input, hint) {\n  const providedMechanism = hint && hint.mechanism;\n  const mechanism = providedMechanism || {\n    handled: true,\n    type: 'generic'\n  };\n  const errorList = getErrorList(mechanism, input, hint);\n  const exceptionList = await Promise.all(errorList.map(async error => {\n    const exception = await exceptionFromError(stackParser, frameModifiers, error);\n    exception.value = exception.value || '';\n    exception.type = exception.type || 'Error';\n    exception.mechanism = mechanism;\n    return exception;\n  }));\n  const properties = {\n    $exception_list: exceptionList\n  };\n  return properties;\n}\n// Flatten error causes into a list of errors\n// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause\nfunction getErrorList(mechanism, input, hint) {\n  const error = getError(mechanism, input, hint);\n  if (error.cause) {\n    return [error, ...getErrorList(mechanism, error.cause, hint)];\n  }\n  return [error];\n}\nfunction getError(mechanism, exception, hint) {\n  if (isError(exception)) {\n    return exception;\n  }\n  mechanism.synthetic = true;\n  if (isPlainObject(exception)) {\n    const errorFromProp = getErrorPropertyFromObject(exception);\n    if (errorFromProp) {\n      return errorFromProp;\n    }\n    const message = getMessageForObject(exception);\n    const ex = hint?.syntheticException || new Error(message);\n    ex.message = message;\n    return ex;\n  }\n  // This handles when someone does: `throw \"something awesome\";`\n  // We use synthesized Error here so we can extract a (rough) stack trace.\n  const ex = hint?.syntheticException || new Error(exception);\n  ex.message = `${exception}`;\n  return ex;\n}\n/** If a plain object has a property that is an `Error`, return this error. */\nfunction getErrorPropertyFromObject(obj) {\n  for (const prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      const value = obj[prop];\n      if (isError(value)) {\n        return value;\n      }\n    }\n  }\n  return undefined;\n}\nfunction getMessageForObject(exception) {\n  if ('name' in exception && typeof exception.name === 'string') {\n    let message = `'${exception.name}' captured as exception`;\n    if ('message' in exception && typeof exception.message === 'string') {\n      message += ` with message '${exception.message}'`;\n    }\n    return message;\n  } else if ('message' in exception && typeof exception.message === 'string') {\n    return exception.message;\n  }\n  const keys = extractExceptionKeysForMessage(exception);\n  // Some ErrorEvent instances do not have an `error` property, which is why they are not handled before\n  // We still want to try to get a decent message for these cases\n  if (isErrorEvent(exception)) {\n    return `Event \\`ErrorEvent\\` captured as exception with message \\`${exception.message}\\``;\n  }\n  const className = getObjectClassName(exception);\n  return `${className && className !== 'Object' ? `'${className}'` : 'Object'} captured as exception with keys: ${keys}`;\n}\nfunction getObjectClassName(obj) {\n  try {\n    const prototype = Object.getPrototypeOf(obj);\n    return prototype ? prototype.constructor.name : undefined;\n  } catch (e) {\n    // ignore errors here\n  }\n}\n/**\r\n * Given any captured exception, extract its keys and create a sorted\r\n * and truncated list that will be used inside the event message.\r\n * eg. `Non-error exception captured with keys: foo, bar, baz`\r\n */\nfunction extractExceptionKeysForMessage(exception, maxLength = 40) {\n  const keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n  const firstKey = keys[0];\n  if (!firstKey) {\n    return '[object has no keys]';\n  }\n  if (firstKey.length >= maxLength) {\n    return truncate(firstKey, maxLength);\n  }\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    const serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n  return '';\n}\nfunction truncate(str, max = 0) {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.slice(0, max)}...`;\n}\n/**\r\n * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their\r\n * non-enumerable properties attached.\r\n *\r\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\r\n * @returns An Event or Error turned into an object - or the value argument itself, when value is neither an Event nor\r\n *  an Error.\r\n */\nfunction convertToPlainObject(value) {\n  if (isError(value)) {\n    return {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value)\n    };\n  } else if (isEvent(value)) {\n    const newObj = {\n      type: value.type,\n      target: serializeEventTarget(value.target),\n      currentTarget: serializeEventTarget(value.currentTarget),\n      ...getOwnProperties(value)\n    };\n    // TODO: figure out why this fails typing (I think CustomEvent is only supported in Node 19 onwards)\n    // if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n    //   newObj.detail = (value as unknown as CustomEvent).detail\n    // }\n    return newObj;\n  } else {\n    return value;\n  }\n}\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj) {\n  if (typeof obj === 'object' && obj !== null) {\n    const extractedProps = {};\n    for (const property in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        extractedProps[property] = obj[property];\n      }\n    }\n    return extractedProps;\n  } else {\n    return {};\n  }\n}\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target) {\n  try {\n    return Object.prototype.toString.call(target);\n  } catch (_oO) {\n    return '<unknown>';\n  }\n}\n/**\r\n * Extracts stack frames from the error and builds an Exception\r\n */\nasync function exceptionFromError(stackParser, frameModifiers, error) {\n  const exception = {\n    type: error.name || error.constructor.name,\n    value: error.message\n  };\n  let frames = parseStackFrames(stackParser, error);\n  for (const modifier of frameModifiers) {\n    frames = await modifier(frames);\n  }\n  if (frames.length) {\n    exception.stacktrace = {\n      frames,\n      type: 'raw'\n    };\n  }\n  return exception;\n}\n/**\r\n * Extracts stack frames from the error.stack string\r\n */\nfunction parseStackFrames(stackParser, error) {\n  return applyChunkIds(stackParser(error.stack || '', 1), stackParser);\n}\nfunction applyChunkIds(frames, parser) {\n  const filenameChunkIdMap = getFilenameToChunkIdMap(parser);\n  frames.forEach(frame => {\n    if (frame.filename) {\n      frame.chunk_id = filenameChunkIdMap[frame.filename];\n    }\n  });\n  return frames;\n}\n\nconst SHUTDOWN_TIMEOUT = 2000;\nclass ErrorTracking {\n  static async buildEventMessage(error, hint, distinctId, additionalProperties) {\n    const properties = {\n      ...additionalProperties\n    };\n    // Given stateless nature of Node SDK we capture exceptions using personless processing when no\n    // user can be determined because a distinct_id is not provided e.g. exception autocapture\n    if (!distinctId) {\n      properties.$process_person_profile = false;\n    }\n    const exceptionProperties = await propertiesFromUnknownInput(this.stackParser, this.frameModifiers, error, hint);\n    return {\n      event: '$exception',\n      distinctId: distinctId || uuidv7(),\n      properties: {\n        ...exceptionProperties,\n        ...properties\n      }\n    };\n  }\n  constructor(client, options) {\n    this.client = client;\n    this._exceptionAutocaptureEnabled = options.enableExceptionAutocapture || false;\n    this.startAutocaptureIfEnabled();\n  }\n  startAutocaptureIfEnabled() {\n    if (this.isEnabled()) {\n      addUncaughtExceptionListener(this.onException.bind(this), this.onFatalError.bind(this));\n      addUnhandledRejectionListener(this.onException.bind(this));\n    }\n  }\n  onException(exception, hint) {\n    void ErrorTracking.buildEventMessage(exception, hint).then(msg => {\n      this.client.capture(msg);\n    });\n  }\n  async onFatalError() {\n    await this.client.shutdown(SHUTDOWN_TIMEOUT);\n  }\n  isEnabled() {\n    return !this.client.isDisabled && this._exceptionAutocaptureEnabled;\n  }\n}\n\nfunction setupExpressErrorHandler(_posthog, app) {\n  app.use((error, _, __, next) => {\n    const hint = {\n      mechanism: {\n        type: 'middleware',\n        handled: false\n      }\n    };\n    // Given stateless nature of Node SDK we capture exceptions using personless processing\n    // when no user can be determined e.g. in the case of exception autocapture\n    ErrorTracking.buildEventMessage(error, hint, uuidv7(), {\n      $process_person_profile: false\n    }).then(msg => _posthog.capture(msg));\n    next(error);\n  });\n}\n\n// Portions of this file are derived from getsentry/sentry-javascript by Software, Inc. dba Sentry\n/** Creates a function that gets the module name from a filename */\nfunction createGetModuleFromFilename(basePath = process.argv[1] ? (0,path__WEBPACK_IMPORTED_MODULE_0__.dirname)(process.argv[1]) : process.cwd(), isWindows = path__WEBPACK_IMPORTED_MODULE_0__.sep === '\\\\') {\n  const normalizedBase = isWindows ? normalizeWindowsPath(basePath) : basePath;\n  return filename => {\n    if (!filename) {\n      return;\n    }\n    const normalizedFilename = isWindows ? normalizeWindowsPath(filename) : filename;\n    // eslint-disable-next-line prefer-const\n    let {\n      dir,\n      base: file,\n      ext\n    } = path__WEBPACK_IMPORTED_MODULE_0__.posix.parse(normalizedFilename);\n    if (ext === '.js' || ext === '.mjs' || ext === '.cjs') {\n      file = file.slice(0, ext.length * -1);\n    }\n    // The file name might be URI-encoded which we want to decode to\n    // the original file name.\n    const decodedFile = decodeURIComponent(file);\n    if (!dir) {\n      // No dirname whatsoever\n      dir = '.';\n    }\n    const n = dir.lastIndexOf('/node_modules');\n    if (n > -1) {\n      return `${dir.slice(n + 14).replace(/\\//g, '.')}:${decodedFile}`;\n    }\n    // Let's see if it's a part of the main module\n    // To be a part of main module, it has to share the same base\n    if (dir.startsWith(normalizedBase)) {\n      const moduleName = dir.slice(normalizedBase.length + 1).replace(/\\//g, '.');\n      return moduleName ? `${moduleName}:${decodedFile}` : decodedFile;\n    }\n    return decodedFile;\n  };\n}\n/** normalizes Windows paths */\nfunction normalizeWindowsPath(path) {\n  return path.replace(/^[A-Z]:/, '') // remove Windows-style prefix\n  .replace(/\\\\/g, '/'); // replace all `\\` instances with `/`\n}\n\n// Portions of this file are derived from getsentry/sentry-javascript by Software, Inc. dba Sentry\n// Licensed under the MIT License\n/** A simple Least Recently Used map */\nclass ReduceableCache {\n  constructor(_maxSize) {\n    this._maxSize = _maxSize;\n    this._cache = new Map();\n  }\n  /** Get an entry or undefined if it was not in the cache. Re-inserts to update the recently used order */\n  get(key) {\n    const value = this._cache.get(key);\n    if (value === undefined) {\n      return undefined;\n    }\n    // Remove and re-insert to update the order\n    this._cache.delete(key);\n    this._cache.set(key, value);\n    return value;\n  }\n  /** Insert an entry and evict an older entry if we've reached maxSize */\n  set(key, value) {\n    this._cache.set(key, value);\n  }\n  /** Remove an entry and return the entry if it was in the cache */\n  reduce() {\n    while (this._cache.size >= this._maxSize) {\n      const value = this._cache.keys().next().value;\n      if (value) {\n        // keys() returns an iterator in insertion order so keys().next() gives us the oldest key\n        this._cache.delete(value);\n      }\n    }\n  }\n}\n\n// Portions of this file are derived from getsentry/sentry-javascript by Software, Inc. dba Sentry\nconst LRU_FILE_CONTENTS_CACHE = new ReduceableCache(25);\nconst LRU_FILE_CONTENTS_FS_READ_FAILED = new ReduceableCache(20);\nconst DEFAULT_LINES_OF_CONTEXT = 7;\n// Determines the upper bound of lineno/colno that we will attempt to read. Large colno values are likely to be\n// minified code while large lineno values are likely to be bundled code.\n// Exported for testing purposes.\nconst MAX_CONTEXTLINES_COLNO = 1000;\nconst MAX_CONTEXTLINES_LINENO = 10000;\nasync function addSourceContext(frames) {\n  // keep a lookup map of which files we've already enqueued to read,\n  // so we don't enqueue the same file multiple times which would cause multiple i/o reads\n  const filesToLines = {};\n  // Maps preserve insertion order, so we iterate in reverse, starting at the\n  // outermost frame and closer to where the exception has occurred (poor mans priority)\n  for (let i = frames.length - 1; i >= 0; i--) {\n    const frame = frames[i];\n    const filename = frame?.filename;\n    if (!frame || typeof filename !== 'string' || typeof frame.lineno !== 'number' || shouldSkipContextLinesForFile(filename) || shouldSkipContextLinesForFrame(frame)) {\n      continue;\n    }\n    const filesToLinesOutput = filesToLines[filename];\n    if (!filesToLinesOutput) {\n      filesToLines[filename] = [];\n    }\n    filesToLines[filename].push(frame.lineno);\n  }\n  const files = Object.keys(filesToLines);\n  if (files.length == 0) {\n    return frames;\n  }\n  const readlinePromises = [];\n  for (const file of files) {\n    // If we failed to read this before, dont try reading it again.\n    if (LRU_FILE_CONTENTS_FS_READ_FAILED.get(file)) {\n      continue;\n    }\n    const filesToLineRanges = filesToLines[file];\n    if (!filesToLineRanges) {\n      continue;\n    }\n    // Sort ranges so that they are sorted by line increasing order and match how the file is read.\n    filesToLineRanges.sort((a, b) => a - b);\n    // Check if the contents are already in the cache and if we can avoid reading the file again.\n    const ranges = makeLineReaderRanges(filesToLineRanges);\n    if (ranges.every(r => rangeExistsInContentCache(file, r))) {\n      continue;\n    }\n    const cache = emplace(LRU_FILE_CONTENTS_CACHE, file, {});\n    readlinePromises.push(getContextLinesFromFile(file, ranges, cache));\n  }\n  // The promise rejections are caught in order to prevent them from short circuiting Promise.all\n  await Promise.all(readlinePromises).catch(() => {});\n  // Perform the same loop as above, but this time we can assume all files are in the cache\n  // and attempt to add source context to frames.\n  if (frames && frames.length > 0) {\n    addSourceContextToFrames(frames, LRU_FILE_CONTENTS_CACHE);\n  }\n  // Once we're finished processing an exception reduce the files held in the cache\n  // so that we don't indefinetly increase the size of this map\n  LRU_FILE_CONTENTS_CACHE.reduce();\n  return frames;\n}\n/**\r\n * Extracts lines from a file and stores them in a cache.\r\n */\nfunction getContextLinesFromFile(path, ranges, output) {\n  return new Promise(resolve => {\n    // It is important *not* to have any async code between createInterface and the 'line' event listener\n    // as it will cause the 'line' event to\n    // be emitted before the listener is attached.\n    const stream = (0,node_fs__WEBPACK_IMPORTED_MODULE_1__.createReadStream)(path);\n    const lineReaded = (0,node_readline__WEBPACK_IMPORTED_MODULE_2__.createInterface)({\n      input: stream\n    });\n    // We need to explicitly destroy the stream to prevent memory leaks,\n    // removing the listeners on the readline interface is not enough.\n    // See: https://github.com/nodejs/node/issues/9002 and https://github.com/getsentry/sentry-javascript/issues/14892\n    function destroyStreamAndResolve() {\n      stream.destroy();\n      resolve();\n    }\n    // Init at zero and increment at the start of the loop because lines are 1 indexed.\n    let lineNumber = 0;\n    let currentRangeIndex = 0;\n    const range = ranges[currentRangeIndex];\n    if (range === undefined) {\n      // We should never reach this point, but if we do, we should resolve the promise to prevent it from hanging.\n      destroyStreamAndResolve();\n      return;\n    }\n    let rangeStart = range[0];\n    let rangeEnd = range[1];\n    // We use this inside Promise.all, so we need to resolve the promise even if there is an error\n    // to prevent Promise.all from short circuiting the rest.\n    function onStreamError() {\n      // Mark file path as failed to read and prevent multiple read attempts.\n      LRU_FILE_CONTENTS_FS_READ_FAILED.set(path, 1);\n      lineReaded.close();\n      lineReaded.removeAllListeners();\n      destroyStreamAndResolve();\n    }\n    // We need to handle the error event to prevent the process from crashing in < Node 16\n    // https://github.com/nodejs/node/pull/31603\n    stream.on('error', onStreamError);\n    lineReaded.on('error', onStreamError);\n    lineReaded.on('close', destroyStreamAndResolve);\n    lineReaded.on('line', line => {\n      lineNumber++;\n      if (lineNumber < rangeStart) {\n        return;\n      }\n      // !Warning: This mutates the cache by storing the snipped line into the cache.\n      output[lineNumber] = snipLine(line, 0);\n      if (lineNumber >= rangeEnd) {\n        if (currentRangeIndex === ranges.length - 1) {\n          // We need to close the file stream and remove listeners, else the reader will continue to run our listener;\n          lineReaded.close();\n          lineReaded.removeAllListeners();\n          return;\n        }\n        currentRangeIndex++;\n        const range = ranges[currentRangeIndex];\n        if (range === undefined) {\n          // This should never happen as it means we have a bug in the context.\n          lineReaded.close();\n          lineReaded.removeAllListeners();\n          return;\n        }\n        rangeStart = range[0];\n        rangeEnd = range[1];\n      }\n    });\n  });\n}\n/** Adds context lines to frames */\nfunction addSourceContextToFrames(frames, cache) {\n  for (const frame of frames) {\n    // Only add context if we have a filename and it hasn't already been added\n    if (frame.filename && frame.context_line === undefined && typeof frame.lineno === 'number') {\n      const contents = cache.get(frame.filename);\n      if (contents === undefined) {\n        continue;\n      }\n      addContextToFrame(frame.lineno, frame, contents);\n    }\n  }\n}\n/**\r\n * Resolves context lines before and after the given line number and appends them to the frame;\r\n */\nfunction addContextToFrame(lineno, frame, contents) {\n  // When there is no line number in the frame, attaching context is nonsensical and will even break grouping.\n  // We already check for lineno before calling this, but since StackFrame lineno is optional, we check it again.\n  if (frame.lineno === undefined || contents === undefined) {\n    return;\n  }\n  frame.pre_context = [];\n  for (let i = makeRangeStart(lineno); i < lineno; i++) {\n    // We always expect the start context as line numbers cannot be negative. If we dont find a line, then\n    // something went wrong somewhere. Clear the context and return without adding any linecontext.\n    const line = contents[i];\n    if (line === undefined) {\n      clearLineContext(frame);\n      return;\n    }\n    frame.pre_context.push(line);\n  }\n  // We should always have the context line. If we dont, something went wrong, so we clear the context and return\n  // without adding any linecontext.\n  if (contents[lineno] === undefined) {\n    clearLineContext(frame);\n    return;\n  }\n  frame.context_line = contents[lineno];\n  const end = makeRangeEnd(lineno);\n  frame.post_context = [];\n  for (let i = lineno + 1; i <= end; i++) {\n    // Since we dont track when the file ends, we cant clear the context if we dont find a line as it could\n    // just be that we reached the end of the file.\n    const line = contents[i];\n    if (line === undefined) {\n      break;\n    }\n    frame.post_context.push(line);\n  }\n}\n/**\r\n * Clears the context lines from a frame, used to reset a frame to its original state\r\n * if we fail to resolve all context lines for it.\r\n */\nfunction clearLineContext(frame) {\n  delete frame.pre_context;\n  delete frame.context_line;\n  delete frame.post_context;\n}\n/**\r\n * Determines if context lines should be skipped for a file.\r\n * - .min.(mjs|cjs|js) files are and not useful since they dont point to the original source\r\n * - node: prefixed modules are part of the runtime and cannot be resolved to a file\r\n * - data: skip json, wasm and inline js https://nodejs.org/api/esm.html#data-imports\r\n */\nfunction shouldSkipContextLinesForFile(path) {\n  // Test the most common prefix and extension first. These are the ones we\n  // are most likely to see in user applications and are the ones we can break out of first.\n  return path.startsWith('node:') || path.endsWith('.min.js') || path.endsWith('.min.cjs') || path.endsWith('.min.mjs') || path.startsWith('data:');\n}\n/**\r\n * Determines if we should skip contextlines based off the max lineno and colno values.\r\n */\nfunction shouldSkipContextLinesForFrame(frame) {\n  if (frame.lineno !== undefined && frame.lineno > MAX_CONTEXTLINES_LINENO) {\n    return true;\n  }\n  if (frame.colno !== undefined && frame.colno > MAX_CONTEXTLINES_COLNO) {\n    return true;\n  }\n  return false;\n}\n/**\r\n * Checks if we have all the contents that we need in the cache.\r\n */\nfunction rangeExistsInContentCache(file, range) {\n  const contents = LRU_FILE_CONTENTS_CACHE.get(file);\n  if (contents === undefined) {\n    return false;\n  }\n  for (let i = range[0]; i <= range[1]; i++) {\n    if (contents[i] === undefined) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\r\n * Creates contiguous ranges of lines to read from a file. In the case where context lines overlap,\r\n * the ranges are merged to create a single range.\r\n */\nfunction makeLineReaderRanges(lines) {\n  if (!lines.length) {\n    return [];\n  }\n  let i = 0;\n  const line = lines[0];\n  if (typeof line !== 'number') {\n    return [];\n  }\n  let current = makeContextRange(line);\n  const out = [];\n  while (true) {\n    if (i === lines.length - 1) {\n      out.push(current);\n      break;\n    }\n    // If the next line falls into the current range, extend the current range to lineno + linecontext.\n    const next = lines[i + 1];\n    if (typeof next !== 'number') {\n      break;\n    }\n    if (next <= current[1]) {\n      current[1] = next + DEFAULT_LINES_OF_CONTEXT;\n    } else {\n      out.push(current);\n      current = makeContextRange(next);\n    }\n    i++;\n  }\n  return out;\n}\n// Determine start and end indices for context range (inclusive);\nfunction makeContextRange(line) {\n  return [makeRangeStart(line), makeRangeEnd(line)];\n}\n// Compute inclusive end context range\nfunction makeRangeStart(line) {\n  return Math.max(1, line - DEFAULT_LINES_OF_CONTEXT);\n}\n// Compute inclusive start context range\nfunction makeRangeEnd(line) {\n  return line + DEFAULT_LINES_OF_CONTEXT;\n}\n/**\r\n * Get or init map value\r\n */\nfunction emplace(map, key, contents) {\n  const value = map.get(key);\n  if (value === undefined) {\n    map.set(key, contents);\n    return contents;\n  }\n  return value;\n}\nfunction snipLine(line, colno) {\n  let newLine = line;\n  const lineLength = newLine.length;\n  if (lineLength <= 150) {\n    return newLine;\n  }\n  if (colno > lineLength) {\n    colno = lineLength;\n  }\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n  let end = Math.min(start + 140, lineLength);\n  if (end > lineLength - 5) {\n    end = lineLength;\n  }\n  if (end === lineLength) {\n    start = Math.max(end - 140, 0);\n  }\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `...${newLine}`;\n  }\n  if (end < lineLength) {\n    newLine += '...';\n  }\n  return newLine;\n}\n\nvar version = \"5.6.0\";\n\nvar PostHogPersistedProperty;\r\n(function (PostHogPersistedProperty) {\r\n    PostHogPersistedProperty[\"AnonymousId\"] = \"anonymous_id\";\r\n    PostHogPersistedProperty[\"DistinctId\"] = \"distinct_id\";\r\n    PostHogPersistedProperty[\"Props\"] = \"props\";\r\n    PostHogPersistedProperty[\"FeatureFlagDetails\"] = \"feature_flag_details\";\r\n    PostHogPersistedProperty[\"FeatureFlags\"] = \"feature_flags\";\r\n    PostHogPersistedProperty[\"FeatureFlagPayloads\"] = \"feature_flag_payloads\";\r\n    PostHogPersistedProperty[\"BootstrapFeatureFlagDetails\"] = \"bootstrap_feature_flag_details\";\r\n    PostHogPersistedProperty[\"BootstrapFeatureFlags\"] = \"bootstrap_feature_flags\";\r\n    PostHogPersistedProperty[\"BootstrapFeatureFlagPayloads\"] = \"bootstrap_feature_flag_payloads\";\r\n    PostHogPersistedProperty[\"OverrideFeatureFlags\"] = \"override_feature_flags\";\r\n    PostHogPersistedProperty[\"Queue\"] = \"queue\";\r\n    PostHogPersistedProperty[\"OptedOut\"] = \"opted_out\";\r\n    PostHogPersistedProperty[\"SessionId\"] = \"session_id\";\r\n    PostHogPersistedProperty[\"SessionStartTimestamp\"] = \"session_start_timestamp\";\r\n    PostHogPersistedProperty[\"SessionLastTimestamp\"] = \"session_timestamp\";\r\n    PostHogPersistedProperty[\"PersonProperties\"] = \"person_properties\";\r\n    PostHogPersistedProperty[\"GroupProperties\"] = \"group_properties\";\r\n    PostHogPersistedProperty[\"InstalledAppBuild\"] = \"installed_app_build\";\r\n    PostHogPersistedProperty[\"InstalledAppVersion\"] = \"installed_app_version\";\r\n    PostHogPersistedProperty[\"SessionReplay\"] = \"session_replay\";\r\n    PostHogPersistedProperty[\"SurveyLastSeenDate\"] = \"survey_last_seen_date\";\r\n    PostHogPersistedProperty[\"SurveysSeen\"] = \"surveys_seen\";\r\n    PostHogPersistedProperty[\"Surveys\"] = \"surveys\";\r\n    PostHogPersistedProperty[\"RemoteConfig\"] = \"remote_config\";\r\n    PostHogPersistedProperty[\"FlagsEndpointWasHit\"] = \"flags_endpoint_was_hit\";\r\n})(PostHogPersistedProperty || (PostHogPersistedProperty = {}));\r\n// Any key prefixed with `attr__` can be added\r\nvar Compression;\r\n(function (Compression) {\r\n    Compression[\"GZipJS\"] = \"gzip-js\";\r\n    Compression[\"Base64\"] = \"base64\";\r\n})(Compression || (Compression = {}));\r\nvar SurveyPosition;\r\n(function (SurveyPosition) {\r\n    SurveyPosition[\"TopLeft\"] = \"top_left\";\r\n    SurveyPosition[\"TopCenter\"] = \"top_center\";\r\n    SurveyPosition[\"TopRight\"] = \"top_right\";\r\n    SurveyPosition[\"MiddleLeft\"] = \"middle_left\";\r\n    SurveyPosition[\"MiddleCenter\"] = \"middle_center\";\r\n    SurveyPosition[\"MiddleRight\"] = \"middle_right\";\r\n    SurveyPosition[\"Left\"] = \"left\";\r\n    SurveyPosition[\"Right\"] = \"right\";\r\n    SurveyPosition[\"Center\"] = \"center\";\r\n})(SurveyPosition || (SurveyPosition = {}));\r\nvar SurveyWidgetType;\r\n(function (SurveyWidgetType) {\r\n    SurveyWidgetType[\"Button\"] = \"button\";\r\n    SurveyWidgetType[\"Tab\"] = \"tab\";\r\n    SurveyWidgetType[\"Selector\"] = \"selector\";\r\n})(SurveyWidgetType || (SurveyWidgetType = {}));\r\nvar SurveyType;\r\n(function (SurveyType) {\r\n    SurveyType[\"Popover\"] = \"popover\";\r\n    SurveyType[\"API\"] = \"api\";\r\n    SurveyType[\"Widget\"] = \"widget\";\r\n})(SurveyType || (SurveyType = {}));\r\nvar SurveyQuestionDescriptionContentType;\r\n(function (SurveyQuestionDescriptionContentType) {\r\n    SurveyQuestionDescriptionContentType[\"Html\"] = \"html\";\r\n    SurveyQuestionDescriptionContentType[\"Text\"] = \"text\";\r\n})(SurveyQuestionDescriptionContentType || (SurveyQuestionDescriptionContentType = {}));\r\nvar SurveyRatingDisplay;\r\n(function (SurveyRatingDisplay) {\r\n    SurveyRatingDisplay[\"Number\"] = \"number\";\r\n    SurveyRatingDisplay[\"Emoji\"] = \"emoji\";\r\n})(SurveyRatingDisplay || (SurveyRatingDisplay = {}));\r\nvar SurveyQuestionType;\r\n(function (SurveyQuestionType) {\r\n    SurveyQuestionType[\"Open\"] = \"open\";\r\n    SurveyQuestionType[\"MultipleChoice\"] = \"multiple_choice\";\r\n    SurveyQuestionType[\"SingleChoice\"] = \"single_choice\";\r\n    SurveyQuestionType[\"Rating\"] = \"rating\";\r\n    SurveyQuestionType[\"Link\"] = \"link\";\r\n})(SurveyQuestionType || (SurveyQuestionType = {}));\r\nvar SurveyQuestionBranchingType;\r\n(function (SurveyQuestionBranchingType) {\r\n    SurveyQuestionBranchingType[\"NextQuestion\"] = \"next_question\";\r\n    SurveyQuestionBranchingType[\"End\"] = \"end\";\r\n    SurveyQuestionBranchingType[\"ResponseBased\"] = \"response_based\";\r\n    SurveyQuestionBranchingType[\"SpecificQuestion\"] = \"specific_question\";\r\n})(SurveyQuestionBranchingType || (SurveyQuestionBranchingType = {}));\r\nvar SurveyMatchType;\r\n(function (SurveyMatchType) {\r\n    SurveyMatchType[\"Regex\"] = \"regex\";\r\n    SurveyMatchType[\"NotRegex\"] = \"not_regex\";\r\n    SurveyMatchType[\"Exact\"] = \"exact\";\r\n    SurveyMatchType[\"IsNot\"] = \"is_not\";\r\n    SurveyMatchType[\"Icontains\"] = \"icontains\";\r\n    SurveyMatchType[\"NotIcontains\"] = \"not_icontains\";\r\n})(SurveyMatchType || (SurveyMatchType = {}));\r\n/** Sync with plugin-server/src/types.ts */\r\nvar ActionStepStringMatching;\r\n(function (ActionStepStringMatching) {\r\n    ActionStepStringMatching[\"Contains\"] = \"contains\";\r\n    ActionStepStringMatching[\"Exact\"] = \"exact\";\r\n    ActionStepStringMatching[\"Regex\"] = \"regex\";\r\n})(ActionStepStringMatching || (ActionStepStringMatching = {}));\n\nconst normalizeFlagsResponse = (flagsResponse) => {\r\n    if ('flags' in flagsResponse) {\r\n        // Convert v2 format to v1 format\r\n        const featureFlags = getFlagValuesFromFlags(flagsResponse.flags);\r\n        const featureFlagPayloads = getPayloadsFromFlags(flagsResponse.flags);\r\n        return {\r\n            ...flagsResponse,\r\n            featureFlags,\r\n            featureFlagPayloads,\r\n        };\r\n    }\r\n    else {\r\n        // Convert v1 format to v2 format\r\n        const featureFlags = flagsResponse.featureFlags ?? {};\r\n        const featureFlagPayloads = Object.fromEntries(Object.entries(flagsResponse.featureFlagPayloads || {}).map(([k, v]) => [k, parsePayload(v)]));\r\n        const flags = Object.fromEntries(Object.entries(featureFlags).map(([key, value]) => [\r\n            key,\r\n            getFlagDetailFromFlagAndPayload(key, value, featureFlagPayloads[key]),\r\n        ]));\r\n        return {\r\n            ...flagsResponse,\r\n            featureFlags,\r\n            featureFlagPayloads,\r\n            flags,\r\n        };\r\n    }\r\n};\r\nfunction getFlagDetailFromFlagAndPayload(key, value, payload) {\r\n    return {\r\n        key: key,\r\n        enabled: typeof value === 'string' ? true : value,\r\n        variant: typeof value === 'string' ? value : undefined,\r\n        reason: undefined,\r\n        metadata: {\r\n            id: undefined,\r\n            version: undefined,\r\n            payload: payload ? JSON.stringify(payload) : undefined,\r\n            description: undefined,\r\n        },\r\n    };\r\n}\r\n/**\r\n * Get the flag values from the flags v4 response.\r\n * @param flags - The flags\r\n * @returns The flag values\r\n */\r\nconst getFlagValuesFromFlags = (flags) => {\r\n    return Object.fromEntries(Object.entries(flags ?? {})\r\n        .map(([key, detail]) => [key, getFeatureFlagValue(detail)])\r\n        .filter(([, value]) => value !== undefined));\r\n};\r\n/**\r\n * Get the payloads from the flags v4 response.\r\n * @param flags - The flags\r\n * @returns The payloads\r\n */\r\nconst getPayloadsFromFlags = (flags) => {\r\n    const safeFlags = flags ?? {};\r\n    return Object.fromEntries(Object.keys(safeFlags)\r\n        .filter((flag) => {\r\n        const details = safeFlags[flag];\r\n        return details.enabled && details.metadata && details.metadata.payload !== undefined;\r\n    })\r\n        .map((flag) => {\r\n        const payload = safeFlags[flag].metadata?.payload;\r\n        return [flag, payload ? parsePayload(payload) : undefined];\r\n    }));\r\n};\r\nconst getFeatureFlagValue = (detail) => {\r\n    return detail === undefined ? undefined : detail.variant ?? detail.enabled;\r\n};\r\nconst parsePayload = (response) => {\r\n    if (typeof response !== 'string') {\r\n        return response;\r\n    }\r\n    try {\r\n        return JSON.parse(response);\r\n    }\r\n    catch {\r\n        return response;\r\n    }\r\n};\n\nconst STRING_FORMAT = 'utf8';\r\nfunction assert(truthyValue, message) {\r\n    if (!truthyValue || typeof truthyValue !== 'string' || isEmpty(truthyValue)) {\r\n        throw new Error(message);\r\n    }\r\n}\r\nfunction isEmpty(truthyValue) {\r\n    if (truthyValue.trim().length === 0) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfunction removeTrailingSlash(url) {\r\n    return url?.replace(/\\/+$/, '');\r\n}\r\nasync function retriable(fn, props) {\r\n    let lastError = null;\r\n    for (let i = 0; i < props.retryCount + 1; i++) {\r\n        if (i > 0) {\r\n            // don't wait when it's the last try\r\n            await new Promise((r) => setTimeout(r, props.retryDelay));\r\n        }\r\n        try {\r\n            const res = await fn();\r\n            return res;\r\n        }\r\n        catch (e) {\r\n            lastError = e;\r\n            if (!props.retryCheck(e)) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    throw lastError;\r\n}\r\nfunction currentISOTime() {\r\n    return new Date().toISOString();\r\n}\r\nfunction safeSetTimeout(fn, timeout) {\r\n    // NOTE: we use this so rarely that it is totally fine to do `safeSetTimeout(fn, 0)``\r\n    // rather than setImmediate.\r\n    const t = setTimeout(fn, timeout);\r\n    // We unref if available to prevent Node.js hanging on exit\r\n    t?.unref && t?.unref();\r\n    return t;\r\n}\r\nfunction allSettled(promises) {\r\n    return Promise.all(promises.map((p) => (p ?? Promise.resolve()).then((value) => ({ status: 'fulfilled', value }), (reason) => ({ status: 'rejected', reason }))));\r\n}\n\n/**\r\n * Older browsers and some runtimes don't support this yet\r\n * This API (as of 2025-05-07) is not available on React Native.\r\n */\r\nfunction isGzipSupported() {\r\n    return 'CompressionStream' in globalThis;\r\n}\r\n/**\r\n * Gzip a string using Compression Streams API if it's available\r\n */\r\nasync function gzipCompress(input, isDebug = true) {\r\n    try {\r\n        // Turn the string into a stream using a Blob, and then compress it\r\n        const dataStream = new Blob([input], {\r\n            type: 'text/plain',\r\n        }).stream();\r\n        const compressedStream = dataStream.pipeThrough(new CompressionStream('gzip'));\r\n        // Using a Response to easily extract the readablestream value. Decoding into a string for fetch\r\n        return await new Response(compressedStream).blob();\r\n    }\r\n    catch (error) {\r\n        if (isDebug) {\r\n            console.error('Failed to gzip compress data', error);\r\n        }\r\n        return null;\r\n    }\r\n}\n\nclass SimpleEventEmitter {\r\n    constructor() {\r\n        this.events = {};\r\n        this.events = {};\r\n    }\r\n    on(event, listener) {\r\n        if (!this.events[event]) {\r\n            this.events[event] = [];\r\n        }\r\n        this.events[event].push(listener);\r\n        return () => {\r\n            this.events[event] = this.events[event].filter((x) => x !== listener);\r\n        };\r\n    }\r\n    emit(event, payload) {\r\n        for (const listener of this.events[event] || []) {\r\n            listener(payload);\r\n        }\r\n        for (const listener of this.events['*'] || []) {\r\n            listener(event, payload);\r\n        }\r\n    }\r\n}\n\nclass PostHogFetchHttpError extends Error {\r\n    constructor(response, reqByteLength) {\r\n        super('HTTP error while fetching PostHog: status=' + response.status + ', reqByteLength=' + reqByteLength);\r\n        this.response = response;\r\n        this.reqByteLength = reqByteLength;\r\n        this.name = 'PostHogFetchHttpError';\r\n    }\r\n    get status() {\r\n        return this.response.status;\r\n    }\r\n    get text() {\r\n        return this.response.text();\r\n    }\r\n    get json() {\r\n        return this.response.json();\r\n    }\r\n}\r\nclass PostHogFetchNetworkError extends Error {\r\n    constructor(error) {\r\n        // TRICKY: \"cause\" is a newer property but is just ignored otherwise. Cast to any to ignore the type issue.\r\n        // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\r\n        // @ts-ignore\r\n        super('Network error while fetching PostHog', error instanceof Error ? { cause: error } : {});\r\n        this.error = error;\r\n        this.name = 'PostHogFetchNetworkError';\r\n    }\r\n}\r\nasync function logFlushError(err) {\r\n    if (err instanceof PostHogFetchHttpError) {\r\n        let text = '';\r\n        try {\r\n            text = await err.text;\r\n        }\r\n        catch { }\r\n        console.error(`Error while flushing PostHog: message=${err.message}, response body=${text}`, err);\r\n    }\r\n    else {\r\n        console.error('Error while flushing PostHog', err);\r\n    }\r\n    return Promise.resolve();\r\n}\r\nfunction isPostHogFetchError(err) {\r\n    return typeof err === 'object' && (err instanceof PostHogFetchHttpError || err instanceof PostHogFetchNetworkError);\r\n}\r\nfunction isPostHogFetchContentTooLargeError(err) {\r\n    return typeof err === 'object' && err instanceof PostHogFetchHttpError && err.status === 413;\r\n}\r\nvar QuotaLimitedFeature;\r\n(function (QuotaLimitedFeature) {\r\n    QuotaLimitedFeature[\"FeatureFlags\"] = \"feature_flags\";\r\n    QuotaLimitedFeature[\"Recordings\"] = \"recordings\";\r\n})(QuotaLimitedFeature || (QuotaLimitedFeature = {}));\r\nclass PostHogCoreStateless {\r\n    constructor(apiKey, options) {\r\n        this.flushPromise = null;\r\n        this.shutdownPromise = null;\r\n        this.pendingPromises = {};\r\n        // internal\r\n        this._events = new SimpleEventEmitter();\r\n        this._isInitialized = false;\r\n        assert(apiKey, \"You must pass your PostHog project's api key.\");\r\n        this.apiKey = apiKey;\r\n        this.host = removeTrailingSlash(options?.host || 'https://us.i.posthog.com');\r\n        this.flushAt = options?.flushAt ? Math.max(options?.flushAt, 1) : 20;\r\n        this.maxBatchSize = Math.max(this.flushAt, options?.maxBatchSize ?? 100);\r\n        this.maxQueueSize = Math.max(this.flushAt, options?.maxQueueSize ?? 1000);\r\n        this.flushInterval = options?.flushInterval ?? 10000;\r\n        this.preloadFeatureFlags = options?.preloadFeatureFlags ?? true;\r\n        // If enable is explicitly set to false we override the optout\r\n        this.defaultOptIn = options?.defaultOptIn ?? true;\r\n        this.disableSurveys = options?.disableSurveys ?? false;\r\n        this._retryOptions = {\r\n            retryCount: options?.fetchRetryCount ?? 3,\r\n            retryDelay: options?.fetchRetryDelay ?? 3000,\r\n            retryCheck: isPostHogFetchError,\r\n        };\r\n        this.requestTimeout = options?.requestTimeout ?? 10000; // 10 seconds\r\n        this.featureFlagsRequestTimeoutMs = options?.featureFlagsRequestTimeoutMs ?? 3000; // 3 seconds\r\n        this.remoteConfigRequestTimeoutMs = options?.remoteConfigRequestTimeoutMs ?? 3000; // 3 seconds\r\n        this.disableGeoip = options?.disableGeoip ?? true;\r\n        this.disabled = options?.disabled ?? false;\r\n        this.historicalMigration = options?.historicalMigration ?? false;\r\n        // Init promise allows the derived class to block calls until it is ready\r\n        this._initPromise = Promise.resolve();\r\n        this._isInitialized = true;\r\n        this.disableCompression = !isGzipSupported() || (options?.disableCompression ?? false);\r\n    }\r\n    logMsgIfDebug(fn) {\r\n        if (this.isDebug) {\r\n            fn();\r\n        }\r\n    }\r\n    wrap(fn) {\r\n        if (this.disabled) {\r\n            this.logMsgIfDebug(() => console.warn('[PostHog] The client is disabled'));\r\n            return;\r\n        }\r\n        if (this._isInitialized) {\r\n            // NOTE: We could also check for the \"opt in\" status here...\r\n            return fn();\r\n        }\r\n        this._initPromise.then(() => fn());\r\n    }\r\n    getCommonEventProperties() {\r\n        return {\r\n            $lib: this.getLibraryId(),\r\n            $lib_version: this.getLibraryVersion(),\r\n        };\r\n    }\r\n    get optedOut() {\r\n        return this.getPersistedProperty(PostHogPersistedProperty.OptedOut) ?? !this.defaultOptIn;\r\n    }\r\n    async optIn() {\r\n        this.wrap(() => {\r\n            this.setPersistedProperty(PostHogPersistedProperty.OptedOut, false);\r\n        });\r\n    }\r\n    async optOut() {\r\n        this.wrap(() => {\r\n            this.setPersistedProperty(PostHogPersistedProperty.OptedOut, true);\r\n        });\r\n    }\r\n    on(event, cb) {\r\n        return this._events.on(event, cb);\r\n    }\r\n    debug(enabled = true) {\r\n        this.removeDebugCallback?.();\r\n        if (enabled) {\r\n            const removeDebugCallback = this.on('*', (event, payload) => console.log('PostHog Debug', event, payload));\r\n            this.removeDebugCallback = () => {\r\n                removeDebugCallback();\r\n                this.removeDebugCallback = undefined;\r\n            };\r\n        }\r\n    }\r\n    get isDebug() {\r\n        return !!this.removeDebugCallback;\r\n    }\r\n    get isDisabled() {\r\n        return this.disabled;\r\n    }\r\n    buildPayload(payload) {\r\n        return {\r\n            distinct_id: payload.distinct_id,\r\n            event: payload.event,\r\n            properties: {\r\n                ...(payload.properties || {}),\r\n                ...this.getCommonEventProperties(), // Common PH props\r\n            },\r\n        };\r\n    }\r\n    addPendingPromise(promise) {\r\n        const promiseUUID = uuidv7();\r\n        this.pendingPromises[promiseUUID] = promise;\r\n        promise\r\n            .catch(() => { })\r\n            .finally(() => {\r\n            delete this.pendingPromises[promiseUUID];\r\n        });\r\n        return promise;\r\n    }\r\n    /***\r\n     *** TRACKING\r\n     ***/\r\n    identifyStateless(distinctId, properties, options) {\r\n        this.wrap(() => {\r\n            // The properties passed to identifyStateless are event properties.\r\n            // To add person properties, pass in all person properties to the `$set` and `$set_once` keys.\r\n            const payload = {\r\n                ...this.buildPayload({\r\n                    distinct_id: distinctId,\r\n                    event: '$identify',\r\n                    properties,\r\n                }),\r\n            };\r\n            this.enqueue('identify', payload, options);\r\n        });\r\n    }\r\n    async identifyStatelessImmediate(distinctId, properties, options) {\r\n        const payload = {\r\n            ...this.buildPayload({\r\n                distinct_id: distinctId,\r\n                event: '$identify',\r\n                properties,\r\n            }),\r\n        };\r\n        await this.sendImmediate('identify', payload, options);\r\n    }\r\n    captureStateless(distinctId, event, properties, options) {\r\n        this.wrap(() => {\r\n            const payload = this.buildPayload({ distinct_id: distinctId, event, properties });\r\n            this.enqueue('capture', payload, options);\r\n        });\r\n    }\r\n    async captureStatelessImmediate(distinctId, event, properties, options) {\r\n        const payload = this.buildPayload({ distinct_id: distinctId, event, properties });\r\n        await this.sendImmediate('capture', payload, options);\r\n    }\r\n    aliasStateless(alias, distinctId, properties, options) {\r\n        this.wrap(() => {\r\n            const payload = this.buildPayload({\r\n                event: '$create_alias',\r\n                distinct_id: distinctId,\r\n                properties: {\r\n                    ...(properties || {}),\r\n                    distinct_id: distinctId,\r\n                    alias,\r\n                },\r\n            });\r\n            this.enqueue('alias', payload, options);\r\n        });\r\n    }\r\n    async aliasStatelessImmediate(alias, distinctId, properties, options) {\r\n        const payload = this.buildPayload({\r\n            event: '$create_alias',\r\n            distinct_id: distinctId,\r\n            properties: {\r\n                ...(properties || {}),\r\n                distinct_id: distinctId,\r\n                alias,\r\n            },\r\n        });\r\n        await this.sendImmediate('alias', payload, options);\r\n    }\r\n    /***\r\n     *** GROUPS\r\n     ***/\r\n    groupIdentifyStateless(groupType, groupKey, groupProperties, options, distinctId, eventProperties) {\r\n        this.wrap(() => {\r\n            const payload = this.buildPayload({\r\n                distinct_id: distinctId || `$${groupType}_${groupKey}`,\r\n                event: '$groupidentify',\r\n                properties: {\r\n                    $group_type: groupType,\r\n                    $group_key: groupKey,\r\n                    $group_set: groupProperties || {},\r\n                    ...(eventProperties || {}),\r\n                },\r\n            });\r\n            this.enqueue('capture', payload, options);\r\n        });\r\n    }\r\n    async getRemoteConfig() {\r\n        await this._initPromise;\r\n        let host = this.host;\r\n        if (host === 'https://us.i.posthog.com') {\r\n            host = 'https://us-assets.i.posthog.com';\r\n        }\r\n        else if (host === 'https://eu.i.posthog.com') {\r\n            host = 'https://eu-assets.i.posthog.com';\r\n        }\r\n        const url = `${host}/array/${this.apiKey}/config`;\r\n        const fetchOptions = {\r\n            method: 'GET',\r\n            headers: { ...this.getCustomHeaders(), 'Content-Type': 'application/json' },\r\n        };\r\n        // Don't retry remote config API calls\r\n        return this.fetchWithRetry(url, fetchOptions, { retryCount: 0 }, this.remoteConfigRequestTimeoutMs)\r\n            .then((response) => response.json())\r\n            .catch((error) => {\r\n            this.logMsgIfDebug(() => console.error('Remote config could not be loaded', error));\r\n            this._events.emit('error', error);\r\n            return undefined;\r\n        });\r\n    }\r\n    /***\r\n     *** FEATURE FLAGS\r\n     ***/\r\n    async getFlags(distinctId, groups = {}, personProperties = {}, groupProperties = {}, extraPayload = {}) {\r\n        await this._initPromise;\r\n        const url = `${this.host}/flags/?v=2&config=true`;\r\n        const fetchOptions = {\r\n            method: 'POST',\r\n            headers: { ...this.getCustomHeaders(), 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n                token: this.apiKey,\r\n                distinct_id: distinctId,\r\n                groups,\r\n                person_properties: personProperties,\r\n                group_properties: groupProperties,\r\n                ...extraPayload,\r\n            }),\r\n        };\r\n        this.logMsgIfDebug(() => console.log('PostHog Debug', 'Flags URL', url));\r\n        // Don't retry /flags API calls\r\n        return this.fetchWithRetry(url, fetchOptions, { retryCount: 0 }, this.featureFlagsRequestTimeoutMs)\r\n            .then((response) => response.json())\r\n            .then((response) => normalizeFlagsResponse(response))\r\n            .catch((error) => {\r\n            this._events.emit('error', error);\r\n            return undefined;\r\n        });\r\n    }\r\n    async getFeatureFlagStateless(key, distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {\r\n        await this._initPromise;\r\n        const flagDetailResponse = await this.getFeatureFlagDetailStateless(key, distinctId, groups, personProperties, groupProperties, disableGeoip);\r\n        if (flagDetailResponse === undefined) {\r\n            // If we haven't loaded flags yet, or errored out, we respond with undefined\r\n            return {\r\n                response: undefined,\r\n                requestId: undefined,\r\n            };\r\n        }\r\n        let response = getFeatureFlagValue(flagDetailResponse.response);\r\n        if (response === undefined) {\r\n            // For cases where the flag is unknown, return false\r\n            response = false;\r\n        }\r\n        // If we have flags we either return the value (true or string) or false\r\n        return {\r\n            response,\r\n            requestId: flagDetailResponse.requestId,\r\n        };\r\n    }\r\n    async getFeatureFlagDetailStateless(key, distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {\r\n        await this._initPromise;\r\n        const flagsResponse = await this.getFeatureFlagDetailsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip, [key]);\r\n        if (flagsResponse === undefined) {\r\n            return undefined;\r\n        }\r\n        const featureFlags = flagsResponse.flags;\r\n        const flagDetail = featureFlags[key];\r\n        return {\r\n            response: flagDetail,\r\n            requestId: flagsResponse.requestId,\r\n        };\r\n    }\r\n    async getFeatureFlagPayloadStateless(key, distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip) {\r\n        await this._initPromise;\r\n        const payloads = await this.getFeatureFlagPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip, [key]);\r\n        if (!payloads) {\r\n            return undefined;\r\n        }\r\n        const response = payloads[key];\r\n        // Undefined means a loading or missing data issue. Null means evaluation happened and there was no match\r\n        if (response === undefined) {\r\n            return null;\r\n        }\r\n        return response;\r\n    }\r\n    async getFeatureFlagPayloadsStateless(distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip, flagKeysToEvaluate) {\r\n        await this._initPromise;\r\n        const payloads = (await this.getFeatureFlagsAndPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip, flagKeysToEvaluate)).payloads;\r\n        return payloads;\r\n    }\r\n    async getFeatureFlagsStateless(distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip, flagKeysToEvaluate) {\r\n        await this._initPromise;\r\n        return await this.getFeatureFlagsAndPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip, flagKeysToEvaluate);\r\n    }\r\n    async getFeatureFlagsAndPayloadsStateless(distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip, flagKeysToEvaluate) {\r\n        await this._initPromise;\r\n        const featureFlagDetails = await this.getFeatureFlagDetailsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip, flagKeysToEvaluate);\r\n        if (!featureFlagDetails) {\r\n            return {\r\n                flags: undefined,\r\n                payloads: undefined,\r\n                requestId: undefined,\r\n            };\r\n        }\r\n        return {\r\n            flags: featureFlagDetails.featureFlags,\r\n            payloads: featureFlagDetails.featureFlagPayloads,\r\n            requestId: featureFlagDetails.requestId,\r\n        };\r\n    }\r\n    async getFeatureFlagDetailsStateless(distinctId, groups = {}, personProperties = {}, groupProperties = {}, disableGeoip, flagKeysToEvaluate) {\r\n        await this._initPromise;\r\n        const extraPayload = {};\r\n        if (disableGeoip ?? this.disableGeoip) {\r\n            extraPayload['geoip_disable'] = true;\r\n        }\r\n        if (flagKeysToEvaluate) {\r\n            extraPayload['flag_keys_to_evaluate'] = flagKeysToEvaluate;\r\n        }\r\n        const flagsResponse = await this.getFlags(distinctId, groups, personProperties, groupProperties, extraPayload);\r\n        if (flagsResponse === undefined) {\r\n            // We probably errored out, so return undefined\r\n            return undefined;\r\n        }\r\n        // if there's an error on the flagsResponse, log a console error, but don't throw an error\r\n        if (flagsResponse.errorsWhileComputingFlags) {\r\n            console.error('[FEATURE FLAGS] Error while computing feature flags, some flags may be missing or incorrect. Learn more at https://posthog.com/docs/feature-flags/best-practices');\r\n        }\r\n        // Add check for quota limitation on feature flags\r\n        if (flagsResponse.quotaLimited?.includes(QuotaLimitedFeature.FeatureFlags)) {\r\n            console.warn('[FEATURE FLAGS] Feature flags quota limit exceeded - feature flags unavailable. Learn more about billing limits at https://posthog.com/docs/billing/limits-alerts');\r\n            return {\r\n                flags: {},\r\n                featureFlags: {},\r\n                featureFlagPayloads: {},\r\n                requestId: flagsResponse?.requestId,\r\n            };\r\n        }\r\n        return flagsResponse;\r\n    }\r\n    /***\r\n     *** SURVEYS\r\n     ***/\r\n    async getSurveysStateless() {\r\n        await this._initPromise;\r\n        if (this.disableSurveys === true) {\r\n            this.logMsgIfDebug(() => console.log('PostHog Debug', 'Loading surveys is disabled.'));\r\n            return [];\r\n        }\r\n        const url = `${this.host}/api/surveys/?token=${this.apiKey}`;\r\n        const fetchOptions = {\r\n            method: 'GET',\r\n            headers: { ...this.getCustomHeaders(), 'Content-Type': 'application/json' },\r\n        };\r\n        const response = await this.fetchWithRetry(url, fetchOptions)\r\n            .then((response) => {\r\n            if (response.status !== 200 || !response.json) {\r\n                const msg = `Surveys API could not be loaded: ${response.status}`;\r\n                const error = new Error(msg);\r\n                this.logMsgIfDebug(() => console.error(error));\r\n                this._events.emit('error', new Error(msg));\r\n                return undefined;\r\n            }\r\n            return response.json();\r\n        })\r\n            .catch((error) => {\r\n            this.logMsgIfDebug(() => console.error('Surveys API could not be loaded', error));\r\n            this._events.emit('error', error);\r\n            return undefined;\r\n        });\r\n        const newSurveys = response?.surveys;\r\n        if (newSurveys) {\r\n            this.logMsgIfDebug(() => console.log('PostHog Debug', 'Surveys fetched from API: ', JSON.stringify(newSurveys)));\r\n        }\r\n        return newSurveys ?? [];\r\n    }\r\n    get props() {\r\n        if (!this._props) {\r\n            this._props = this.getPersistedProperty(PostHogPersistedProperty.Props);\r\n        }\r\n        return this._props || {};\r\n    }\r\n    set props(val) {\r\n        this._props = val;\r\n    }\r\n    async register(properties) {\r\n        this.wrap(() => {\r\n            this.props = {\r\n                ...this.props,\r\n                ...properties,\r\n            };\r\n            this.setPersistedProperty(PostHogPersistedProperty.Props, this.props);\r\n        });\r\n    }\r\n    async unregister(property) {\r\n        this.wrap(() => {\r\n            delete this.props[property];\r\n            this.setPersistedProperty(PostHogPersistedProperty.Props, this.props);\r\n        });\r\n    }\r\n    /***\r\n     *** QUEUEING AND FLUSHING\r\n     ***/\r\n    enqueue(type, _message, options) {\r\n        this.wrap(() => {\r\n            if (this.optedOut) {\r\n                this._events.emit(type, `Library is disabled. Not sending event. To re-enable, call posthog.optIn()`);\r\n                return;\r\n            }\r\n            const message = this.prepareMessage(type, _message, options);\r\n            const queue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];\r\n            if (queue.length >= this.maxQueueSize) {\r\n                queue.shift();\r\n                this.logMsgIfDebug(() => console.info('Queue is full, the oldest event is dropped.'));\r\n            }\r\n            queue.push({ message });\r\n            this.setPersistedProperty(PostHogPersistedProperty.Queue, queue);\r\n            this._events.emit(type, message);\r\n            // Flush queued events if we meet the flushAt length\r\n            if (queue.length >= this.flushAt) {\r\n                this.flushBackground();\r\n            }\r\n            if (this.flushInterval && !this._flushTimer) {\r\n                this._flushTimer = safeSetTimeout(() => this.flushBackground(), this.flushInterval);\r\n            }\r\n        });\r\n    }\r\n    async sendImmediate(type, _message, options) {\r\n        if (this.disabled) {\r\n            this.logMsgIfDebug(() => console.warn('[PostHog] The client is disabled'));\r\n            return;\r\n        }\r\n        if (!this._isInitialized) {\r\n            await this._initPromise;\r\n        }\r\n        if (this.optedOut) {\r\n            this._events.emit(type, `Library is disabled. Not sending event. To re-enable, call posthog.optIn()`);\r\n            return;\r\n        }\r\n        const data = {\r\n            api_key: this.apiKey,\r\n            batch: [this.prepareMessage(type, _message, options)],\r\n            sent_at: currentISOTime(),\r\n        };\r\n        if (this.historicalMigration) {\r\n            data.historical_migration = true;\r\n        }\r\n        const payload = JSON.stringify(data);\r\n        const url = `${this.host}/batch/`;\r\n        const gzippedPayload = !this.disableCompression ? await gzipCompress(payload, this.isDebug) : null;\r\n        const fetchOptions = {\r\n            method: 'POST',\r\n            headers: {\r\n                ...this.getCustomHeaders(),\r\n                'Content-Type': 'application/json',\r\n                ...(gzippedPayload !== null && { 'Content-Encoding': 'gzip' }),\r\n            },\r\n            body: gzippedPayload || payload,\r\n        };\r\n        try {\r\n            await this.fetchWithRetry(url, fetchOptions);\r\n        }\r\n        catch (err) {\r\n            this._events.emit('error', err);\r\n        }\r\n    }\r\n    prepareMessage(type, _message, options) {\r\n        const message = {\r\n            ..._message,\r\n            type: type,\r\n            library: this.getLibraryId(),\r\n            library_version: this.getLibraryVersion(),\r\n            timestamp: options?.timestamp ? options?.timestamp : currentISOTime(),\r\n            uuid: options?.uuid ? options.uuid : uuidv7(),\r\n        };\r\n        const addGeoipDisableProperty = options?.disableGeoip ?? this.disableGeoip;\r\n        if (addGeoipDisableProperty) {\r\n            if (!message.properties) {\r\n                message.properties = {};\r\n            }\r\n            message['properties']['$geoip_disable'] = true;\r\n        }\r\n        if (message.distinctId) {\r\n            message.distinct_id = message.distinctId;\r\n            delete message.distinctId;\r\n        }\r\n        return message;\r\n    }\r\n    clearFlushTimer() {\r\n        if (this._flushTimer) {\r\n            clearTimeout(this._flushTimer);\r\n            this._flushTimer = undefined;\r\n        }\r\n    }\r\n    /**\r\n     * Helper for flushing the queue in the background\r\n     * Avoids unnecessary promise errors\r\n     */\r\n    flushBackground() {\r\n        void this.flush().catch(async (err) => {\r\n            await logFlushError(err);\r\n        });\r\n    }\r\n    /**\r\n     * Flushes the queue\r\n     *\r\n     * This function will return a promise that will resolve when the flush is complete,\r\n     * or reject if there was an error (for example if the server or network is down).\r\n     *\r\n     * If there is already a flush in progress, this function will wait for that flush to complete.\r\n     *\r\n     * It's recommended to do error handling in the callback of the promise.\r\n     *\r\n     * @example\r\n     * posthog.flush().then(() => {\r\n     *   console.log('Flush complete')\r\n     * }).catch((err) => {\r\n     *   console.error('Flush failed', err)\r\n     * })\r\n     *\r\n     *\r\n     * @throws PostHogFetchHttpError\r\n     * @throws PostHogFetchNetworkError\r\n     * @throws Error\r\n     */\r\n    async flush() {\r\n        // Wait for the current flush operation to finish (regardless of success or failure), then try to flush again.\r\n        // Use allSettled instead of finally to be defensive around flush throwing errors immediately rather than rejecting.\r\n        // Use a custom allSettled implementation to avoid issues with patching Promise on RN\r\n        const nextFlushPromise = allSettled([this.flushPromise]).then(() => {\r\n            return this._flush();\r\n        });\r\n        this.flushPromise = nextFlushPromise;\r\n        void this.addPendingPromise(nextFlushPromise);\r\n        allSettled([nextFlushPromise]).then(() => {\r\n            // If there are no others waiting to flush, clear the promise.\r\n            // We don't strictly need to do this, but it could make debugging easier\r\n            if (this.flushPromise === nextFlushPromise) {\r\n                this.flushPromise = null;\r\n            }\r\n        });\r\n        return nextFlushPromise;\r\n    }\r\n    getCustomHeaders() {\r\n        // Don't set the user agent if we're not on a browser. The latest spec allows\r\n        // the User-Agent header (see https://fetch.spec.whatwg.org/#terminology-headers\r\n        // and https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader),\r\n        // but browsers such as Chrome and Safari have not caught up.\r\n        const customUserAgent = this.getCustomUserAgent();\r\n        const headers = {};\r\n        if (customUserAgent && customUserAgent !== '') {\r\n            headers['User-Agent'] = customUserAgent;\r\n        }\r\n        return headers;\r\n    }\r\n    async _flush() {\r\n        this.clearFlushTimer();\r\n        await this._initPromise;\r\n        let queue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];\r\n        if (!queue.length) {\r\n            return;\r\n        }\r\n        const sentMessages = [];\r\n        const originalQueueLength = queue.length;\r\n        while (queue.length > 0 && sentMessages.length < originalQueueLength) {\r\n            const batchItems = queue.slice(0, this.maxBatchSize);\r\n            const batchMessages = batchItems.map((item) => item.message);\r\n            const persistQueueChange = () => {\r\n                const refreshedQueue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];\r\n                const newQueue = refreshedQueue.slice(batchItems.length);\r\n                this.setPersistedProperty(PostHogPersistedProperty.Queue, newQueue);\r\n                queue = newQueue;\r\n            };\r\n            const data = {\r\n                api_key: this.apiKey,\r\n                batch: batchMessages,\r\n                sent_at: currentISOTime(),\r\n            };\r\n            if (this.historicalMigration) {\r\n                data.historical_migration = true;\r\n            }\r\n            const payload = JSON.stringify(data);\r\n            const url = `${this.host}/batch/`;\r\n            const gzippedPayload = !this.disableCompression ? await gzipCompress(payload, this.isDebug) : null;\r\n            const fetchOptions = {\r\n                method: 'POST',\r\n                headers: {\r\n                    ...this.getCustomHeaders(),\r\n                    'Content-Type': 'application/json',\r\n                    ...(gzippedPayload !== null && { 'Content-Encoding': 'gzip' }),\r\n                },\r\n                body: gzippedPayload || payload,\r\n            };\r\n            const retryOptions = {\r\n                retryCheck: (err) => {\r\n                    // don't automatically retry on 413 errors, we want to reduce the batch size first\r\n                    if (isPostHogFetchContentTooLargeError(err)) {\r\n                        return false;\r\n                    }\r\n                    // otherwise, retry on network errors\r\n                    return isPostHogFetchError(err);\r\n                },\r\n            };\r\n            try {\r\n                await this.fetchWithRetry(url, fetchOptions, retryOptions);\r\n            }\r\n            catch (err) {\r\n                if (isPostHogFetchContentTooLargeError(err) && batchMessages.length > 1) {\r\n                    // if we get a 413 error, we want to reduce the batch size and try again\r\n                    this.maxBatchSize = Math.max(1, Math.floor(batchMessages.length / 2));\r\n                    this.logMsgIfDebug(() => console.warn(`Received 413 when sending batch of size ${batchMessages.length}, reducing batch size to ${this.maxBatchSize}`));\r\n                    // do not persist the queue change, we want to retry the same batch\r\n                    continue;\r\n                }\r\n                // depending on the error type, eg a malformed JSON or broken queue, it'll always return an error\r\n                // and this will be an endless loop, in this case, if the error isn't a network issue, we always remove the items from the queue\r\n                if (!(err instanceof PostHogFetchNetworkError)) {\r\n                    persistQueueChange();\r\n                }\r\n                this._events.emit('error', err);\r\n                throw err;\r\n            }\r\n            persistQueueChange();\r\n            sentMessages.push(...batchMessages);\r\n        }\r\n        this._events.emit('flush', sentMessages);\r\n    }\r\n    async fetchWithRetry(url, options, retryOptions, requestTimeout) {\r\n        var _a;\r\n        (_a = AbortSignal).timeout ?? (_a.timeout = function timeout(ms) {\r\n            const ctrl = new AbortController();\r\n            setTimeout(() => ctrl.abort(), ms);\r\n            return ctrl.signal;\r\n        });\r\n        const body = options.body ? options.body : '';\r\n        let reqByteLength = -1;\r\n        try {\r\n            if (body instanceof Blob) {\r\n                reqByteLength = body.size;\r\n            }\r\n            else {\r\n                reqByteLength = Buffer.byteLength(body, STRING_FORMAT);\r\n            }\r\n        }\r\n        catch {\r\n            if (body instanceof Blob) {\r\n                reqByteLength = body.size;\r\n            }\r\n            else {\r\n                const encoded = new TextEncoder().encode(body);\r\n                reqByteLength = encoded.length;\r\n            }\r\n        }\r\n        return await retriable(async () => {\r\n            let res = null;\r\n            try {\r\n                res = await this.fetch(url, {\r\n                    signal: AbortSignal.timeout(requestTimeout ?? this.requestTimeout),\r\n                    ...options,\r\n                });\r\n            }\r\n            catch (e) {\r\n                // fetch will only throw on network errors or on timeouts\r\n                throw new PostHogFetchNetworkError(e);\r\n            }\r\n            // If we're in no-cors mode, we can't access the response status\r\n            // We only throw on HTTP errors if we're not in no-cors mode\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/Request/mode#no-cors\r\n            const isNoCors = options.mode === 'no-cors';\r\n            if (!isNoCors && (res.status < 200 || res.status >= 400)) {\r\n                throw new PostHogFetchHttpError(res, reqByteLength);\r\n            }\r\n            return res;\r\n        }, { ...this._retryOptions, ...retryOptions });\r\n    }\r\n    async _shutdown(shutdownTimeoutMs = 30000) {\r\n        // A little tricky - we want to have a max shutdown time and enforce it, even if that means we have some\r\n        // dangling promises. We'll keep track of the timeout and resolve/reject based on that.\r\n        await this._initPromise;\r\n        let hasTimedOut = false;\r\n        this.clearFlushTimer();\r\n        const doShutdown = async () => {\r\n            try {\r\n                await Promise.all(Object.values(this.pendingPromises));\r\n                while (true) {\r\n                    const queue = this.getPersistedProperty(PostHogPersistedProperty.Queue) || [];\r\n                    if (queue.length === 0) {\r\n                        break;\r\n                    }\r\n                    // flush again to make sure we send all events, some of which might've been added\r\n                    // while we were waiting for the pending promises to resolve\r\n                    // For example, see sendFeatureFlags in posthog-node/src/posthog-node.ts::capture\r\n                    await this.flush();\r\n                    if (hasTimedOut) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (!isPostHogFetchError(e)) {\r\n                    throw e;\r\n                }\r\n                await logFlushError(e);\r\n            }\r\n        };\r\n        return Promise.race([\r\n            new Promise((_, reject) => {\r\n                safeSetTimeout(() => {\r\n                    this.logMsgIfDebug(() => console.error('Timed out while shutting down PostHog'));\r\n                    hasTimedOut = true;\r\n                    reject('Timeout while shutting down PostHog. Some events may not have been sent.');\r\n                }, shutdownTimeoutMs);\r\n            }),\r\n            doShutdown(),\r\n        ]);\r\n    }\r\n    /**\r\n     *  Call shutdown() once before the node process exits, so ensure that all events have been sent and all promises\r\n     *  have resolved. Do not use this function if you intend to keep using this PostHog instance after calling it.\r\n     * @param shutdownTimeoutMs\r\n     */\r\n    async shutdown(shutdownTimeoutMs = 30000) {\r\n        if (this.shutdownPromise) {\r\n            this.logMsgIfDebug(() => console.warn('shutdown() called while already shutting down. shutdown() is meant to be called once before process exit - use flush() for per-request cleanup'));\r\n        }\r\n        else {\r\n            this.shutdownPromise = this._shutdown(shutdownTimeoutMs).finally(() => {\r\n                this.shutdownPromise = null;\r\n            });\r\n        }\r\n        return this.shutdownPromise;\r\n    }\r\n}\n\n/**\r\n * A lazy value that is only computed when needed. Inspired by C#'s Lazy<T> class.\r\n */\nclass Lazy {\n  constructor(factory) {\n    this.factory = factory;\n  }\n  /**\r\n   * Gets the value, initializing it if necessary.\r\n   * Multiple concurrent calls will share the same initialization promise.\r\n   */\n  async getValue() {\n    if (this.value !== undefined) {\n      return this.value;\n    }\n    if (this.initializationPromise === undefined) {\n      this.initializationPromise = (async () => {\n        try {\n          const result = await this.factory();\n          this.value = result;\n          return result;\n        } finally {\n          // Clear the promise so we can retry if needed\n          this.initializationPromise = undefined;\n        }\n      })();\n    }\n    return this.initializationPromise;\n  }\n  /**\r\n   * Returns true if the value has been initialized.\r\n   */\n  isInitialized() {\n    return this.value !== undefined;\n  }\n  /**\r\n   * Returns a promise that resolves when the value is initialized.\r\n   * If already initialized, resolves immediately.\r\n   */\n  async waitForInitialization() {\n    if (this.isInitialized()) {\n      return;\n    }\n    await this.getValue();\n  }\n}\n\n/// <reference lib=\"dom\" />\nconst nodeCrypto = new Lazy(async () => {\n  try {\n    return await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ \"crypto\", 19));\n  } catch {\n    return undefined;\n  }\n});\nasync function getNodeCrypto() {\n  return await nodeCrypto.getValue();\n}\nconst webCrypto = new Lazy(async () => {\n  if (typeof globalThis.crypto?.subtle !== 'undefined') {\n    return globalThis.crypto.subtle;\n  }\n  try {\n    // Node.js: use built-in webcrypto and assign it if needed\n    const crypto = await nodeCrypto.getValue();\n    if (crypto?.webcrypto?.subtle) {\n      return crypto.webcrypto.subtle;\n    }\n  } catch {\n    // Ignore if not available\n  }\n  return undefined;\n});\nasync function getWebCrypto() {\n  return await webCrypto.getValue();\n}\n\n/// <reference lib=\"dom\" />\nasync function hashSHA1(text) {\n  // Try Node.js crypto first\n  const nodeCrypto = await getNodeCrypto();\n  if (nodeCrypto) {\n    return nodeCrypto.createHash('sha1').update(text).digest('hex');\n  }\n  const webCrypto = await getWebCrypto();\n  // Fall back to Web Crypto API\n  if (webCrypto) {\n    const hashBuffer = await webCrypto.digest('SHA-1', new TextEncoder().encode(text));\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n  throw new Error('No crypto implementation available. Tried Node Crypto API and Web SubtleCrypto API');\n}\n\nconst SIXTY_SECONDS = 60 * 1000;\n// eslint-disable-next-line\nconst LONG_SCALE = 0xfffffffffffffff;\nconst NULL_VALUES_ALLOWED_OPERATORS = ['is_not'];\nclass ClientError extends Error {\n  constructor(message) {\n    super();\n    Error.captureStackTrace(this, this.constructor);\n    this.name = 'ClientError';\n    this.message = message;\n    Object.setPrototypeOf(this, ClientError.prototype);\n  }\n}\nclass InconclusiveMatchError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n    // instanceof doesn't work in ES3 or ES5\n    // https://www.dannyguo.com/blog/how-to-fix-instanceof-not-working-for-custom-errors-in-typescript/\n    // this is the workaround\n    Object.setPrototypeOf(this, InconclusiveMatchError.prototype);\n  }\n}\nclass FeatureFlagsPoller {\n  constructor({\n    pollingInterval,\n    personalApiKey,\n    projectApiKey,\n    timeout,\n    host,\n    customHeaders,\n    ...options\n  }) {\n    this.debugMode = false;\n    this.shouldBeginExponentialBackoff = false;\n    this.backOffCount = 0;\n    this.pollingInterval = pollingInterval;\n    this.personalApiKey = personalApiKey;\n    this.featureFlags = [];\n    this.featureFlagsByKey = {};\n    this.groupTypeMapping = {};\n    this.cohorts = {};\n    this.loadedSuccessfullyOnce = false;\n    this.timeout = timeout;\n    this.projectApiKey = projectApiKey;\n    this.host = host;\n    this.poller = undefined;\n    this.fetch = options.fetch || fetch;\n    this.onError = options.onError;\n    this.customHeaders = customHeaders;\n    this.onLoad = options.onLoad;\n    void this.loadFeatureFlags();\n  }\n  debug(enabled = true) {\n    this.debugMode = enabled;\n  }\n  logMsgIfDebug(fn) {\n    if (this.debugMode) {\n      fn();\n    }\n  }\n  async getFeatureFlag(key, distinctId, groups = {}, personProperties = {}, groupProperties = {}) {\n    await this.loadFeatureFlags();\n    let response = undefined;\n    let featureFlag = undefined;\n    if (!this.loadedSuccessfullyOnce) {\n      return response;\n    }\n    featureFlag = this.featureFlagsByKey[key];\n    if (featureFlag !== undefined) {\n      try {\n        response = await this.computeFlagLocally(featureFlag, distinctId, groups, personProperties, groupProperties);\n        this.logMsgIfDebug(() => console.debug(`Successfully computed flag locally: ${key} -> ${response}`));\n      } catch (e) {\n        if (e instanceof InconclusiveMatchError) {\n          this.logMsgIfDebug(() => console.debug(`InconclusiveMatchError when computing flag locally: ${key}: ${e}`));\n        } else if (e instanceof Error) {\n          this.onError?.(new Error(`Error computing flag locally: ${key}: ${e}`));\n        }\n      }\n    }\n    return response;\n  }\n  async computeFeatureFlagPayloadLocally(key, matchValue) {\n    await this.loadFeatureFlags();\n    let response = undefined;\n    if (!this.loadedSuccessfullyOnce) {\n      return undefined;\n    }\n    if (typeof matchValue == 'boolean') {\n      response = this.featureFlagsByKey?.[key]?.filters?.payloads?.[matchValue.toString()];\n    } else if (typeof matchValue == 'string') {\n      response = this.featureFlagsByKey?.[key]?.filters?.payloads?.[matchValue];\n    }\n    // Undefined means a loading or missing data issue. Null means evaluation happened and there was no match\n    if (response === undefined || response === null) {\n      return null;\n    }\n    try {\n      return JSON.parse(response);\n    } catch {\n      return response;\n    }\n  }\n  async getAllFlagsAndPayloads(distinctId, groups = {}, personProperties = {}, groupProperties = {}, flagKeysToExplicitlyEvaluate) {\n    await this.loadFeatureFlags();\n    const response = {};\n    const payloads = {};\n    let fallbackToFlags = this.featureFlags.length == 0;\n    const flagsToEvaluate = flagKeysToExplicitlyEvaluate ? flagKeysToExplicitlyEvaluate.map(key => this.featureFlagsByKey[key]).filter(Boolean) : this.featureFlags;\n    await Promise.all(flagsToEvaluate.map(async flag => {\n      try {\n        const matchValue = await this.computeFlagLocally(flag, distinctId, groups, personProperties, groupProperties);\n        response[flag.key] = matchValue;\n        const matchPayload = await this.computeFeatureFlagPayloadLocally(flag.key, matchValue);\n        if (matchPayload) {\n          payloads[flag.key] = matchPayload;\n        }\n      } catch (e) {\n        if (e instanceof InconclusiveMatchError) {\n          this.logMsgIfDebug(() => console.debug(`InconclusiveMatchError when computing flag locally: ${flag.key}: ${e}`));\n        } else if (e instanceof Error) {\n          this.onError?.(new Error(`Error computing flag locally: ${flag.key}: ${e}`));\n        }\n        fallbackToFlags = true;\n      }\n    }));\n    return {\n      response,\n      payloads,\n      fallbackToFlags\n    };\n  }\n  async computeFlagLocally(flag, distinctId, groups = {}, personProperties = {}, groupProperties = {}) {\n    if (flag.ensure_experience_continuity) {\n      throw new InconclusiveMatchError('Flag has experience continuity enabled');\n    }\n    if (!flag.active) {\n      return false;\n    }\n    const flagFilters = flag.filters || {};\n    const aggregation_group_type_index = flagFilters.aggregation_group_type_index;\n    if (aggregation_group_type_index != undefined) {\n      const groupName = this.groupTypeMapping[String(aggregation_group_type_index)];\n      if (!groupName) {\n        this.logMsgIfDebug(() => console.warn(`[FEATURE FLAGS] Unknown group type index ${aggregation_group_type_index} for feature flag ${flag.key}`));\n        throw new InconclusiveMatchError('Flag has unknown group type index');\n      }\n      if (!(groupName in groups)) {\n        this.logMsgIfDebug(() => console.warn(`[FEATURE FLAGS] Can't compute group feature flag: ${flag.key} without group names passed in`));\n        return false;\n      }\n      const focusedGroupProperties = groupProperties[groupName];\n      return await this.matchFeatureFlagProperties(flag, groups[groupName], focusedGroupProperties);\n    } else {\n      return await this.matchFeatureFlagProperties(flag, distinctId, personProperties);\n    }\n  }\n  async matchFeatureFlagProperties(flag, distinctId, properties) {\n    const flagFilters = flag.filters || {};\n    const flagConditions = flagFilters.groups || [];\n    let isInconclusive = false;\n    let result = undefined;\n    // # Stable sort conditions with variant overrides to the top. This ensures that if overrides are present, they are\n    // # evaluated first, and the variant override is applied to the first matching condition.\n    const sortedFlagConditions = [...flagConditions].sort((conditionA, conditionB) => {\n      const AHasVariantOverride = !!conditionA.variant;\n      const BHasVariantOverride = !!conditionB.variant;\n      if (AHasVariantOverride && BHasVariantOverride) {\n        return 0;\n      } else if (AHasVariantOverride) {\n        return -1;\n      } else if (BHasVariantOverride) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n    for (const condition of sortedFlagConditions) {\n      try {\n        if (await this.isConditionMatch(flag, distinctId, condition, properties)) {\n          const variantOverride = condition.variant;\n          const flagVariants = flagFilters.multivariate?.variants || [];\n          if (variantOverride && flagVariants.some(variant => variant.key === variantOverride)) {\n            result = variantOverride;\n          } else {\n            result = (await this.getMatchingVariant(flag, distinctId)) || true;\n          }\n          break;\n        }\n      } catch (e) {\n        if (e instanceof InconclusiveMatchError) {\n          isInconclusive = true;\n        } else {\n          throw e;\n        }\n      }\n    }\n    if (result !== undefined) {\n      return result;\n    } else if (isInconclusive) {\n      throw new InconclusiveMatchError(\"Can't determine if feature flag is enabled or not with given properties\");\n    }\n    // We can only return False when all conditions are False\n    return false;\n  }\n  async isConditionMatch(flag, distinctId, condition, properties) {\n    const rolloutPercentage = condition.rollout_percentage;\n    const warnFunction = msg => {\n      this.logMsgIfDebug(() => console.warn(msg));\n    };\n    if ((condition.properties || []).length > 0) {\n      for (const prop of condition.properties) {\n        const propertyType = prop.type;\n        let matches = false;\n        if (propertyType === 'cohort') {\n          matches = matchCohort(prop, properties, this.cohorts, this.debugMode);\n        } else if (propertyType === 'flag') {\n          this.logMsgIfDebug(() => console.warn(`[FEATURE FLAGS] Flag dependency filters are not supported in local evaluation. ` + `Skipping condition for flag '${flag.key}' with dependency on flag '${prop.key || 'unknown'}'`));\n          continue;\n        } else {\n          matches = matchProperty(prop, properties, warnFunction);\n        }\n        if (!matches) {\n          return false;\n        }\n      }\n      if (rolloutPercentage == undefined) {\n        return true;\n      }\n    }\n    if (rolloutPercentage != undefined && (await _hash(flag.key, distinctId)) > rolloutPercentage / 100.0) {\n      return false;\n    }\n    return true;\n  }\n  async getMatchingVariant(flag, distinctId) {\n    const hashValue = await _hash(flag.key, distinctId, 'variant');\n    const matchingVariant = this.variantLookupTable(flag).find(variant => {\n      return hashValue >= variant.valueMin && hashValue < variant.valueMax;\n    });\n    if (matchingVariant) {\n      return matchingVariant.key;\n    }\n    return undefined;\n  }\n  variantLookupTable(flag) {\n    const lookupTable = [];\n    let valueMin = 0;\n    let valueMax = 0;\n    const flagFilters = flag.filters || {};\n    const multivariates = flagFilters.multivariate?.variants || [];\n    multivariates.forEach(variant => {\n      valueMax = valueMin + variant.rollout_percentage / 100.0;\n      lookupTable.push({\n        valueMin,\n        valueMax,\n        key: variant.key\n      });\n      valueMin = valueMax;\n    });\n    return lookupTable;\n  }\n  async loadFeatureFlags(forceReload = false) {\n    if (!this.loadedSuccessfullyOnce || forceReload) {\n      await this._loadFeatureFlags();\n    }\n  }\n  /**\r\n   * Returns true if the feature flags poller has loaded successfully at least once and has more than 0 feature flags.\r\n   * This is useful to check if local evaluation is ready before calling getFeatureFlag.\r\n   */\n  isLocalEvaluationReady() {\n    return (this.loadedSuccessfullyOnce ?? false) && (this.featureFlags?.length ?? 0) > 0;\n  }\n  /**\r\n   * If a client is misconfigured with an invalid or improper API key, the polling interval is doubled each time\r\n   * until a successful request is made, up to a maximum of 60 seconds.\r\n   *\r\n   * @returns The polling interval to use for the next request.\r\n   */\n  getPollingInterval() {\n    if (!this.shouldBeginExponentialBackoff) {\n      return this.pollingInterval;\n    }\n    return Math.min(SIXTY_SECONDS, this.pollingInterval * 2 ** this.backOffCount);\n  }\n  async _loadFeatureFlags() {\n    if (this.poller) {\n      clearTimeout(this.poller);\n      this.poller = undefined;\n    }\n    this.poller = setTimeout(() => this._loadFeatureFlags(), this.getPollingInterval());\n    try {\n      const res = await this._requestFeatureFlagDefinitions();\n      // Handle undefined res case, this shouldn't happen, but it doesn't hurt to handle it anyway\n      if (!res) {\n        // Don't override existing flags when something goes wrong\n        return;\n      }\n      // NB ON ERROR HANDLING & `loadedSuccessfullyOnce`:\n      //\n      // `loadedSuccessfullyOnce` indicates we've successfully loaded a valid set of flags at least once.\n      // If we set it to `true` in an error scenario (e.g. 402 Over Quota, 401 Invalid Key, etc.),\n      // any manual call to `loadFeatureFlags()` (without forceReload) will skip refetching entirely,\n      // leaving us stuck with zero or outdated flags. The poller does keep running, but we also want\n      // manual reloads to be possible as soon as the error condition is resolved.\n      //\n      // Therefore, on error statuses, we do *not* set `loadedSuccessfullyOnce = true`, ensuring that\n      // both the background poller and any subsequent manual calls can keep trying to load flags\n      // once the issue (quota, permission, rate limit, etc.) is resolved.\n      switch (res.status) {\n        case 401:\n          // Invalid API key\n          this.shouldBeginExponentialBackoff = true;\n          this.backOffCount += 1;\n          throw new ClientError(`Your project key or personal API key is invalid. Setting next polling interval to ${this.getPollingInterval()}ms. More information: https://posthog.com/docs/api#rate-limiting`);\n        case 402:\n          // Quota exceeded - clear all flags\n          console.warn('[FEATURE FLAGS] Feature flags quota limit exceeded - unsetting all local flags. Learn more about billing limits at https://posthog.com/docs/billing/limits-alerts');\n          this.featureFlags = [];\n          this.featureFlagsByKey = {};\n          this.groupTypeMapping = {};\n          this.cohorts = {};\n          return;\n        case 403:\n          // Permissions issue\n          this.shouldBeginExponentialBackoff = true;\n          this.backOffCount += 1;\n          throw new ClientError(`Your personal API key does not have permission to fetch feature flag definitions for local evaluation. Setting next polling interval to ${this.getPollingInterval()}ms. Are you sure you're using the correct personal and Project API key pair? More information: https://posthog.com/docs/api/overview`);\n        case 429:\n          // Rate limited\n          this.shouldBeginExponentialBackoff = true;\n          this.backOffCount += 1;\n          throw new ClientError(`You are being rate limited. Setting next polling interval to ${this.getPollingInterval()}ms. More information: https://posthog.com/docs/api#rate-limiting`);\n        case 200:\n          {\n            // Process successful response\n            const responseJson = (await res.json()) ?? {};\n            if (!('flags' in responseJson)) {\n              this.onError?.(new Error(`Invalid response when getting feature flags: ${JSON.stringify(responseJson)}`));\n              return;\n            }\n            this.featureFlags = responseJson.flags ?? [];\n            this.featureFlagsByKey = this.featureFlags.reduce((acc, curr) => (acc[curr.key] = curr, acc), {});\n            this.groupTypeMapping = responseJson.group_type_mapping || {};\n            this.cohorts = responseJson.cohorts || {};\n            this.loadedSuccessfullyOnce = true;\n            this.shouldBeginExponentialBackoff = false;\n            this.backOffCount = 0;\n            this.onLoad?.(this.featureFlags.length);\n            break;\n          }\n        default:\n          // Something else went wrong, or the server is down.\n          // In this case, don't override existing flags\n          return;\n      }\n    } catch (err) {\n      if (err instanceof ClientError) {\n        this.onError?.(err);\n      }\n    }\n  }\n  getPersonalApiKeyRequestOptions(method = 'GET') {\n    return {\n      method,\n      headers: {\n        ...this.customHeaders,\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${this.personalApiKey}`\n      }\n    };\n  }\n  async _requestFeatureFlagDefinitions() {\n    const url = `${this.host}/api/feature_flag/local_evaluation?token=${this.projectApiKey}&send_cohorts`;\n    const options = this.getPersonalApiKeyRequestOptions();\n    let abortTimeout = null;\n    if (this.timeout && typeof this.timeout === 'number') {\n      const controller = new AbortController();\n      abortTimeout = safeSetTimeout(() => {\n        controller.abort();\n      }, this.timeout);\n      options.signal = controller.signal;\n    }\n    try {\n      return await this.fetch(url, options);\n    } finally {\n      clearTimeout(abortTimeout);\n    }\n  }\n  stopPoller() {\n    clearTimeout(this.poller);\n  }\n}\n// # This function takes a distinct_id and a feature flag key and returns a float between 0 and 1.\n// # Given the same distinct_id and key, it'll always return the same float. These floats are\n// # uniformly distributed between 0 and 1, so if we want to show this feature to 20% of traffic\n// # we can do _hash(key, distinct_id) < 0.2\nasync function _hash(key, distinctId, salt = '') {\n  const hashString = await hashSHA1(`${key}.${distinctId}${salt}`);\n  return parseInt(hashString.slice(0, 15), 16) / LONG_SCALE;\n}\nfunction matchProperty(property, propertyValues, warnFunction) {\n  const key = property.key;\n  const value = property.value;\n  const operator = property.operator || 'exact';\n  if (!(key in propertyValues)) {\n    throw new InconclusiveMatchError(`Property ${key} not found in propertyValues`);\n  } else if (operator === 'is_not_set') {\n    throw new InconclusiveMatchError(`Operator is_not_set is not supported`);\n  }\n  const overrideValue = propertyValues[key];\n  if (overrideValue == null && !NULL_VALUES_ALLOWED_OPERATORS.includes(operator)) {\n    // if the value is null, just fail the feature flag comparison\n    // this isn't an InconclusiveMatchError because the property value was provided.\n    if (warnFunction) {\n      warnFunction(`Property ${key} cannot have a value of null/undefined with the ${operator} operator`);\n    }\n    return false;\n  }\n  function computeExactMatch(value, overrideValue) {\n    if (Array.isArray(value)) {\n      return value.map(val => String(val).toLowerCase()).includes(String(overrideValue).toLowerCase());\n    }\n    return String(value).toLowerCase() === String(overrideValue).toLowerCase();\n  }\n  function compare(lhs, rhs, operator) {\n    if (operator === 'gt') {\n      return lhs > rhs;\n    } else if (operator === 'gte') {\n      return lhs >= rhs;\n    } else if (operator === 'lt') {\n      return lhs < rhs;\n    } else if (operator === 'lte') {\n      return lhs <= rhs;\n    } else {\n      throw new Error(`Invalid operator: ${operator}`);\n    }\n  }\n  switch (operator) {\n    case 'exact':\n      return computeExactMatch(value, overrideValue);\n    case 'is_not':\n      return !computeExactMatch(value, overrideValue);\n    case 'is_set':\n      return key in propertyValues;\n    case 'icontains':\n      return String(overrideValue).toLowerCase().includes(String(value).toLowerCase());\n    case 'not_icontains':\n      return !String(overrideValue).toLowerCase().includes(String(value).toLowerCase());\n    case 'regex':\n      return isValidRegex(String(value)) && String(overrideValue).match(String(value)) !== null;\n    case 'not_regex':\n      return isValidRegex(String(value)) && String(overrideValue).match(String(value)) === null;\n    case 'gt':\n    case 'gte':\n    case 'lt':\n    case 'lte':\n      {\n        // :TRICKY: We adjust comparison based on the override value passed in,\n        // to make sure we handle both numeric and string comparisons appropriately.\n        let parsedValue = typeof value === 'number' ? value : null;\n        if (typeof value === 'string') {\n          try {\n            parsedValue = parseFloat(value);\n          } catch (err) {\n            // pass\n          }\n        }\n        if (parsedValue != null && overrideValue != null) {\n          // check both null and undefined\n          if (typeof overrideValue === 'string') {\n            return compare(overrideValue, String(value), operator);\n          } else {\n            return compare(overrideValue, parsedValue, operator);\n          }\n        } else {\n          return compare(String(overrideValue), String(value), operator);\n        }\n      }\n    case 'is_date_after':\n    case 'is_date_before':\n      {\n        let parsedDate = relativeDateParseForFeatureFlagMatching(String(value));\n        if (parsedDate == null) {\n          parsedDate = convertToDateTime(value);\n        }\n        if (parsedDate == null) {\n          throw new InconclusiveMatchError(`Invalid date: ${value}`);\n        }\n        const overrideDate = convertToDateTime(overrideValue);\n        if (['is_date_before'].includes(operator)) {\n          return overrideDate < parsedDate;\n        }\n        return overrideDate > parsedDate;\n      }\n    default:\n      throw new InconclusiveMatchError(`Unknown operator: ${operator}`);\n  }\n}\nfunction matchCohort(property, propertyValues, cohortProperties, debugMode = false) {\n  const cohortId = String(property.value);\n  if (!(cohortId in cohortProperties)) {\n    throw new InconclusiveMatchError(\"can't match cohort without a given cohort property value\");\n  }\n  const propertyGroup = cohortProperties[cohortId];\n  return matchPropertyGroup(propertyGroup, propertyValues, cohortProperties, debugMode);\n}\nfunction matchPropertyGroup(propertyGroup, propertyValues, cohortProperties, debugMode = false) {\n  if (!propertyGroup) {\n    return true;\n  }\n  const propertyGroupType = propertyGroup.type;\n  const properties = propertyGroup.values;\n  if (!properties || properties.length === 0) {\n    // empty groups are no-ops, always match\n    return true;\n  }\n  let errorMatchingLocally = false;\n  if ('values' in properties[0]) {\n    // a nested property group\n    for (const prop of properties) {\n      try {\n        const matches = matchPropertyGroup(prop, propertyValues, cohortProperties, debugMode);\n        if (propertyGroupType === 'AND') {\n          if (!matches) {\n            return false;\n          }\n        } else {\n          // OR group\n          if (matches) {\n            return true;\n          }\n        }\n      } catch (err) {\n        if (err instanceof InconclusiveMatchError) {\n          if (debugMode) {\n            console.debug(`Failed to compute property ${prop} locally: ${err}`);\n          }\n          errorMatchingLocally = true;\n        } else {\n          throw err;\n        }\n      }\n    }\n    if (errorMatchingLocally) {\n      throw new InconclusiveMatchError(\"Can't match cohort without a given cohort property value\");\n    }\n    // if we get here, all matched in AND case, or none matched in OR case\n    return propertyGroupType === 'AND';\n  } else {\n    for (const prop of properties) {\n      try {\n        let matches;\n        if (prop.type === 'cohort') {\n          matches = matchCohort(prop, propertyValues, cohortProperties, debugMode);\n        } else if (prop.type === 'flag') {\n          if (debugMode) {\n            console.warn(`[FEATURE FLAGS] Flag dependency filters are not supported in local evaluation. ` + `Skipping condition with dependency on flag '${prop.key || 'unknown'}'`);\n          }\n          continue;\n        } else {\n          matches = matchProperty(prop, propertyValues);\n        }\n        const negation = prop.negation || false;\n        if (propertyGroupType === 'AND') {\n          // if negated property, do the inverse\n          if (!matches && !negation) {\n            return false;\n          }\n          if (matches && negation) {\n            return false;\n          }\n        } else {\n          // OR group\n          if (matches && !negation) {\n            return true;\n          }\n          if (!matches && negation) {\n            return true;\n          }\n        }\n      } catch (err) {\n        if (err instanceof InconclusiveMatchError) {\n          if (debugMode) {\n            console.debug(`Failed to compute property ${prop} locally: ${err}`);\n          }\n          errorMatchingLocally = true;\n        } else {\n          throw err;\n        }\n      }\n    }\n    if (errorMatchingLocally) {\n      throw new InconclusiveMatchError(\"can't match cohort without a given cohort property value\");\n    }\n    // if we get here, all matched in AND case, or none matched in OR case\n    return propertyGroupType === 'AND';\n  }\n}\nfunction isValidRegex(regex) {\n  try {\n    new RegExp(regex);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\nfunction convertToDateTime(value) {\n  if (value instanceof Date) {\n    return value;\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    const date = new Date(value);\n    if (!isNaN(date.valueOf())) {\n      return date;\n    }\n    throw new InconclusiveMatchError(`${value} is in an invalid date format`);\n  } else {\n    throw new InconclusiveMatchError(`The date provided ${value} must be a string, number, or date object`);\n  }\n}\nfunction relativeDateParseForFeatureFlagMatching(value) {\n  const regex = /^-?(?<number>[0-9]+)(?<interval>[a-z])$/;\n  const match = value.match(regex);\n  const parsedDt = new Date(new Date().toISOString());\n  if (match) {\n    if (!match.groups) {\n      return null;\n    }\n    const number = parseInt(match.groups['number']);\n    if (number >= 10000) {\n      // Guard against overflow, disallow numbers greater than 10_000\n      return null;\n    }\n    const interval = match.groups['interval'];\n    if (interval == 'h') {\n      parsedDt.setUTCHours(parsedDt.getUTCHours() - number);\n    } else if (interval == 'd') {\n      parsedDt.setUTCDate(parsedDt.getUTCDate() - number);\n    } else if (interval == 'w') {\n      parsedDt.setUTCDate(parsedDt.getUTCDate() - number * 7);\n    } else if (interval == 'm') {\n      parsedDt.setUTCMonth(parsedDt.getUTCMonth() - number);\n    } else if (interval == 'y') {\n      parsedDt.setUTCFullYear(parsedDt.getUTCFullYear() - number);\n    } else {\n      return null;\n    }\n    return parsedDt;\n  } else {\n    return null;\n  }\n}\n\nclass PostHogMemoryStorage {\n  constructor() {\n    this._memoryStorage = {};\n  }\n  getProperty(key) {\n    return this._memoryStorage[key];\n  }\n  setProperty(key, value) {\n    this._memoryStorage[key] = value !== null ? value : undefined;\n  }\n}\n\n// Standard local evaluation rate limit is 600 per minute (10 per second),\n// so the fastest a poller should ever be set is 100ms.\nconst MINIMUM_POLLING_INTERVAL = 100;\nconst THIRTY_SECONDS = 30 * 1000;\nconst MAX_CACHE_SIZE = 50 * 1000;\n// The actual exported Nodejs API.\nclass PostHogBackendClient extends PostHogCoreStateless {\n  constructor(apiKey, options = {}) {\n    super(apiKey, options);\n    this._memoryStorage = new PostHogMemoryStorage();\n    this.options = options;\n    this.options.featureFlagsPollingInterval = typeof options.featureFlagsPollingInterval === 'number' ? Math.max(options.featureFlagsPollingInterval, MINIMUM_POLLING_INTERVAL) : THIRTY_SECONDS;\n    if (options.personalApiKey) {\n      if (options.personalApiKey.includes('phc_')) {\n        throw new Error('Your Personal API key is invalid. These keys are prefixed with \"phx_\" and can be created in PostHog project settings.');\n      }\n      // Only start the poller if local evaluation is enabled (defaults to true for backward compatibility)\n      const shouldEnableLocalEvaluation = options.enableLocalEvaluation !== false;\n      if (shouldEnableLocalEvaluation) {\n        this.featureFlagsPoller = new FeatureFlagsPoller({\n          pollingInterval: this.options.featureFlagsPollingInterval,\n          personalApiKey: options.personalApiKey,\n          projectApiKey: apiKey,\n          timeout: options.requestTimeout ?? 10000,\n          host: this.host,\n          fetch: options.fetch,\n          onError: err => {\n            this._events.emit('error', err);\n          },\n          onLoad: count => {\n            this._events.emit('localEvaluationFlagsLoaded', count);\n          },\n          customHeaders: this.getCustomHeaders()\n        });\n      }\n    }\n    this.errorTracking = new ErrorTracking(this, options);\n    this.distinctIdHasSentFlagCalls = {};\n    this.maxCacheSize = options.maxCacheSize || MAX_CACHE_SIZE;\n  }\n  getPersistedProperty(key) {\n    return this._memoryStorage.getProperty(key);\n  }\n  setPersistedProperty(key, value) {\n    return this._memoryStorage.setProperty(key, value);\n  }\n  fetch(url, options) {\n    return this.options.fetch ? this.options.fetch(url, options) : fetch(url, options);\n  }\n  getLibraryVersion() {\n    return version;\n  }\n  getCustomUserAgent() {\n    return `${this.getLibraryId()}/${this.getLibraryVersion()}`;\n  }\n  enable() {\n    return super.optIn();\n  }\n  disable() {\n    return super.optOut();\n  }\n  debug(enabled = true) {\n    super.debug(enabled);\n    this.featureFlagsPoller?.debug(enabled);\n  }\n  capture(props) {\n    if (typeof props === 'string') {\n      this.logMsgIfDebug(() => console.warn('Called capture() with a string as the first argument when an object was expected.'));\n    }\n    const {\n      distinctId,\n      event,\n      properties,\n      groups,\n      sendFeatureFlags,\n      timestamp,\n      disableGeoip,\n      uuid\n    } = props;\n    const _capture = props => {\n      super.captureStateless(distinctId, event, props, {\n        timestamp,\n        disableGeoip,\n        uuid\n      });\n    };\n    // :TRICKY: If we flush, or need to shut down, to not lose events we want this promise to resolve before we flush\n    const capturePromise = Promise.resolve().then(async () => {\n      if (sendFeatureFlags) {\n        // If we are sending feature flags, we evaluate them locally if the user prefers it, otherwise we fall back to remote evaluation\n        const sendFeatureFlagsOptions = typeof sendFeatureFlags === 'object' ? sendFeatureFlags : undefined;\n        return await this.getFeatureFlagsForEvent(distinctId, groups, disableGeoip, sendFeatureFlagsOptions);\n      }\n      if (event === '$feature_flag_called') {\n        // If we're capturing a $feature_flag_called event, we don't want to enrich the event with cached flags that may be out of date.\n        return {};\n      }\n      return {};\n    }).then(flags => {\n      // Derive the relevant flag properties to add\n      const additionalProperties = {};\n      if (flags) {\n        for (const [feature, variant] of Object.entries(flags)) {\n          additionalProperties[`$feature/${feature}`] = variant;\n        }\n      }\n      const activeFlags = Object.keys(flags || {}).filter(flag => flags?.[flag] !== false).sort();\n      if (activeFlags.length > 0) {\n        additionalProperties['$active_feature_flags'] = activeFlags;\n      }\n      return additionalProperties;\n    }).catch(() => {\n      // Something went wrong getting the flag info - we should capture the event anyways\n      return {};\n    }).then(additionalProperties => {\n      // No matter what - capture the event\n      _capture({\n        ...additionalProperties,\n        ...properties,\n        $groups: groups\n      });\n    });\n    this.addPendingPromise(capturePromise);\n  }\n  async captureImmediate(props) {\n    if (typeof props === 'string') {\n      this.logMsgIfDebug(() => console.warn('Called capture() with a string as the first argument when an object was expected.'));\n    }\n    const {\n      distinctId,\n      event,\n      properties,\n      groups,\n      sendFeatureFlags,\n      timestamp,\n      disableGeoip,\n      uuid\n    } = props;\n    const _capture = props => {\n      return super.captureStatelessImmediate(distinctId, event, props, {\n        timestamp,\n        disableGeoip,\n        uuid\n      });\n    };\n    const capturePromise = Promise.resolve().then(async () => {\n      if (sendFeatureFlags) {\n        // If we are sending feature flags, we evaluate them locally if the user prefers it, otherwise we fall back to remote evaluation\n        const sendFeatureFlagsOptions = typeof sendFeatureFlags === 'object' ? sendFeatureFlags : undefined;\n        return await this.getFeatureFlagsForEvent(distinctId, groups, disableGeoip, sendFeatureFlagsOptions);\n      }\n      if (event === '$feature_flag_called') {\n        // If we're capturing a $feature_flag_called event, we don't want to enrich the event with cached flags that may be out of date.\n        return {};\n      }\n      return {};\n    }).then(flags => {\n      // Derive the relevant flag properties to add\n      const additionalProperties = {};\n      if (flags) {\n        for (const [feature, variant] of Object.entries(flags)) {\n          additionalProperties[`$feature/${feature}`] = variant;\n        }\n      }\n      const activeFlags = Object.keys(flags || {}).filter(flag => flags?.[flag] !== false).sort();\n      if (activeFlags.length > 0) {\n        additionalProperties['$active_feature_flags'] = activeFlags;\n      }\n      return additionalProperties;\n    }).catch(() => {\n      // Something went wrong getting the flag info - we should capture the event anyways\n      return {};\n    }).then(additionalProperties => {\n      // No matter what - capture the event\n      _capture({\n        ...additionalProperties,\n        ...properties,\n        $groups: groups\n      });\n    });\n    await capturePromise;\n  }\n  identify({\n    distinctId,\n    properties,\n    disableGeoip\n  }) {\n    // Catch properties passed as $set and move them to the top level\n    // promote $set and $set_once to top level\n    const userPropsOnce = properties?.$set_once;\n    delete properties?.$set_once;\n    // if no $set is provided we assume all properties are $set\n    const userProps = properties?.$set || properties;\n    super.identifyStateless(distinctId, {\n      $set: userProps,\n      $set_once: userPropsOnce\n    }, {\n      disableGeoip\n    });\n  }\n  async identifyImmediate({\n    distinctId,\n    properties,\n    disableGeoip\n  }) {\n    // promote $set and $set_once to top level\n    const userPropsOnce = properties?.$set_once;\n    delete properties?.$set_once;\n    // if no $set is provided we assume all properties are $set\n    const userProps = properties?.$set || properties;\n    await super.identifyStatelessImmediate(distinctId, {\n      $set: userProps,\n      $set_once: userPropsOnce\n    }, {\n      disableGeoip\n    });\n  }\n  alias(data) {\n    super.aliasStateless(data.alias, data.distinctId, undefined, {\n      disableGeoip: data.disableGeoip\n    });\n  }\n  async aliasImmediate(data) {\n    await super.aliasStatelessImmediate(data.alias, data.distinctId, undefined, {\n      disableGeoip: data.disableGeoip\n    });\n  }\n  isLocalEvaluationReady() {\n    return this.featureFlagsPoller?.isLocalEvaluationReady() ?? false;\n  }\n  async waitForLocalEvaluationReady(timeoutMs = THIRTY_SECONDS) {\n    if (this.isLocalEvaluationReady()) {\n      return true;\n    }\n    if (this.featureFlagsPoller === undefined) {\n      return false;\n    }\n    return new Promise(resolve => {\n      const timeout = setTimeout(() => {\n        cleanup();\n        resolve(false);\n      }, timeoutMs);\n      const cleanup = this._events.on('localEvaluationFlagsLoaded', count => {\n        clearTimeout(timeout);\n        cleanup();\n        resolve(count > 0);\n      });\n    });\n  }\n  async getFeatureFlag(key, distinctId, options) {\n    const {\n      groups,\n      disableGeoip\n    } = options || {};\n    let {\n      onlyEvaluateLocally,\n      sendFeatureFlagEvents,\n      personProperties,\n      groupProperties\n    } = options || {};\n    const adjustedProperties = this.addLocalPersonAndGroupProperties(distinctId, groups, personProperties, groupProperties);\n    personProperties = adjustedProperties.allPersonProperties;\n    groupProperties = adjustedProperties.allGroupProperties;\n    // set defaults\n    if (onlyEvaluateLocally == undefined) {\n      onlyEvaluateLocally = false;\n    }\n    if (sendFeatureFlagEvents == undefined) {\n      sendFeatureFlagEvents = true;\n    }\n    let response = await this.featureFlagsPoller?.getFeatureFlag(key, distinctId, groups, personProperties, groupProperties);\n    const flagWasLocallyEvaluated = response !== undefined;\n    let requestId = undefined;\n    let flagDetail = undefined;\n    if (!flagWasLocallyEvaluated && !onlyEvaluateLocally) {\n      const remoteResponse = await super.getFeatureFlagDetailStateless(key, distinctId, groups, personProperties, groupProperties, disableGeoip);\n      if (remoteResponse === undefined) {\n        return undefined;\n      }\n      flagDetail = remoteResponse.response;\n      response = getFeatureFlagValue(flagDetail);\n      requestId = remoteResponse?.requestId;\n    }\n    const featureFlagReportedKey = `${key}_${response}`;\n    if (sendFeatureFlagEvents && (!(distinctId in this.distinctIdHasSentFlagCalls) || !this.distinctIdHasSentFlagCalls[distinctId].includes(featureFlagReportedKey))) {\n      if (Object.keys(this.distinctIdHasSentFlagCalls).length >= this.maxCacheSize) {\n        this.distinctIdHasSentFlagCalls = {};\n      }\n      if (Array.isArray(this.distinctIdHasSentFlagCalls[distinctId])) {\n        this.distinctIdHasSentFlagCalls[distinctId].push(featureFlagReportedKey);\n      } else {\n        this.distinctIdHasSentFlagCalls[distinctId] = [featureFlagReportedKey];\n      }\n      this.capture({\n        distinctId,\n        event: '$feature_flag_called',\n        properties: {\n          $feature_flag: key,\n          $feature_flag_response: response,\n          $feature_flag_id: flagDetail?.metadata?.id,\n          $feature_flag_version: flagDetail?.metadata?.version,\n          $feature_flag_reason: flagDetail?.reason?.description ?? flagDetail?.reason?.code,\n          locally_evaluated: flagWasLocallyEvaluated,\n          [`$feature/${key}`]: response,\n          $feature_flag_request_id: requestId\n        },\n        groups,\n        disableGeoip\n      });\n    }\n    return response;\n  }\n  async getFeatureFlagPayload(key, distinctId, matchValue, options) {\n    const {\n      groups,\n      disableGeoip\n    } = options || {};\n    let {\n      onlyEvaluateLocally,\n      sendFeatureFlagEvents,\n      personProperties,\n      groupProperties\n    } = options || {};\n    const adjustedProperties = this.addLocalPersonAndGroupProperties(distinctId, groups, personProperties, groupProperties);\n    personProperties = adjustedProperties.allPersonProperties;\n    groupProperties = adjustedProperties.allGroupProperties;\n    let response = undefined;\n    const localEvaluationEnabled = this.featureFlagsPoller !== undefined;\n    if (localEvaluationEnabled) {\n      // Try to get match value locally if not provided\n      if (!matchValue) {\n        matchValue = await this.getFeatureFlag(key, distinctId, {\n          ...options,\n          onlyEvaluateLocally: true,\n          sendFeatureFlagEvents: false\n        });\n      }\n      if (matchValue) {\n        response = await this.featureFlagsPoller?.computeFeatureFlagPayloadLocally(key, matchValue);\n      }\n    }\n    //}\n    // set defaults\n    if (onlyEvaluateLocally == undefined) {\n      onlyEvaluateLocally = false;\n    }\n    if (sendFeatureFlagEvents == undefined) {\n      sendFeatureFlagEvents = true;\n    }\n    // set defaults\n    if (onlyEvaluateLocally == undefined) {\n      onlyEvaluateLocally = false;\n    }\n    const payloadWasLocallyEvaluated = response !== undefined;\n    if (!payloadWasLocallyEvaluated && !onlyEvaluateLocally) {\n      response = await super.getFeatureFlagPayloadStateless(key, distinctId, groups, personProperties, groupProperties, disableGeoip);\n    }\n    return response;\n  }\n  async getRemoteConfigPayload(flagKey) {\n    if (!this.options.personalApiKey) {\n      throw new Error('Personal API key is required for remote config payload decryption');\n    }\n    const response = await this._requestRemoteConfigPayload(flagKey);\n    if (!response) {\n      return undefined;\n    }\n    const parsed = await response.json();\n    // The payload from the endpoint is stored as a JSON encoded string. So when we return\n    // it, it's effectively double encoded. As far as we know, we should never get single-encoded\n    // JSON, but we'll be defensive here just in case.\n    if (typeof parsed === 'string') {\n      try {\n        // If the parsed value is a string, try parsing it again to handle double-encoded JSON\n        return JSON.parse(parsed);\n      } catch (e) {\n        // If second parse fails, return the string as is\n        return parsed;\n      }\n    }\n    return parsed;\n  }\n  async isFeatureEnabled(key, distinctId, options) {\n    const feat = await this.getFeatureFlag(key, distinctId, options);\n    if (feat === undefined) {\n      return undefined;\n    }\n    return !!feat || false;\n  }\n  async getAllFlags(distinctId, options) {\n    const response = await this.getAllFlagsAndPayloads(distinctId, options);\n    return response.featureFlags || {};\n  }\n  async getAllFlagsAndPayloads(distinctId, options) {\n    const {\n      groups,\n      disableGeoip,\n      flagKeys\n    } = options || {};\n    let {\n      onlyEvaluateLocally,\n      personProperties,\n      groupProperties\n    } = options || {};\n    const adjustedProperties = this.addLocalPersonAndGroupProperties(distinctId, groups, personProperties, groupProperties);\n    personProperties = adjustedProperties.allPersonProperties;\n    groupProperties = adjustedProperties.allGroupProperties;\n    // set defaults\n    if (onlyEvaluateLocally == undefined) {\n      onlyEvaluateLocally = false;\n    }\n    const localEvaluationResult = await this.featureFlagsPoller?.getAllFlagsAndPayloads(distinctId, groups, personProperties, groupProperties, flagKeys);\n    let featureFlags = {};\n    let featureFlagPayloads = {};\n    let fallbackToFlags = true;\n    if (localEvaluationResult) {\n      featureFlags = localEvaluationResult.response;\n      featureFlagPayloads = localEvaluationResult.payloads;\n      fallbackToFlags = localEvaluationResult.fallbackToFlags;\n    }\n    if (fallbackToFlags && !onlyEvaluateLocally) {\n      const remoteEvaluationResult = await super.getFeatureFlagsAndPayloadsStateless(distinctId, groups, personProperties, groupProperties, disableGeoip, flagKeys);\n      featureFlags = {\n        ...featureFlags,\n        ...(remoteEvaluationResult.flags || {})\n      };\n      featureFlagPayloads = {\n        ...featureFlagPayloads,\n        ...(remoteEvaluationResult.payloads || {})\n      };\n    }\n    return {\n      featureFlags,\n      featureFlagPayloads\n    };\n  }\n  groupIdentify({\n    groupType,\n    groupKey,\n    properties,\n    distinctId,\n    disableGeoip\n  }) {\n    super.groupIdentifyStateless(groupType, groupKey, properties, {\n      disableGeoip\n    }, distinctId);\n  }\n  /**\r\n   * Reloads the feature flag definitions from the server for local evaluation.\r\n   * This is useful to call if you want to ensure that the feature flags are up to date before calling getFeatureFlag.\r\n   */\n  async reloadFeatureFlags() {\n    await this.featureFlagsPoller?.loadFeatureFlags(true);\n  }\n  async _shutdown(shutdownTimeoutMs) {\n    this.featureFlagsPoller?.stopPoller();\n    return super._shutdown(shutdownTimeoutMs);\n  }\n  async _requestRemoteConfigPayload(flagKey) {\n    if (!this.options.personalApiKey) {\n      return undefined;\n    }\n    const url = `${this.host}/api/projects/@current/feature_flags/${flagKey}/remote_config/`;\n    const options = {\n      method: 'GET',\n      headers: {\n        ...this.getCustomHeaders(),\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${this.options.personalApiKey}`\n      }\n    };\n    let abortTimeout = null;\n    if (this.options.requestTimeout && typeof this.options.requestTimeout === 'number') {\n      const controller = new AbortController();\n      abortTimeout = safeSetTimeout(() => {\n        controller.abort();\n      }, this.options.requestTimeout);\n      options.signal = controller.signal;\n    }\n    try {\n      return await this.fetch(url, options);\n    } catch (error) {\n      this._events.emit('error', error);\n      return undefined;\n    } finally {\n      if (abortTimeout) {\n        clearTimeout(abortTimeout);\n      }\n    }\n  }\n  extractPropertiesFromEvent(eventProperties, groups) {\n    if (!eventProperties) {\n      return {\n        personProperties: {},\n        groupProperties: {}\n      };\n    }\n    const personProperties = {};\n    const groupProperties = {};\n    for (const [key, value] of Object.entries(eventProperties)) {\n      // If the value is a plain object and the key exists in groups, treat it as group properties\n      if (isPlainObject(value) && groups && key in groups) {\n        const groupProps = {};\n        for (const [groupKey, groupValue] of Object.entries(value)) {\n          groupProps[String(groupKey)] = String(groupValue);\n        }\n        groupProperties[String(key)] = groupProps;\n      } else {\n        // Otherwise treat as person property\n        personProperties[String(key)] = String(value);\n      }\n    }\n    return {\n      personProperties,\n      groupProperties\n    };\n  }\n  async getFeatureFlagsForEvent(distinctId, groups, disableGeoip, sendFeatureFlagsOptions) {\n    // Use properties directly from options if they exist\n    const finalPersonProperties = sendFeatureFlagsOptions?.personProperties || {};\n    const finalGroupProperties = sendFeatureFlagsOptions?.groupProperties || {};\n    const flagKeys = sendFeatureFlagsOptions?.flagKeys;\n    // Check if we should only evaluate locally\n    const onlyEvaluateLocally = sendFeatureFlagsOptions?.onlyEvaluateLocally ?? false;\n    // If onlyEvaluateLocally is true, only use local evaluation\n    if (onlyEvaluateLocally) {\n      if ((this.featureFlagsPoller?.featureFlags?.length || 0) > 0) {\n        const groupsWithStringValues = {};\n        for (const [key, value] of Object.entries(groups || {})) {\n          groupsWithStringValues[key] = String(value);\n        }\n        return await this.getAllFlags(distinctId, {\n          groups: groupsWithStringValues,\n          personProperties: finalPersonProperties,\n          groupProperties: finalGroupProperties,\n          disableGeoip,\n          onlyEvaluateLocally: true,\n          flagKeys\n        });\n      } else {\n        // If onlyEvaluateLocally is true but we don't have local flags, return empty\n        return {};\n      }\n    }\n    // Prefer local evaluation if available (default behavior; I'd rather not penalize users who haven't updated to the new API but still want to use local evaluation)\n    if ((this.featureFlagsPoller?.featureFlags?.length || 0) > 0) {\n      const groupsWithStringValues = {};\n      for (const [key, value] of Object.entries(groups || {})) {\n        groupsWithStringValues[key] = String(value);\n      }\n      return await this.getAllFlags(distinctId, {\n        groups: groupsWithStringValues,\n        personProperties: finalPersonProperties,\n        groupProperties: finalGroupProperties,\n        disableGeoip,\n        onlyEvaluateLocally: true,\n        flagKeys\n      });\n    }\n    // Fall back to remote evaluation if local evaluation is not available\n    return (await super.getFeatureFlagsStateless(distinctId, groups, finalPersonProperties, finalGroupProperties, disableGeoip)).flags;\n  }\n  addLocalPersonAndGroupProperties(distinctId, groups, personProperties, groupProperties) {\n    const allPersonProperties = {\n      distinct_id: distinctId,\n      ...(personProperties || {})\n    };\n    const allGroupProperties = {};\n    if (groups) {\n      for (const groupName of Object.keys(groups)) {\n        allGroupProperties[groupName] = {\n          $group_key: groups[groupName],\n          ...(groupProperties?.[groupName] || {})\n        };\n      }\n    }\n    return {\n      allPersonProperties,\n      allGroupProperties\n    };\n  }\n  captureException(error, distinctId, additionalProperties) {\n    const syntheticException = new Error('PostHog syntheticException');\n    ErrorTracking.buildEventMessage(error, {\n      syntheticException\n    }, distinctId, additionalProperties).then(msg => {\n      this.capture(msg);\n    });\n  }\n  async captureExceptionImmediate(error, distinctId, additionalProperties) {\n    const syntheticException = new Error('PostHog syntheticException');\n    const evtMsg = await ErrorTracking.buildEventMessage(error, {\n      syntheticException\n    }, distinctId, additionalProperties);\n    return await this.captureImmediate(evtMsg);\n  }\n}\n\n// Portions of this file are derived from getsentry/sentry-javascript by Software, Inc. dba Sentry\n// Licensed under the MIT License\n// This was originally forked from https://github.com/csnover/TraceKit, and was largely\n// re-written as part of raven - js.\n//\n// This code was later copied to the JavaScript mono - repo and further modified and\n// refactored over the years.\n// Copyright (c) 2013 Onur Can Cakmak onur.cakmak@gmail.com and all TraceKit contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files(the 'Software'), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n// merge, publish, distribute, sublicense, and / or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies\n// or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\nconst STACKTRACE_FRAME_LIMIT = 50;\nconst UNKNOWN_FUNCTION = '?';\n/** Node Stack line parser */\nfunction node(getModule) {\n  const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n  return line => {\n    const lineMatch = line.match(FULL_MATCH);\n    if (lineMatch) {\n      let object;\n      let method;\n      let functionName;\n      let typeName;\n      let methodName;\n      if (lineMatch[1]) {\n        functionName = lineMatch[1];\n        let methodStart = functionName.lastIndexOf('.');\n        if (functionName[methodStart - 1] === '.') {\n          methodStart--;\n        }\n        if (methodStart > 0) {\n          object = functionName.slice(0, methodStart);\n          method = functionName.slice(methodStart + 1);\n          const objectEnd = object.indexOf('.Module');\n          if (objectEnd > 0) {\n            functionName = functionName.slice(objectEnd + 1);\n            object = object.slice(0, objectEnd);\n          }\n        }\n        typeName = undefined;\n      }\n      if (method) {\n        typeName = object;\n        methodName = method;\n      }\n      if (method === '<anonymous>') {\n        methodName = undefined;\n        functionName = undefined;\n      }\n      if (functionName === undefined) {\n        methodName = methodName || UNKNOWN_FUNCTION;\n        functionName = typeName ? `${typeName}.${methodName}` : methodName;\n      }\n      let filename = lineMatch[2]?.startsWith('file://') ? lineMatch[2].slice(7) : lineMatch[2];\n      const isNative = lineMatch[5] === 'native';\n      // If it's a Windows path, trim the leading slash so that `/C:/foo` becomes `C:/foo`\n      if (filename?.match(/\\/[A-Z]:/)) {\n        filename = filename.slice(1);\n      }\n      if (!filename && lineMatch[5] && !isNative) {\n        filename = lineMatch[5];\n      }\n      return {\n        filename: filename ? decodeURI(filename) : undefined,\n        module: getModule ? getModule(filename) : undefined,\n        function: functionName,\n        lineno: _parseIntOrUndefined(lineMatch[3]),\n        colno: _parseIntOrUndefined(lineMatch[4]),\n        in_app: filenameIsInApp(filename || '', isNative),\n        platform: 'node:javascript'\n      };\n    }\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line,\n        platform: 'node:javascript'\n      };\n    }\n    return undefined;\n  };\n}\n/**\r\n * Does this filename look like it's part of the app code?\r\n */\nfunction filenameIsInApp(filename, isNative = false) {\n  const isInternal = isNative || filename &&\n  // It's not internal if it's an absolute linux path\n  !filename.startsWith('/') &&\n  // It's not internal if it's an absolute windows path\n  !filename.match(/^[A-Z]:/) &&\n  // It's not internal if the path is starting with a dot\n  !filename.startsWith('.') &&\n  // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack\n  !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\\-+])*:\\/\\//); // Schema from: https://stackoverflow.com/a/3641782\n  // in_app is all that's not an internal Node function or a module within node_modules\n  // note that isNative appears to return true even for node core libraries\n  // see https://github.com/getsentry/raven-node/issues/176\n  return !isInternal && filename !== undefined && !filename.includes('node_modules/');\n}\nfunction _parseIntOrUndefined(input) {\n  return parseInt(input || '', 10) || undefined;\n}\nfunction nodeStackLineParser(getModule) {\n  return [90, node(getModule)];\n}\nfunction createStackParser(getModule) {\n  const parsers = [nodeStackLineParser(getModule)];\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n  return (stack, skipFirstLines = 0) => {\n    const frames = [];\n    const lines = stack.split('\\n');\n    for (let i = skipFirstLines; i < lines.length; i++) {\n      const line = lines[i];\n      // Ignore lines over 1kb as they are unlikely to be stack frames.\n      if (line.length > 1024) {\n        continue;\n      }\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n      // https://github.com/getsentry/sentry-javascript/issues/7813\n      // Skip Error: lines\n      if (cleanedLine.match(/\\S*Error: /)) {\n        continue;\n      }\n      for (const parser of sortedParsers) {\n        const frame = parser(cleanedLine);\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n      if (frames.length >= STACKTRACE_FRAME_LIMIT) {\n        break;\n      }\n    }\n    return reverseAndStripFrames(frames);\n  };\n}\nfunction reverseAndStripFrames(stack) {\n  if (!stack.length) {\n    return [];\n  }\n  const localStack = Array.from(stack);\n  localStack.reverse();\n  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map(frame => ({\n    ...frame,\n    filename: frame.filename || getLastStackFrame(localStack).filename,\n    function: frame.function || UNKNOWN_FUNCTION\n  }));\n}\nfunction getLastStackFrame(arr) {\n  return arr[arr.length - 1] || {};\n}\n\nErrorTracking.stackParser = createStackParser(createGetModuleFromFilename());\nErrorTracking.frameModifiers = [addSourceContext];\nclass PostHog extends PostHogBackendClient {\n  getLibraryId() {\n    return 'posthog-node';\n  }\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9zdGhvZy1ub2RlL2xpYi9ub2RlL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEyQztBQUNBO0FBQ0s7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0IsVUFBVSxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUNBQXFDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxHQUFHO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxHQUFHLEdBQUc7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxHQUFHO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjLEtBQUssZ0JBQWdCO0FBQ2hFLGdCQUFnQixnQkFBZ0Isd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkMsUUFBUSwyQkFBMkI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFFBQVEsMkJBQTJCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVCQUF1QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFVBQVU7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxrQkFBa0I7QUFDMUY7QUFDQTtBQUNBLFlBQVksMENBQTBDLFVBQVUsZUFBZSxtQ0FBbUMsS0FBSztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLGtFQUFrRSw2Q0FBTywrQ0FBK0MscUNBQUc7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sRUFBRSx1Q0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0MsR0FBRyxZQUFZO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVyxHQUFHLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFnQjtBQUNuQyx1QkFBdUIsOERBQWU7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9GQUFvRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrRUFBa0U7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Riw0QkFBNEIsa0JBQWtCLDRCQUE0QjtBQUNqSzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGVBQWUsSUFBSTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVksa0JBQWtCLEtBQUs7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsMkZBQTJGO0FBQzNGLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNENBQTRDO0FBQzVGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEMsNENBQTRDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxHQUFHLFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsNkNBQTZDO0FBQzdDLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxTQUFTLFlBQVk7QUFDakQ7QUFDQTtBQUNBLHVCQUF1QixnRUFBZ0U7QUFDdkY7QUFDQTtBQUNBLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCLHNCQUFzQixtQkFBbUI7QUFDMUc7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLGdFQUFnRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOERBQThELHVCQUF1QixzQkFBc0I7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSx1QkFBdUIsc0JBQXNCO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSx1QkFBdUIsc0JBQXNCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSx1QkFBdUIsc0JBQXNCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHVCQUF1QixzQkFBc0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHVCQUF1QixzQkFBc0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHVCQUF1QixzQkFBc0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGdDQUFnQztBQUNoQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVLHNCQUFzQixZQUFZO0FBQ25FO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWdFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGdCQUFnQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw0QkFBNEI7QUFDN0UsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDRCQUE0QjtBQUNqRixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxxQkFBcUIsMkJBQTJCLGtCQUFrQjtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSSx3Q0FBd0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtIQUFnQjtBQUNqQyxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx1QkFBdUIsc0JBQXNCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLEtBQUssS0FBSyxTQUFTO0FBQ3pHLFFBQVE7QUFDUjtBQUNBLHdHQUF3RyxJQUFJLElBQUksRUFBRTtBQUNsSCxVQUFVO0FBQ1Ysb0VBQW9FLElBQUksSUFBSSxFQUFFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHVCQUF1QixzQkFBc0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3R0FBd0csU0FBUyxJQUFJLEVBQUU7QUFDdkgsVUFBVTtBQUNWLG9FQUFvRSxTQUFTLElBQUksRUFBRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHVCQUF1QixzQkFBc0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRiw4QkFBOEIsbUJBQW1CLFNBQVM7QUFDcEo7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLFVBQVU7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysb0tBQW9LLFNBQVMsNkJBQTZCLHNCQUFzQjtBQUNoTztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILDBCQUEwQjtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyS0FBMkssMEJBQTBCO0FBQ3JNO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLDBCQUEwQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLDZCQUE2QjtBQUNwSDtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQkFBb0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVSwyQ0FBMkMsbUJBQW1CO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSSxHQUFHLFdBQVcsRUFBRSxLQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUssaURBQWlELFVBQVU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esd0RBQXdELE1BQU0sV0FBVyxJQUFJO0FBQzdFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw0SkFBNEosc0JBQXNCO0FBQ2xMO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3REFBd0QsTUFBTSxXQUFXLElBQUk7QUFDN0U7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0MsSUFBSTtBQUNKLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0IsR0FBRyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsSUFBSSxHQUFHLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVSx1Q0FBdUMsUUFBUTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRCQUE0QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEdBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVMsR0FBRyxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdIO0FBQ2hIIiwic291cmNlcyI6WyIvVXNlcnMvYXBwbGUvcmVuZXdwYWwvbm9kZV9tb2R1bGVzL3Bvc3Rob2ctbm9kZS9saWIvbm9kZS9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcG9zaXgsIGRpcm5hbWUsIHNlcCB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgY3JlYXRlUmVhZFN0cmVhbSB9IGZyb20gJ25vZGU6ZnMnO1xuaW1wb3J0IHsgY3JlYXRlSW50ZXJmYWNlIH0gZnJvbSAnbm9kZTpyZWFkbGluZSc7XG5cbi8qKlxyXG4gKiBAZmlsZSBBZGFwdGVkIGZyb20gW3Bvc3Rob2ctanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9Qb3N0SG9nL3Bvc3Rob2ctanMvYmxvYi84MTU3ZGY5MzVhNGQwZTcxZDJmZWZlZjcxMjdhYTg1ZWU1MWM4MmQxL3NyYy9leHRlbnNpb25zL3NlbnRyeS1pbnRlZ3JhdGlvbi50cykgd2l0aCBtb2RpZmljYXRpb25zIGZvciB0aGUgTm9kZSBTREsuXHJcbiAqL1xuLyoqXHJcbiAqIEludGVncmF0ZSBTZW50cnkgd2l0aCBQb3N0SG9nLiBUaGlzIHdpbGwgYWRkIGEgZGlyZWN0IGxpbmsgdG8gdGhlIHBlcnNvbiBpbiBTZW50cnksIGFuZCBhbiAkZXhjZXB0aW9uIGV2ZW50IGluIFBvc3RIb2cuXHJcbiAqXHJcbiAqICMjIyBVc2FnZVxyXG4gKlxyXG4gKiAgICAgU2VudHJ5LmluaXQoe1xyXG4gKiAgICAgICAgICBkc246ICdodHRwczovL2V4YW1wbGUnLFxyXG4gKiAgICAgICAgICBpbnRlZ3JhdGlvbnM6IFtcclxuICogICAgICAgICAgICAgIG5ldyBQb3N0SG9nU2VudHJ5SW50ZWdyYXRpb24ocG9zdGhvZylcclxuICogICAgICAgICAgXVxyXG4gKiAgICAgfSlcclxuICpcclxuICogICAgIFNlbnRyeS5zZXRUYWcoUG9zdEhvZ1NlbnRyeUludGVncmF0aW9uLlBPU1RIT0dfSURfVEFHLCAnc29tZSBkaXN0aW5jdCBpZCcpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW3Bvc3Rob2ddIFRoZSBwb3N0aG9nIG9iamVjdFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29yZ2FuaXphdGlvbl0gT3B0aW9uYWw6IFRoZSBTZW50cnkgb3JnYW5pemF0aW9uLCB1c2VkIHRvIHNlbmQgYSBkaXJlY3QgbGluayBmcm9tIFBvc3RIb2cgdG8gU2VudHJ5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvamVjdElkXSBPcHRpb25hbDogVGhlIFNlbnRyeSBwcm9qZWN0IGlkLCB1c2VkIHRvIHNlbmQgYSBkaXJlY3QgbGluayBmcm9tIFBvc3RIb2cgdG8gU2VudHJ5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSBPcHRpb25hbDogVXJsIG9mIGEgc2VsZi1ob3N0ZWQgc2VudHJ5IGluc3RhbmNlIChkZWZhdWx0OiBodHRwczovL3NlbnRyeS5pby9vcmdhbml6YXRpb25zLylcclxuICogQHBhcmFtIHtTZXZlcml0eUxldmVsW10gfCAnKid9IFtzZXZlcml0eUFsbG93TGlzdF0gT3B0aW9uYWw6IHNlbmQgZXZlbnRzIG1hdGNoaW5nIHRoZSBwcm92aWRlZCBsZXZlbHMuIFVzZSAnKicgdG8gc2VuZCBhbGwgZXZlbnRzIChkZWZhdWx0OiBbJ2Vycm9yJ10pXHJcbiAqL1xuY29uc3QgTkFNRSA9ICdwb3N0aG9nLW5vZGUnO1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRQcm9jZXNzb3IoX3Bvc3Rob2csIHtcbiAgb3JnYW5pemF0aW9uLFxuICBwcm9qZWN0SWQsXG4gIHByZWZpeCxcbiAgc2V2ZXJpdHlBbGxvd0xpc3QgPSBbJ2Vycm9yJ11cbn0gPSB7fSkge1xuICByZXR1cm4gZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNob3VsZFByb2Nlc3NMZXZlbCA9IHNldmVyaXR5QWxsb3dMaXN0ID09PSAnKicgfHwgc2V2ZXJpdHlBbGxvd0xpc3QuaW5jbHVkZXMoZXZlbnQubGV2ZWwpO1xuICAgIGlmICghc2hvdWxkUHJvY2Vzc0xldmVsKSB7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIGlmICghZXZlbnQudGFncykge1xuICAgICAgZXZlbnQudGFncyA9IHt9O1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIFBvc3RIb2cgdXNlciBJRCBmcm9tIGEgc3BlY2lmaWMgdGFnLCB3aGljaCB1c2VycyBjYW4gc2V0IG9uIHRoZWlyIFNlbnRyeSBzY29wZSBhcyB0aGV5IG5lZWQuXG4gICAgY29uc3QgdXNlcklkID0gZXZlbnQudGFnc1tQb3N0SG9nU2VudHJ5SW50ZWdyYXRpb24uUE9TVEhPR19JRF9UQUddO1xuICAgIGlmICh1c2VySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSWYgd2UgY2FuJ3QgZmluZCBhIHVzZXIgSUQsIGRvbid0IGJvdGhlciBsaW5raW5nIHRoZSBldmVudC4gV2Ugd29uJ3QgYmUgYWJsZSB0byBzZW5kIGFueXRoaW5nIG1lYW5pbmdmdWwgdG8gUG9zdEhvZyB3aXRob3V0IGl0LlxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBjb25zdCB1aUhvc3QgPSBfcG9zdGhvZy5vcHRpb25zLmhvc3QgPz8gJ2h0dHBzOi8vdXMuaS5wb3N0aG9nLmNvbSc7XG4gICAgY29uc3QgcGVyc29uVXJsID0gbmV3IFVSTChgL3Byb2plY3QvJHtfcG9zdGhvZy5hcGlLZXl9L3BlcnNvbi8ke3VzZXJJZH1gLCB1aUhvc3QpLnRvU3RyaW5nKCk7XG4gICAgZXZlbnQudGFnc1snUG9zdEhvZyBQZXJzb24gVVJMJ10gPSBwZXJzb25Vcmw7XG4gICAgY29uc3QgZXhjZXB0aW9ucyA9IGV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzIHx8IFtdO1xuICAgIGNvbnN0IGV4Y2VwdGlvbkxpc3QgPSBleGNlcHRpb25zLm1hcChleGNlcHRpb24gPT4gKHtcbiAgICAgIC4uLmV4Y2VwdGlvbixcbiAgICAgIHN0YWNrdHJhY2U6IGV4Y2VwdGlvbi5zdGFja3RyYWNlID8ge1xuICAgICAgICAuLi5leGNlcHRpb24uc3RhY2t0cmFjZSxcbiAgICAgICAgdHlwZTogJ3JhdycsXG4gICAgICAgIGZyYW1lczogKGV4Y2VwdGlvbi5zdGFja3RyYWNlLmZyYW1lcyB8fCBbXSkubWFwKGZyYW1lID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZnJhbWUsXG4gICAgICAgICAgICBwbGF0Zm9ybTogJ25vZGU6amF2YXNjcmlwdCdcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfSA6IHVuZGVmaW5lZFxuICAgIH0pKTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgLy8gUG9zdEhvZyBFeGNlcHRpb24gUHJvcGVydGllcyxcbiAgICAgICRleGNlcHRpb25fbWVzc2FnZTogZXhjZXB0aW9uc1swXT8udmFsdWUgfHwgZXZlbnQubWVzc2FnZSxcbiAgICAgICRleGNlcHRpb25fdHlwZTogZXhjZXB0aW9uc1swXT8udHlwZSxcbiAgICAgICRleGNlcHRpb25fcGVyc29uVVJMOiBwZXJzb25VcmwsXG4gICAgICAkZXhjZXB0aW9uX2xldmVsOiBldmVudC5sZXZlbCxcbiAgICAgICRleGNlcHRpb25fbGlzdDogZXhjZXB0aW9uTGlzdCxcbiAgICAgIC8vIFNlbnRyeSBFeGNlcHRpb24gUHJvcGVydGllc1xuICAgICAgJHNlbnRyeV9ldmVudF9pZDogZXZlbnQuZXZlbnRfaWQsXG4gICAgICAkc2VudHJ5X2V4Y2VwdGlvbjogZXZlbnQuZXhjZXB0aW9uLFxuICAgICAgJHNlbnRyeV9leGNlcHRpb25fbWVzc2FnZTogZXhjZXB0aW9uc1swXT8udmFsdWUgfHwgZXZlbnQubWVzc2FnZSxcbiAgICAgICRzZW50cnlfZXhjZXB0aW9uX3R5cGU6IGV4Y2VwdGlvbnNbMF0/LnR5cGUsXG4gICAgICAkc2VudHJ5X3RhZ3M6IGV2ZW50LnRhZ3NcbiAgICB9O1xuICAgIGlmIChvcmdhbml6YXRpb24gJiYgcHJvamVjdElkKSB7XG4gICAgICBwcm9wZXJ0aWVzWyckc2VudHJ5X3VybCddID0gKHByZWZpeCB8fCAnaHR0cHM6Ly9zZW50cnkuaW8vb3JnYW5pemF0aW9ucy8nKSArIG9yZ2FuaXphdGlvbiArICcvaXNzdWVzLz9wcm9qZWN0PScgKyBwcm9qZWN0SWQgKyAnJnF1ZXJ5PScgKyBldmVudC5ldmVudF9pZDtcbiAgICB9XG4gICAgX3Bvc3Rob2cuY2FwdHVyZSh7XG4gICAgICBldmVudDogJyRleGNlcHRpb24nLFxuICAgICAgZGlzdGluY3RJZDogdXNlcklkLFxuICAgICAgcHJvcGVydGllc1xuICAgIH0pO1xuICAgIHJldHVybiBldmVudDtcbiAgfTtcbn1cbi8vIFY4IGludGVncmF0aW9uIC0gZnVuY3Rpb24gYmFzZWRcbmZ1bmN0aW9uIHNlbnRyeUludGVncmF0aW9uKF9wb3N0aG9nLCBvcHRpb25zKSB7XG4gIGNvbnN0IHByb2Nlc3NvciA9IGNyZWF0ZUV2ZW50UHJvY2Vzc29yKF9wb3N0aG9nLCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBOQU1FLFxuICAgIHByb2Nlc3NFdmVudChldmVudCkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NvcihldmVudCk7XG4gICAgfVxuICB9O1xufVxuLy8gVjcgaW50ZWdyYXRpb24gLSBjbGFzcyBiYXNlZFxuY2xhc3MgUG9zdEhvZ1NlbnRyeUludGVncmF0aW9uIHtcbiAgY29uc3RydWN0b3IoX3Bvc3Rob2csIG9yZ2FuaXphdGlvbiwgcHJlZml4LCBzZXZlcml0eUFsbG93TGlzdCkge1xuICAgIHRoaXMubmFtZSA9IE5BTUU7XG4gICAgLy8gc2V0dXBPbmNlIGdldHMgY2FsbGVkIGJ5IFNlbnRyeSB3aGVuIGl0IGludGlhbGl6ZXMgdGhlIHBsdWdpblxuICAgIHRoaXMubmFtZSA9IE5BTUU7XG4gICAgdGhpcy5zZXR1cE9uY2UgPSBmdW5jdGlvbiAoYWRkR2xvYmFsRXZlbnRQcm9jZXNzb3IsIGdldEN1cnJlbnRIdWIpIHtcbiAgICAgIGNvbnN0IHByb2plY3RJZCA9IGdldEN1cnJlbnRIdWIoKT8uZ2V0Q2xpZW50KCk/LmdldERzbigpPy5wcm9qZWN0SWQ7XG4gICAgICBhZGRHbG9iYWxFdmVudFByb2Nlc3NvcihjcmVhdGVFdmVudFByb2Nlc3NvcihfcG9zdGhvZywge1xuICAgICAgICBvcmdhbml6YXRpb24sXG4gICAgICAgIHByb2plY3RJZCxcbiAgICAgICAgcHJlZml4LFxuICAgICAgICBzZXZlcml0eUFsbG93TGlzdFxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cbn1cblBvc3RIb2dTZW50cnlJbnRlZ3JhdGlvbi5QT1NUSE9HX0lEX1RBRyA9ICdwb3N0aG9nX2Rpc3RpbmN0X2lkJztcblxuLy8gdmVuZG9yIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy91dWlkdjcvYmxvYi9mMzBiN2E3ZmFmZjczYWZiY2UwYjI3YTQ2YzYzODMxMGY5NjkxMmJhL3NyYy9pbmRleC50c1xyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svdXVpZHY3I2xpY2Vuc2VcclxuLyoqXHJcbiAqIHV1aWR2NzogQW4gZXhwZXJpbWVudGFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBwcm9wb3NlZCBVVUlEIFZlcnNpb24gN1xyXG4gKlxyXG4gKiBAbGljZW5zZSBBcGFjaGUtMi4wXHJcbiAqIEBjb3B5cmlnaHQgMjAyMS0yMDIzIExpb3NLXHJcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxyXG4gKi9cclxuY29uc3QgRElHSVRTID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XHJcbi8qKiBSZXByZXNlbnRzIGEgVVVJRCBhcyBhIDE2LWJ5dGUgYnl0ZSBhcnJheS4gKi9cclxuY2xhc3MgVVVJRCB7XHJcbiAgICAvKiogQHBhcmFtIGJ5dGVzIC0gVGhlIDE2LWJ5dGUgYnl0ZSBhcnJheSByZXByZXNlbnRhdGlvbi4gKi9cclxuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBmcm9tIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiwgYSAxNi1ieXRlIGJ5dGUgYXJyYXlcclxuICAgICAqIGNvbnRhaW5pbmcgdGhlIGJpbmFyeSBVVUlEIHJlcHJlc2VudGF0aW9uIGluIHRoZSBiaWctZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgZG9lcyBOT1Qgc2hhbGxvdy1jb3B5IHRoZSBhcmd1bWVudCwgYW5kIHRodXMgdGhlIGNyZWF0ZWQgb2JqZWN0XHJcbiAgICAgKiBob2xkcyB0aGUgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIFR5cGVFcnJvciBpZiB0aGUgbGVuZ3RoIG9mIHRoZSBhcmd1bWVudCBpcyBub3QgMTYuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBvZklubmVyKGJ5dGVzKSB7XHJcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gMTYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCAxMjgtYml0IGxlbmd0aFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVVJRChieXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYSBieXRlIGFycmF5IGZyb20gVVVJRHY3IGZpZWxkIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdW5peFRzTXMgLSBBIDQ4LWJpdCBgdW5peF90c19tc2AgZmllbGQgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gcmFuZEEgLSBBIDEyLWJpdCBgcmFuZF9hYCBmaWVsZCB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSByYW5kQkhpIC0gVGhlIGhpZ2hlciAzMCBiaXRzIG9mIDYyLWJpdCBgcmFuZF9iYCBmaWVsZCB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSByYW5kQkxvIC0gVGhlIGxvd2VyIDMyIGJpdHMgb2YgNjItYml0IGByYW5kX2JgIGZpZWxkIHZhbHVlLlxyXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIGFueSBmaWVsZCB2YWx1ZSBpcyBvdXQgb2YgdGhlIHNwZWNpZmllZCByYW5nZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21GaWVsZHNWNyh1bml4VHNNcywgcmFuZEEsIHJhbmRCSGksIHJhbmRCTG8pIHtcclxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodW5peFRzTXMpIHx8XHJcbiAgICAgICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKHJhbmRBKSB8fFxyXG4gICAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihyYW5kQkhpKSB8fFxyXG4gICAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihyYW5kQkxvKSB8fFxyXG4gICAgICAgICAgICB1bml4VHNNcyA8IDAgfHxcclxuICAgICAgICAgICAgcmFuZEEgPCAwIHx8XHJcbiAgICAgICAgICAgIHJhbmRCSGkgPCAwIHx8XHJcbiAgICAgICAgICAgIHJhbmRCTG8gPCAwIHx8XHJcbiAgICAgICAgICAgIHVuaXhUc01zID4gMjgxNDc0OTc2NzEwNjU1IHx8XHJcbiAgICAgICAgICAgIHJhbmRBID4gMHhmZmYgfHxcclxuICAgICAgICAgICAgcmFuZEJIaSA+IDEwNzM3NDE4MjMgfHxcclxuICAgICAgICAgICAgcmFuZEJMbyA+IDQyOTQ5NjcyOTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIGZpZWxkIHZhbHVlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2KTtcclxuICAgICAgICBieXRlc1swXSA9IHVuaXhUc01zIC8gMiAqKiA0MDtcclxuICAgICAgICBieXRlc1sxXSA9IHVuaXhUc01zIC8gMiAqKiAzMjtcclxuICAgICAgICBieXRlc1syXSA9IHVuaXhUc01zIC8gMiAqKiAyNDtcclxuICAgICAgICBieXRlc1szXSA9IHVuaXhUc01zIC8gMiAqKiAxNjtcclxuICAgICAgICBieXRlc1s0XSA9IHVuaXhUc01zIC8gMiAqKiA4O1xyXG4gICAgICAgIGJ5dGVzWzVdID0gdW5peFRzTXM7XHJcbiAgICAgICAgYnl0ZXNbNl0gPSAweDcwIHwgKHJhbmRBID4+PiA4KTtcclxuICAgICAgICBieXRlc1s3XSA9IHJhbmRBO1xyXG4gICAgICAgIGJ5dGVzWzhdID0gMHg4MCB8IChyYW5kQkhpID4+PiAyNCk7XHJcbiAgICAgICAgYnl0ZXNbOV0gPSByYW5kQkhpID4+PiAxNjtcclxuICAgICAgICBieXRlc1sxMF0gPSByYW5kQkhpID4+PiA4O1xyXG4gICAgICAgIGJ5dGVzWzExXSA9IHJhbmRCSGk7XHJcbiAgICAgICAgYnl0ZXNbMTJdID0gcmFuZEJMbyA+Pj4gMjQ7XHJcbiAgICAgICAgYnl0ZXNbMTNdID0gcmFuZEJMbyA+Pj4gMTY7XHJcbiAgICAgICAgYnl0ZXNbMTRdID0gcmFuZEJMbyA+Pj4gODtcclxuICAgICAgICBieXRlc1sxNV0gPSByYW5kQkxvO1xyXG4gICAgICAgIHJldHVybiBuZXcgVVVJRChieXRlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyBhIGJ5dGUgYXJyYXkgZnJvbSBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgZm9ybWF0czpcclxuICAgICAqXHJcbiAgICAgKiAtIDMyLWRpZ2l0IGhleGFkZWNpbWFsIGZvcm1hdCB3aXRob3V0IGh5cGhlbnM6IGAwMTg5ZGNkNTUzMTE3ZDQwOGRiMDk0OTZhMmVlZjM3YmBcclxuICAgICAqIC0gOC00LTQtNC0xMiBoeXBoZW5hdGVkIGZvcm1hdDogYDAxODlkY2Q1LTUzMTEtN2Q0MC04ZGIwLTk0OTZhMmVlZjM3YmBcclxuICAgICAqIC0gSHlwaGVuYXRlZCBmb3JtYXQgd2l0aCBzdXJyb3VuZGluZyBicmFjZXM6IGB7MDE4OWRjZDUtNTMxMS03ZDQwLThkYjAtOTQ5NmEyZWVmMzdifWBcclxuICAgICAqIC0gUkZDIDQxMjIgVVJOIGZvcm1hdDogYHVybjp1dWlkOjAxODlkY2Q1LTUzMTEtN2Q0MC04ZGIwLTk0OTZhMmVlZjM3YmBcclxuICAgICAqXHJcbiAgICAgKiBMZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlcyByZXByZXNlbnRzIGFuIGVycm9yLlxyXG4gICAgICpcclxuICAgICAqIEB0aHJvd3MgU3ludGF4RXJyb3IgaWYgdGhlIGFyZ3VtZW50IGNvdWxkIG5vdCBwYXJzZSBhcyBhIHZhbGlkIFVVSUQgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcGFyc2UodXVpZCkge1xyXG4gICAgICAgIGxldCBoZXggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgc3dpdGNoICh1dWlkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjYXNlIDMyOlxyXG4gICAgICAgICAgICAgICAgaGV4ID0gL15bMC05YS1mXXszMn0kL2kuZXhlYyh1dWlkKT8uWzBdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzY6XHJcbiAgICAgICAgICAgICAgICBoZXggPVxyXG4gICAgICAgICAgICAgICAgICAgIC9eKFswLTlhLWZdezh9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17MTJ9KSQvaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXhlYyh1dWlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/LnNsaWNlKDEsIDYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzg6XHJcbiAgICAgICAgICAgICAgICBoZXggPVxyXG4gICAgICAgICAgICAgICAgICAgIC9eXFx7KFswLTlhLWZdezh9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17MTJ9KVxcfSQvaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXhlYyh1dWlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/LnNsaWNlKDEsIDYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNDU6XHJcbiAgICAgICAgICAgICAgICBoZXggPVxyXG4gICAgICAgICAgICAgICAgICAgIC9edXJuOnV1aWQ6KFswLTlhLWZdezh9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17MTJ9KSQvaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXhlYyh1dWlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/LnNsaWNlKDEsIDYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoZXgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5uZXIgPSBuZXcgVWludDhBcnJheSgxNik7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMiAqIGksIDIgKiBpICsgOCksIDE2KTtcclxuICAgICAgICAgICAgICAgIGlubmVyW2kgKyAwXSA9IG4gPj4+IDI0O1xyXG4gICAgICAgICAgICAgICAgaW5uZXJbaSArIDFdID0gbiA+Pj4gMTY7XHJcbiAgICAgICAgICAgICAgICBpbm5lcltpICsgMl0gPSBuID4+PiA4O1xyXG4gICAgICAgICAgICAgICAgaW5uZXJbaSArIDNdID0gbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVVSUQoaW5uZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiY291bGQgbm90IHBhcnNlIFVVSUQgc3RyaW5nXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIDgtNC00LTQtMTIgY2Fub25pY2FsIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvblxyXG4gICAgICogKGAwMTg5ZGNkNS01MzExLTdkNDAtOGRiMC05NDk2YTJlZWYzN2JgKS5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ieXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0ZXh0ICs9IERJR0lUUy5jaGFyQXQodGhpcy5ieXRlc1tpXSA+Pj4gNCk7XHJcbiAgICAgICAgICAgIHRleHQgKz0gRElHSVRTLmNoYXJBdCh0aGlzLmJ5dGVzW2ldICYgMHhmKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDMgfHwgaSA9PT0gNSB8fCBpID09PSA3IHx8IGkgPT09IDkpIHtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gXCItXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSAzMi1kaWdpdCBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiB3aXRob3V0IGh5cGhlbnNcclxuICAgICAqIChgMDE4OWRjZDU1MzExN2Q0MDhkYjA5NDk2YTJlZWYzN2JgKS5cclxuICAgICAqL1xyXG4gICAgdG9IZXgoKSB7XHJcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ieXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0ZXh0ICs9IERJR0lUUy5jaGFyQXQodGhpcy5ieXRlc1tpXSA+Pj4gNCk7XHJcbiAgICAgICAgICAgIHRleHQgKz0gRElHSVRTLmNoYXJBdCh0aGlzLmJ5dGVzW2ldICYgMHhmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcbiAgICAvKiogQHJldHVybnMgVGhlIDgtNC00LTQtMTIgY2Fub25pY2FsIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbi4gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBvcnRzIHRoZSB2YXJpYW50IGZpZWxkIHZhbHVlIG9mIHRoZSBVVUlEIG9yLCBpZiBhcHByb3ByaWF0ZSwgXCJOSUxcIiBvclxyXG4gICAgICogXCJNQVhcIi5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgY29udmVuaWVuY2UsIHRoaXMgbWV0aG9kIHJlcG9ydHMgXCJOSUxcIiBvciBcIk1BWFwiIGlmIGB0aGlzYCByZXByZXNlbnRzXHJcbiAgICAgKiB0aGUgTmlsIG9yIE1heCBVVUlELCBhbHRob3VnaCB0aGUgTmlsIGFuZCBNYXggVVVJRHMgYXJlIHRlY2huaWNhbGx5XHJcbiAgICAgKiBzdWJzdW1lZCB1bmRlciB0aGUgdmFyaWFudHMgYDBiMGAgYW5kIGAwYjExMWAsIHJlc3BlY3RpdmVseS5cclxuICAgICAqL1xyXG4gICAgZ2V0VmFyaWFudCgpIHtcclxuICAgICAgICBjb25zdCBuID0gdGhpcy5ieXRlc1s4XSA+Pj4gNDtcclxuICAgICAgICBpZiAobiA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5yZWFjaGFibGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMGIwMTExKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmV2ZXJ5KChlKSA9PiBlID09PSAwKSA/IFwiTklMXCIgOiBcIlZBUl8wXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMGIxMDExKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlZBUl8xMFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuIDw9IDBiMTEwMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJWQVJfMTEwXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMGIxMTExKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmV2ZXJ5KChlKSA9PiBlID09PSAweGZmKSA/IFwiTUFYXCIgOiBcIlZBUl9SRVNFUlZFRFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5yZWFjaGFibGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIGZpZWxkIHZhbHVlIG9mIHRoZSBVVUlEIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBVVUlEIGRvZXNcclxuICAgICAqIG5vdCBoYXZlIHRoZSB2YXJpYW50IGZpZWxkIHZhbHVlIG9mIGAwYjEwYC5cclxuICAgICAqL1xyXG4gICAgZ2V0VmVyc2lvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50KCkgPT09IFwiVkFSXzEwXCIgPyB0aGlzLmJ5dGVzWzZdID4+PiA0IDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqIENyZWF0ZXMgYW4gb2JqZWN0IGZyb20gYHRoaXNgLiAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVVUlEKHRoaXMuYnl0ZXMuc2xpY2UoMCkpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBgdGhpc2AgaXMgZXF1aXZhbGVudCB0byBgb3RoZXJgLiAqL1xyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA9PT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5lZ2F0aXZlIGludGVnZXIsIHplcm8sIG9yIHBvc2l0aXZlIGludGVnZXIgaWYgYHRoaXNgIGlzIGxlc3NcclxuICAgICAqIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gYG90aGVyYCwgcmVzcGVjdGl2ZWx5LlxyXG4gICAgICovXHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IHRoaXMuYnl0ZXNbaV0gLSBvdGhlci5ieXRlc1tpXTtcclxuICAgICAgICAgICAgaWYgKGRpZmYgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNpZ24oZGlmZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEVuY2Fwc3VsYXRlcyB0aGUgbW9ub3RvbmljIGNvdW50ZXIgc3RhdGUuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgQVBJcyB0byB1dGlsaXplIGEgc2VwYXJhdGUgY291bnRlciBzdGF0ZSBmcm9tIHRoYXQgb2YgdGhlXHJcbiAqIGdsb2JhbCBnZW5lcmF0b3IgdXNlZCBieSB7QGxpbmsgdXVpZHY3fSBhbmQge0BsaW5rIHV1aWR2N29ian0uIEluIGFkZGl0aW9uIHRvXHJcbiAqIHRoZSBkZWZhdWx0IHtAbGluayBnZW5lcmF0ZX0gbWV0aG9kLCB0aGlzIGNsYXNzIGhhcyB7QGxpbmsgZ2VuZXJhdGVPckFib3J0fVxyXG4gKiB0aGF0IGlzIHVzZWZ1bCB0byBhYnNvbHV0ZWx5IGd1YXJhbnRlZSB0aGUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIG9yZGVyIG9mXHJcbiAqIGdlbmVyYXRlZCBVVUlEcy4gU2VlIHRoZWlyIHJlc3BlY3RpdmUgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cclxuICovXHJcbmNsYXNzIFY3R2VuZXJhdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGdlbmVyYXRvciBvYmplY3Qgd2l0aCB0aGUgZGVmYXVsdCByYW5kb20gbnVtYmVyIGdlbmVyYXRvciwgb3JcclxuICAgICAqIHdpdGggdGhlIHNwZWNpZmllZCBvbmUgaWYgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LiBUaGUgc3BlY2lmaWVkIHJhbmRvbVxyXG4gICAgICogbnVtYmVyIGdlbmVyYXRvciBzaG91bGQgYmUgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nIGFuZCBzZWN1cmVseSBzZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJhbmRvbU51bWJlckdlbmVyYXRvcikge1xyXG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gMDtcclxuICAgICAgICB0aGlzLmNvdW50ZXIgPSAwO1xyXG4gICAgICAgIHRoaXMucmFuZG9tID0gcmFuZG9tTnVtYmVyR2VuZXJhdG9yID8/IGdldERlZmF1bHRSYW5kb20oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IFVVSUR2NyBvYmplY3QgZnJvbSB0aGUgY3VycmVudCB0aW1lc3RhbXAsIG9yIHJlc2V0cyB0aGVcclxuICAgICAqIGdlbmVyYXRvciB1cG9uIHNpZ25pZmljYW50IHRpbWVzdGFtcCByb2xsYmFjay5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIFVVSUQgYnkgcmV1c2luZyB0aGUgcHJldmlvdXNcclxuICAgICAqIHRpbWVzdGFtcCBldmVuIGlmIHRoZSB1cC10by1kYXRlIHRpbWVzdGFtcCBpcyBzbWFsbGVyIHRoYW4gdGhlIGltbWVkaWF0ZWx5XHJcbiAgICAgKiBwcmVjZWRpbmcgVVVJRCdzLiBIb3dldmVyLCB3aGVuIHN1Y2ggYSBjbG9jayByb2xsYmFjayBpcyBjb25zaWRlcmVkXHJcbiAgICAgKiBzaWduaWZpY2FudCAoaS5lLiwgYnkgbW9yZSB0aGFuIHRlbiBzZWNvbmRzKSwgdGhpcyBtZXRob2QgcmVzZXRzIHRoZVxyXG4gICAgICogZ2VuZXJhdG9yIGFuZCByZXR1cm5zIGEgbmV3IFVVSUQgYmFzZWQgb24gdGhlIGdpdmVuIHRpbWVzdGFtcCwgYnJlYWtpbmcgdGhlXHJcbiAgICAgKiBpbmNyZWFzaW5nIG9yZGVyIG9mIFVVSURzLlxyXG4gICAgICpcclxuICAgICAqIFNlZSB7QGxpbmsgZ2VuZXJhdGVPckFib3J0fSBmb3IgdGhlIG90aGVyIG1vZGUgb2YgZ2VuZXJhdGlvbiBhbmRcclxuICAgICAqIHtAbGluayBnZW5lcmF0ZU9yUmVzZXRDb3JlfSBmb3IgdGhlIGxvdy1sZXZlbCBwcmltaXRpdmUuXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlT3JSZXNldENvcmUoRGF0ZS5ub3coKSwgMTAwMDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgVVVJRHY3IG9iamVjdCBmcm9tIHRoZSBjdXJyZW50IHRpbWVzdGFtcCwgb3IgcmV0dXJuc1xyXG4gICAgICogYHVuZGVmaW5lZGAgdXBvbiBzaWduaWZpY2FudCB0aW1lc3RhbXAgcm9sbGJhY2suXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBVVUlEIGJ5IHJldXNpbmcgdGhlIHByZXZpb3VzXHJcbiAgICAgKiB0aW1lc3RhbXAgZXZlbiBpZiB0aGUgdXAtdG8tZGF0ZSB0aW1lc3RhbXAgaXMgc21hbGxlciB0aGFuIHRoZSBpbW1lZGlhdGVseVxyXG4gICAgICogcHJlY2VkaW5nIFVVSUQncy4gSG93ZXZlciwgd2hlbiBzdWNoIGEgY2xvY2sgcm9sbGJhY2sgaXMgY29uc2lkZXJlZFxyXG4gICAgICogc2lnbmlmaWNhbnQgKGkuZS4sIGJ5IG1vcmUgdGhhbiB0ZW4gc2Vjb25kcyksIHRoaXMgbWV0aG9kIGFib3J0cyBhbmRcclxuICAgICAqIHJldHVybnMgYHVuZGVmaW5lZGAgaW1tZWRpYXRlbHkuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIHtAbGluayBnZW5lcmF0ZX0gZm9yIHRoZSBvdGhlciBtb2RlIG9mIGdlbmVyYXRpb24gYW5kXHJcbiAgICAgKiB7QGxpbmsgZ2VuZXJhdGVPckFib3J0Q29yZX0gZm9yIHRoZSBsb3ctbGV2ZWwgcHJpbWl0aXZlLlxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZU9yQWJvcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVPckFib3J0Q29yZShEYXRlLm5vdygpLCAxMDAwMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBVVUlEdjcgb2JqZWN0IGZyb20gdGhlIGB1bml4VHNNc2AgcGFzc2VkLCBvciByZXNldHMgdGhlXHJcbiAgICAgKiBnZW5lcmF0b3IgdXBvbiBzaWduaWZpY2FudCB0aW1lc3RhbXAgcm9sbGJhY2suXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byB7QGxpbmsgZ2VuZXJhdGV9IGV4Y2VwdCB0aGF0IGl0IHRha2VzIGEgY3VzdG9tXHJcbiAgICAgKiB0aW1lc3RhbXAgYW5kIGNsb2NrIHJvbGxiYWNrIGFsbG93YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcm9sbGJhY2tBbGxvd2FuY2UgLSBUaGUgYW1vdW50IG9mIGB1bml4VHNNc2Agcm9sbGJhY2sgdGhhdCBpc1xyXG4gICAgICogY29uc2lkZXJlZCBzaWduaWZpY2FudC4gQSBzdWdnZXN0ZWQgdmFsdWUgaXMgYDEwXzAwMGAgKG1pbGxpc2Vjb25kcykuXHJcbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYHVuaXhUc01zYCBpcyBub3QgYSA0OC1iaXQgcG9zaXRpdmUgaW50ZWdlci5cclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVPclJlc2V0Q29yZSh1bml4VHNNcywgcm9sbGJhY2tBbGxvd2FuY2UpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdlbmVyYXRlT3JBYm9ydENvcmUodW5peFRzTXMsIHJvbGxiYWNrQWxsb3dhbmNlKTtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyByZXNldCBzdGF0ZSBhbmQgcmVzdW1lXHJcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gMDtcclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdlbmVyYXRlT3JBYm9ydENvcmUodW5peFRzTXMsIHJvbGxiYWNrQWxsb3dhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgVVVJRHY3IG9iamVjdCBmcm9tIHRoZSBgdW5peFRzTXNgIHBhc3NlZCwgb3IgcmV0dXJuc1xyXG4gICAgICogYHVuZGVmaW5lZGAgdXBvbiBzaWduaWZpY2FudCB0aW1lc3RhbXAgcm9sbGJhY2suXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byB7QGxpbmsgZ2VuZXJhdGVPckFib3J0fSBleGNlcHQgdGhhdCBpdCB0YWtlcyBhXHJcbiAgICAgKiBjdXN0b20gdGltZXN0YW1wIGFuZCBjbG9jayByb2xsYmFjayBhbGxvd2FuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJvbGxiYWNrQWxsb3dhbmNlIC0gVGhlIGFtb3VudCBvZiBgdW5peFRzTXNgIHJvbGxiYWNrIHRoYXQgaXNcclxuICAgICAqIGNvbnNpZGVyZWQgc2lnbmlmaWNhbnQuIEEgc3VnZ2VzdGVkIHZhbHVlIGlzIGAxMF8wMDBgIChtaWxsaXNlY29uZHMpLlxyXG4gICAgICogQHRocm93cyBSYW5nZUVycm9yIGlmIGB1bml4VHNNc2AgaXMgbm90IGEgNDgtYml0IHBvc2l0aXZlIGludGVnZXIuXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlT3JBYm9ydENvcmUodW5peFRzTXMsIHJvbGxiYWNrQWxsb3dhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgTUFYX0NPVU5URVIgPSA0Mzk4MDQ2NTExMTAzO1xyXG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih1bml4VHNNcykgfHxcclxuICAgICAgICAgICAgdW5peFRzTXMgPCAxIHx8XHJcbiAgICAgICAgICAgIHVuaXhUc01zID4gMjgxNDc0OTc2NzEwNjU1KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYHVuaXhUc01zYCBtdXN0IGJlIGEgNDgtYml0IHBvc2l0aXZlIGludGVnZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJvbGxiYWNrQWxsb3dhbmNlIDwgMCB8fCByb2xsYmFja0FsbG93YW5jZSA+IDI4MTQ3NDk3NjcxMDY1NSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImByb2xsYmFja0FsbG93YW5jZWAgb3V0IG9mIHJlYXNvbmFibGUgcmFuZ2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bml4VHNNcyA+IHRoaXMudGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gdW5peFRzTXM7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRDb3VudGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHVuaXhUc01zICsgcm9sbGJhY2tBbGxvd2FuY2UgPj0gdGhpcy50aW1lc3RhbXApIHtcclxuICAgICAgICAgICAgLy8gZ28gb24gd2l0aCBwcmV2aW91cyB0aW1lc3RhbXAgaWYgbmV3IG9uZSBpcyBub3QgbXVjaCBzbWFsbGVyXHJcbiAgICAgICAgICAgIHRoaXMuY291bnRlcisrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudGVyID4gTUFYX0NPVU5URVIpIHtcclxuICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aW1lc3RhbXAgYXQgY291bnRlciBvdmVyZmxvd1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lc3RhbXArKztcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRDb3VudGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGFib3J0IGlmIGNsb2NrIHdlbnQgYmFja3dhcmRzIHRvIHVuYmVhcmFibGUgZXh0ZW50XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBVVUlELmZyb21GaWVsZHNWNyh0aGlzLnRpbWVzdGFtcCwgTWF0aC50cnVuYyh0aGlzLmNvdW50ZXIgLyAyICoqIDMwKSwgdGhpcy5jb3VudGVyICYgKDIgKiogMzAgLSAxKSwgdGhpcy5yYW5kb20ubmV4dFVpbnQzMigpKTtcclxuICAgIH1cclxuICAgIC8qKiBJbml0aWFsaXplcyB0aGUgY291bnRlciBhdCBhIDQyLWJpdCByYW5kb20gaW50ZWdlci4gKi9cclxuICAgIHJlc2V0Q291bnRlcigpIHtcclxuICAgICAgICB0aGlzLmNvdW50ZXIgPVxyXG4gICAgICAgICAgICB0aGlzLnJhbmRvbS5uZXh0VWludDMyKCkgKiAweDQwMCArICh0aGlzLnJhbmRvbS5uZXh0VWludDMyKCkgJiAweDNmZik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBVVUlEdjQgb2JqZWN0IHV0aWxpemluZyB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgaW5zaWRlLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZVY0KCkge1xyXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoVWludDMyQXJyYXkub2YodGhpcy5yYW5kb20ubmV4dFVpbnQzMigpLCB0aGlzLnJhbmRvbS5uZXh0VWludDMyKCksIHRoaXMucmFuZG9tLm5leHRVaW50MzIoKSwgdGhpcy5yYW5kb20ubmV4dFVpbnQzMigpKS5idWZmZXIpO1xyXG4gICAgICAgIGJ5dGVzWzZdID0gMHg0MCB8IChieXRlc1s2XSA+Pj4gNCk7XHJcbiAgICAgICAgYnl0ZXNbOF0gPSAweDgwIHwgKGJ5dGVzWzhdID4+PiAyKTtcclxuICAgICAgICByZXR1cm4gVVVJRC5vZklubmVyKGJ5dGVzKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBnbG9iYWwgZmxhZyB0byBmb3JjZSB1c2Ugb2YgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nIFJORy4gKi9cclxuLy8gZGVjbGFyZSBjb25zdCBVVUlEVjdfREVOWV9XRUFLX1JORzogYm9vbGVhbjtcclxuLyoqIFJldHVybnMgdGhlIGRlZmF1bHQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgYXZhaWxhYmxlIGluIHRoZSBlbnZpcm9ubWVudC4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdFJhbmRvbSA9ICgpID0+IHtcclxuICAgIC8vIGZpeDogY3J5cHRvIGlzbid0IGF2YWlsYWJsZSBpbiByZWFjdC1uYXRpdmUsIGFsd2F5cyB1c2UgTWF0aC5yYW5kb21cclxuICAgIC8vICAgLy8gZGV0ZWN0IFdlYiBDcnlwdG8gQVBJXHJcbiAgICAvLyAgIGlmIChcclxuICAgIC8vICAgICB0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmXHJcbiAgICAvLyAgICAgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgIT09IFwidW5kZWZpbmVkXCJcclxuICAgIC8vICAgKSB7XHJcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBCdWZmZXJlZENyeXB0b1JhbmRvbSgpO1xyXG4gICAgLy8gICB9IGVsc2Uge1xyXG4gICAgLy8gICAgIC8vIGZhbGwgYmFjayBvbiBNYXRoLnJhbmRvbSgpIHVubGVzcyB0aGUgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxyXG4gICAgLy8gICAgIGlmICh0eXBlb2YgVVVJRFY3X0RFTllfV0VBS19STkcgIT09IFwidW5kZWZpbmVkXCIgJiYgVVVJRFY3X0RFTllfV0VBS19STkcpIHtcclxuICAgIC8vICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZyBSTkcgYXZhaWxhYmxlXCIpO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICByZXR1cm4ge1xyXG4gICAgLy8gICAgICAgbmV4dFVpbnQzMjogKCk6IG51bWJlciA9PlxyXG4gICAgLy8gICAgICAgICBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiAweDFfMDAwMCkgKiAweDFfMDAwMCArXHJcbiAgICAvLyAgICAgICAgIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIDB4MV8wMDAwKSxcclxuICAgIC8vICAgICB9O1xyXG4gICAgLy8gICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHRVaW50MzI6ICgpID0+IE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIDY1NTM2KSAqIDY1NTM2ICtcclxuICAgICAgICAgICAgTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogNjU1MzYpLFxyXG4gICAgfTtcclxufTtcclxuLy8gLyoqXHJcbi8vICAqIFdyYXBzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKClgIHRvIGVuYWJsZSBidWZmZXJpbmc7IHRoaXMgdXNlcyBhIHNtYWxsXHJcbi8vICAqIGJ1ZmZlciBieSBkZWZhdWx0IHRvIGF2b2lkIGJvdGggdW5iZWFyYWJsZSB0aHJvdWdocHV0IGRlY2xpbmUgaW4gc29tZVxyXG4vLyAgKiBlbnZpcm9ubWVudHMgYW5kIHRoZSB3YXN0ZSBvZiB0aW1lIGFuZCBzcGFjZSBmb3IgdW51c2VkIHZhbHVlcy5cclxuLy8gICovXHJcbi8vIGNsYXNzIEJ1ZmZlcmVkQ3J5cHRvUmFuZG9tIHtcclxuLy8gICBwcml2YXRlIHJlYWRvbmx5IGJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheSg4KTtcclxuLy8gICBwcml2YXRlIGN1cnNvciA9IDB4ZmZmZjtcclxuLy8gICBuZXh0VWludDMyKCk6IG51bWJlciB7XHJcbi8vICAgICBpZiAodGhpcy5jdXJzb3IgPj0gdGhpcy5idWZmZXIubGVuZ3RoKSB7XHJcbi8vICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModGhpcy5idWZmZXIpO1xyXG4vLyAgICAgICB0aGlzLmN1cnNvciA9IDA7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5jdXJzb3IrK107XHJcbi8vICAgfVxyXG4vLyB9XHJcbmxldCBkZWZhdWx0R2VuZXJhdG9yO1xyXG4vKipcclxuICogR2VuZXJhdGVzIGEgVVVJRHY3IHN0cmluZy5cclxuICpcclxuICogQHJldHVybnMgVGhlIDgtNC00LTQtMTIgY2Fub25pY2FsIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvblxyXG4gKiAoXCJ4eHh4eHh4eC14eHh4LXh4eHgteHh4eC14eHh4eHh4eHh4eHhcIikuXHJcbiAqL1xyXG5jb25zdCB1dWlkdjcgPSAoKSA9PiB1dWlkdjdvYmooKS50b1N0cmluZygpO1xyXG4vKiogR2VuZXJhdGVzIGEgVVVJRHY3IG9iamVjdC4gKi9cclxuY29uc3QgdXVpZHY3b2JqID0gKCkgPT4gKGRlZmF1bHRHZW5lcmF0b3IgfHwgKGRlZmF1bHRHZW5lcmF0b3IgPSBuZXcgVjdHZW5lcmF0b3IoKSkpLmdlbmVyYXRlKCk7XG5cbi8vIFBvcnRpb25zIG9mIHRoaXMgZmlsZSBhcmUgZGVyaXZlZCBmcm9tIGdldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCBieSBTb2Z0d2FyZSwgSW5jLiBkYmEgU2VudHJ5XG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbmZ1bmN0aW9uIG1ha2VVbmNhdWdodEV4Y2VwdGlvbkhhbmRsZXIoY2FwdHVyZUZuLCBvbkZhdGFsRm4pIHtcbiAgbGV0IGNhbGxlZEZhdGFsRXJyb3IgPSBmYWxzZTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZXJyb3IgPT4ge1xuICAgIC8vIEF0dGFjaGluZyBhIGxpc3RlbmVyIHRvIGB1bmNhdWdodEV4Y2VwdGlvbmAgd2lsbCBwcmV2ZW50IHRoZSBub2RlIHByb2Nlc3MgZnJvbSBleGl0aW5nLiBXZSBnZW5lcmFsbHkgZG8gbm90XG4gICAgLy8gd2FudCB0byBhbHRlciB0aGlzIGJlaGF2aW91ciBzbyB3ZSBjaGVjayBmb3Igb3RoZXIgbGlzdGVuZXJzIHRoYXQgdXNlcnMgbWF5IGhhdmUgYXR0YWNoZWQgdGhlbXNlbHZlcyBhbmQgYWRqdXN0XG4gICAgLy8gZXhpdCBiZWhhdmlvdXIgb2YgdGhlIFNESyBhY2NvcmRpbmdseTpcbiAgICAvLyAtIElmIG90aGVyIGxpc3RlbmVycyBhcmUgYXR0YWNoZWQsIGRvIG5vdCBleGl0LlxuICAgIC8vIC0gSWYgdGhlIG9ubHkgbGlzdGVuZXIgYXR0YWNoZWQgaXMgb3VycywgZXhpdC5cbiAgICBjb25zdCB1c2VyUHJvdmlkZWRMaXN0ZW5lcnNDb3VudCA9IGdsb2JhbC5wcm9jZXNzLmxpc3RlbmVycygndW5jYXVnaHRFeGNlcHRpb24nKS5maWx0ZXIobGlzdGVuZXIgPT4ge1xuICAgICAgLy8gVGhlcmUgYXJlIDIgbGlzdGVuZXJzIHdlIGlnbm9yZTpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIGFzIHNvb24gYXMgd2UncmUgdXNpbmcgZG9tYWlucyB0aGlzIGxpc3RlbmVyIGlzIGF0dGFjaGVkIGJ5IG5vZGUgaXRzZWxmXG4gICAgICAgIGxpc3RlbmVyLm5hbWUgIT09ICdkb21haW5VbmNhdWdodEV4Y2VwdGlvbkNsZWFyJyAmJlxuICAgICAgICAvLyB0aGUgaGFuZGxlciB3ZSByZWdpc3RlciBpbiB0aGlzIGludGVncmF0aW9uXG4gICAgICAgIGxpc3RlbmVyLl9wb3N0aG9nRXJyb3JIYW5kbGVyICE9PSB0cnVlXG4gICAgICApO1xuICAgIH0pLmxlbmd0aDtcbiAgICBjb25zdCBwcm9jZXNzV291bGRFeGl0ID0gdXNlclByb3ZpZGVkTGlzdGVuZXJzQ291bnQgPT09IDA7XG4gICAgY2FwdHVyZUZuKGVycm9yLCB7XG4gICAgICBtZWNoYW5pc206IHtcbiAgICAgICAgdHlwZTogJ29udW5jYXVnaHRleGNlcHRpb24nLFxuICAgICAgICBoYW5kbGVkOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2FsbGVkRmF0YWxFcnJvciAmJiBwcm9jZXNzV291bGRFeGl0KSB7XG4gICAgICBjYWxsZWRGYXRhbEVycm9yID0gdHJ1ZTtcbiAgICAgIG9uRmF0YWxGbigpO1xuICAgIH1cbiAgfSwge1xuICAgIF9wb3N0aG9nRXJyb3JIYW5kbGVyOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkVW5jYXVnaHRFeGNlcHRpb25MaXN0ZW5lcihjYXB0dXJlRm4sIG9uRmF0YWxGbikge1xuICBnbG9iYWwucHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCBtYWtlVW5jYXVnaHRFeGNlcHRpb25IYW5kbGVyKGNhcHR1cmVGbiwgb25GYXRhbEZuKSk7XG59XG5mdW5jdGlvbiBhZGRVbmhhbmRsZWRSZWplY3Rpb25MaXN0ZW5lcihjYXB0dXJlRm4pIHtcbiAgZ2xvYmFsLnByb2Nlc3Mub24oJ3VuaGFuZGxlZFJlamVjdGlvbicsIHJlYXNvbiA9PiB7XG4gICAgY2FwdHVyZUZuKHJlYXNvbiwge1xuICAgICAgbWVjaGFuaXNtOiB7XG4gICAgICAgIHR5cGU6ICdvbnVuaGFuZGxlZHJlamVjdGlvbicsXG4gICAgICAgIGhhbmRsZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBQb3J0aW9ucyBvZiB0aGlzIGZpbGUgYXJlIGRlcml2ZWQgZnJvbSBnZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQgYnkgU29mdHdhcmUsIEluYy4gZGJhIFNlbnRyeVxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG5sZXQgcGFyc2VkU3RhY2tSZXN1bHRzO1xubGV0IGxhc3RLZXlzQ291bnQ7XG5sZXQgY2FjaGVkRmlsZW5hbWVDaHVua0lkcztcbmZ1bmN0aW9uIGdldEZpbGVuYW1lVG9DaHVua0lkTWFwKHN0YWNrUGFyc2VyKSB7XG4gIGNvbnN0IGNodW5rSWRNYXAgPSBnbG9iYWxUaGlzLl9wb3N0aG9nQ2h1bmtJZHM7XG4gIGlmICghY2h1bmtJZE1hcCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05vIGNodW5rIGlkIG1hcCBmb3VuZCcpO1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBjaHVua0lkS2V5cyA9IE9iamVjdC5rZXlzKGNodW5rSWRNYXApO1xuICBpZiAoY2FjaGVkRmlsZW5hbWVDaHVua0lkcyAmJiBjaHVua0lkS2V5cy5sZW5ndGggPT09IGxhc3RLZXlzQ291bnQpIHtcbiAgICByZXR1cm4gY2FjaGVkRmlsZW5hbWVDaHVua0lkcztcbiAgfVxuICBsYXN0S2V5c0NvdW50ID0gY2h1bmtJZEtleXMubGVuZ3RoO1xuICBjYWNoZWRGaWxlbmFtZUNodW5rSWRzID0gY2h1bmtJZEtleXMucmVkdWNlKChhY2MsIHN0YWNrS2V5KSA9PiB7XG4gICAgaWYgKCFwYXJzZWRTdGFja1Jlc3VsdHMpIHtcbiAgICAgIHBhcnNlZFN0YWNrUmVzdWx0cyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZWRTdGFja1Jlc3VsdHNbc3RhY2tLZXldO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGFjY1tyZXN1bHRbMF1dID0gcmVzdWx0WzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYXJzZWRTdGFjayA9IHN0YWNrUGFyc2VyKHN0YWNrS2V5KTtcbiAgICAgIGZvciAobGV0IGkgPSBwYXJzZWRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBzdGFja0ZyYW1lID0gcGFyc2VkU3RhY2tbaV07XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gc3RhY2tGcmFtZT8uZmlsZW5hbWU7XG4gICAgICAgIGNvbnN0IGNodW5rSWQgPSBjaHVua0lkTWFwW3N0YWNrS2V5XTtcbiAgICAgICAgaWYgKGZpbGVuYW1lICYmIGNodW5rSWQpIHtcbiAgICAgICAgICBhY2NbZmlsZW5hbWVdID0gY2h1bmtJZDtcbiAgICAgICAgICBwYXJzZWRTdGFja1Jlc3VsdHNbc3RhY2tLZXldID0gW2ZpbGVuYW1lLCBjaHVua0lkXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBjYWNoZWRGaWxlbmFtZUNodW5rSWRzO1xufVxuXG4vLyBQb3J0aW9ucyBvZiB0aGlzIGZpbGUgYXJlIGRlcml2ZWQgZnJvbSBnZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQgYnkgU29mdHdhcmUsIEluYy4gZGJhIFNlbnRyeVxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG5mdW5jdGlvbiBpc0V2ZW50KGNhbmRpZGF0ZSkge1xuICByZXR1cm4gdHlwZW9mIEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luc3RhbmNlT2YoY2FuZGlkYXRlLCBFdmVudCk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KGNhbmRpZGF0ZSkge1xuICByZXR1cm4gaXNCdWlsdGluKGNhbmRpZGF0ZSwgJ09iamVjdCcpO1xufVxuZnVuY3Rpb24gaXNFcnJvcihjYW5kaWRhdGUpIHtcbiAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY2FuZGlkYXRlKSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzpcbiAgICBjYXNlICdbb2JqZWN0IEV4Y2VwdGlvbl0nOlxuICAgIGNhc2UgJ1tvYmplY3QgRE9NRXhjZXB0aW9uXSc6XG4gICAgY2FzZSAnW29iamVjdCBXZWJBc3NlbWJseS5FeGNlcHRpb25dJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gaXNJbnN0YW5jZU9mKGNhbmRpZGF0ZSwgRXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBpc0luc3RhbmNlT2YoY2FuZGlkYXRlLCBiYXNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZSBpbnN0YW5jZW9mIGJhc2U7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNFcnJvckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBpc0J1aWx0aW4oZXZlbnQsICdFcnJvckV2ZW50Jyk7XG59XG5mdW5jdGlvbiBpc0J1aWx0aW4oY2FuZGlkYXRlLCBjbGFzc05hbWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjYW5kaWRhdGUpID09PSBgW29iamVjdCAke2NsYXNzTmFtZX1dYDtcbn1cblxuLy8gUG9ydGlvbnMgb2YgdGhpcyBmaWxlIGFyZSBkZXJpdmVkIGZyb20gZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0IGJ5IFNvZnR3YXJlLCBJbmMuIGRiYSBTZW50cnlcbmFzeW5jIGZ1bmN0aW9uIHByb3BlcnRpZXNGcm9tVW5rbm93bklucHV0KHN0YWNrUGFyc2VyLCBmcmFtZU1vZGlmaWVycywgaW5wdXQsIGhpbnQpIHtcbiAgY29uc3QgcHJvdmlkZWRNZWNoYW5pc20gPSBoaW50ICYmIGhpbnQubWVjaGFuaXNtO1xuICBjb25zdCBtZWNoYW5pc20gPSBwcm92aWRlZE1lY2hhbmlzbSB8fCB7XG4gICAgaGFuZGxlZDogdHJ1ZSxcbiAgICB0eXBlOiAnZ2VuZXJpYydcbiAgfTtcbiAgY29uc3QgZXJyb3JMaXN0ID0gZ2V0RXJyb3JMaXN0KG1lY2hhbmlzbSwgaW5wdXQsIGhpbnQpO1xuICBjb25zdCBleGNlcHRpb25MaXN0ID0gYXdhaXQgUHJvbWlzZS5hbGwoZXJyb3JMaXN0Lm1hcChhc3luYyBlcnJvciA9PiB7XG4gICAgY29uc3QgZXhjZXB0aW9uID0gYXdhaXQgZXhjZXB0aW9uRnJvbUVycm9yKHN0YWNrUGFyc2VyLCBmcmFtZU1vZGlmaWVycywgZXJyb3IpO1xuICAgIGV4Y2VwdGlvbi52YWx1ZSA9IGV4Y2VwdGlvbi52YWx1ZSB8fCAnJztcbiAgICBleGNlcHRpb24udHlwZSA9IGV4Y2VwdGlvbi50eXBlIHx8ICdFcnJvcic7XG4gICAgZXhjZXB0aW9uLm1lY2hhbmlzbSA9IG1lY2hhbmlzbTtcbiAgICByZXR1cm4gZXhjZXB0aW9uO1xuICB9KSk7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgJGV4Y2VwdGlvbl9saXN0OiBleGNlcHRpb25MaXN0XG4gIH07XG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuLy8gRmxhdHRlbiBlcnJvciBjYXVzZXMgaW50byBhIGxpc3Qgb2YgZXJyb3JzXG4vLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yL2NhdXNlXG5mdW5jdGlvbiBnZXRFcnJvckxpc3QobWVjaGFuaXNtLCBpbnB1dCwgaGludCkge1xuICBjb25zdCBlcnJvciA9IGdldEVycm9yKG1lY2hhbmlzbSwgaW5wdXQsIGhpbnQpO1xuICBpZiAoZXJyb3IuY2F1c2UpIHtcbiAgICByZXR1cm4gW2Vycm9yLCAuLi5nZXRFcnJvckxpc3QobWVjaGFuaXNtLCBlcnJvci5jYXVzZSwgaGludCldO1xuICB9XG4gIHJldHVybiBbZXJyb3JdO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3IobWVjaGFuaXNtLCBleGNlcHRpb24sIGhpbnQpIHtcbiAgaWYgKGlzRXJyb3IoZXhjZXB0aW9uKSkge1xuICAgIHJldHVybiBleGNlcHRpb247XG4gIH1cbiAgbWVjaGFuaXNtLnN5bnRoZXRpYyA9IHRydWU7XG4gIGlmIChpc1BsYWluT2JqZWN0KGV4Y2VwdGlvbikpIHtcbiAgICBjb25zdCBlcnJvckZyb21Qcm9wID0gZ2V0RXJyb3JQcm9wZXJ0eUZyb21PYmplY3QoZXhjZXB0aW9uKTtcbiAgICBpZiAoZXJyb3JGcm9tUHJvcCkge1xuICAgICAgcmV0dXJuIGVycm9yRnJvbVByb3A7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRNZXNzYWdlRm9yT2JqZWN0KGV4Y2VwdGlvbik7XG4gICAgY29uc3QgZXggPSBoaW50Py5zeW50aGV0aWNFeGNlcHRpb24gfHwgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGV4Lm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHJldHVybiBleDtcbiAgfVxuICAvLyBUaGlzIGhhbmRsZXMgd2hlbiBzb21lb25lIGRvZXM6IGB0aHJvdyBcInNvbWV0aGluZyBhd2Vzb21lXCI7YFxuICAvLyBXZSB1c2Ugc3ludGhlc2l6ZWQgRXJyb3IgaGVyZSBzbyB3ZSBjYW4gZXh0cmFjdCBhIChyb3VnaCkgc3RhY2sgdHJhY2UuXG4gIGNvbnN0IGV4ID0gaGludD8uc3ludGhldGljRXhjZXB0aW9uIHx8IG5ldyBFcnJvcihleGNlcHRpb24pO1xuICBleC5tZXNzYWdlID0gYCR7ZXhjZXB0aW9ufWA7XG4gIHJldHVybiBleDtcbn1cbi8qKiBJZiBhIHBsYWluIG9iamVjdCBoYXMgYSBwcm9wZXJ0eSB0aGF0IGlzIGFuIGBFcnJvcmAsIHJldHVybiB0aGlzIGVycm9yLiAqL1xuZnVuY3Rpb24gZ2V0RXJyb3JQcm9wZXJ0eUZyb21PYmplY3Qob2JqKSB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW3Byb3BdO1xuICAgICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VGb3JPYmplY3QoZXhjZXB0aW9uKSB7XG4gIGlmICgnbmFtZScgaW4gZXhjZXB0aW9uICYmIHR5cGVvZiBleGNlcHRpb24ubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGAnJHtleGNlcHRpb24ubmFtZX0nIGNhcHR1cmVkIGFzIGV4Y2VwdGlvbmA7XG4gICAgaWYgKCdtZXNzYWdlJyBpbiBleGNlcHRpb24gJiYgdHlwZW9mIGV4Y2VwdGlvbi5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgbWVzc2FnZSArPSBgIHdpdGggbWVzc2FnZSAnJHtleGNlcHRpb24ubWVzc2FnZX0nYDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0gZWxzZSBpZiAoJ21lc3NhZ2UnIGluIGV4Y2VwdGlvbiAmJiB0eXBlb2YgZXhjZXB0aW9uLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4Y2VwdGlvbi5tZXNzYWdlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBleHRyYWN0RXhjZXB0aW9uS2V5c0Zvck1lc3NhZ2UoZXhjZXB0aW9uKTtcbiAgLy8gU29tZSBFcnJvckV2ZW50IGluc3RhbmNlcyBkbyBub3QgaGF2ZSBhbiBgZXJyb3JgIHByb3BlcnR5LCB3aGljaCBpcyB3aHkgdGhleSBhcmUgbm90IGhhbmRsZWQgYmVmb3JlXG4gIC8vIFdlIHN0aWxsIHdhbnQgdG8gdHJ5IHRvIGdldCBhIGRlY2VudCBtZXNzYWdlIGZvciB0aGVzZSBjYXNlc1xuICBpZiAoaXNFcnJvckV2ZW50KGV4Y2VwdGlvbikpIHtcbiAgICByZXR1cm4gYEV2ZW50IFxcYEVycm9yRXZlbnRcXGAgY2FwdHVyZWQgYXMgZXhjZXB0aW9uIHdpdGggbWVzc2FnZSBcXGAke2V4Y2VwdGlvbi5tZXNzYWdlfVxcYGA7XG4gIH1cbiAgY29uc3QgY2xhc3NOYW1lID0gZ2V0T2JqZWN0Q2xhc3NOYW1lKGV4Y2VwdGlvbik7XG4gIHJldHVybiBgJHtjbGFzc05hbWUgJiYgY2xhc3NOYW1lICE9PSAnT2JqZWN0JyA/IGAnJHtjbGFzc05hbWV9J2AgOiAnT2JqZWN0J30gY2FwdHVyZWQgYXMgZXhjZXB0aW9uIHdpdGgga2V5czogJHtrZXlzfWA7XG59XG5mdW5jdGlvbiBnZXRPYmplY3RDbGFzc05hbWUob2JqKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgcmV0dXJuIHByb3RvdHlwZSA/IHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lIDogdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaWdub3JlIGVycm9ycyBoZXJlXG4gIH1cbn1cbi8qKlxyXG4gKiBHaXZlbiBhbnkgY2FwdHVyZWQgZXhjZXB0aW9uLCBleHRyYWN0IGl0cyBrZXlzIGFuZCBjcmVhdGUgYSBzb3J0ZWRcclxuICogYW5kIHRydW5jYXRlZCBsaXN0IHRoYXQgd2lsbCBiZSB1c2VkIGluc2lkZSB0aGUgZXZlbnQgbWVzc2FnZS5cclxuICogZWcuIGBOb24tZXJyb3IgZXhjZXB0aW9uIGNhcHR1cmVkIHdpdGgga2V5czogZm9vLCBiYXIsIGJhemBcclxuICovXG5mdW5jdGlvbiBleHRyYWN0RXhjZXB0aW9uS2V5c0Zvck1lc3NhZ2UoZXhjZXB0aW9uLCBtYXhMZW5ndGggPSA0MCkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY29udmVydFRvUGxhaW5PYmplY3QoZXhjZXB0aW9uKSk7XG4gIGtleXMuc29ydCgpO1xuICBjb25zdCBmaXJzdEtleSA9IGtleXNbMF07XG4gIGlmICghZmlyc3RLZXkpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgaGFzIG5vIGtleXNdJztcbiAgfVxuICBpZiAoZmlyc3RLZXkubGVuZ3RoID49IG1heExlbmd0aCkge1xuICAgIHJldHVybiB0cnVuY2F0ZShmaXJzdEtleSwgbWF4TGVuZ3RoKTtcbiAgfVxuICBmb3IgKGxldCBpbmNsdWRlZEtleXMgPSBrZXlzLmxlbmd0aDsgaW5jbHVkZWRLZXlzID4gMDsgaW5jbHVkZWRLZXlzLS0pIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0ga2V5cy5zbGljZSgwLCBpbmNsdWRlZEtleXMpLmpvaW4oJywgJyk7XG4gICAgaWYgKHNlcmlhbGl6ZWQubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGluY2x1ZGVkS2V5cyA9PT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1bmNhdGUoc2VyaWFsaXplZCwgbWF4TGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiB0cnVuY2F0ZShzdHIsIG1heCA9IDApIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8IG1heCA9PT0gMCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0ci5sZW5ndGggPD0gbWF4ID8gc3RyIDogYCR7c3RyLnNsaWNlKDAsIG1heCl9Li4uYDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIGFueSBgRXJyb3JgIG9yIGBFdmVudGAgaW50byBhIHBsYWluIG9iamVjdCB3aXRoIGFsbCBvZiB0aGVpciBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIGFuZCBzb21lIG9mIHRoZWlyXHJcbiAqIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgYXR0YWNoZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSBJbml0aWFsIHNvdXJjZSB0aGF0IHdlIGhhdmUgdG8gdHJhbnNmb3JtIGluIG9yZGVyIGZvciBpdCB0byBiZSB1c2FibGUgYnkgdGhlIHNlcmlhbGl6ZXJcclxuICogQHJldHVybnMgQW4gRXZlbnQgb3IgRXJyb3IgdHVybmVkIGludG8gYW4gb2JqZWN0IC0gb3IgdGhlIHZhbHVlIGFyZ3VtZW50IGl0c2VsZiwgd2hlbiB2YWx1ZSBpcyBuZWl0aGVyIGFuIEV2ZW50IG5vclxyXG4gKiAgYW4gRXJyb3IuXHJcbiAqL1xuZnVuY3Rpb24gY29udmVydFRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB2YWx1ZS5uYW1lLFxuICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrLFxuICAgICAgLi4uZ2V0T3duUHJvcGVydGllcyh2YWx1ZSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzRXZlbnQodmFsdWUpKSB7XG4gICAgY29uc3QgbmV3T2JqID0ge1xuICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgIHRhcmdldDogc2VyaWFsaXplRXZlbnRUYXJnZXQodmFsdWUudGFyZ2V0KSxcbiAgICAgIGN1cnJlbnRUYXJnZXQ6IHNlcmlhbGl6ZUV2ZW50VGFyZ2V0KHZhbHVlLmN1cnJlbnRUYXJnZXQpLFxuICAgICAgLi4uZ2V0T3duUHJvcGVydGllcyh2YWx1ZSlcbiAgICB9O1xuICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgd2h5IHRoaXMgZmFpbHMgdHlwaW5nIChJIHRoaW5rIEN1c3RvbUV2ZW50IGlzIG9ubHkgc3VwcG9ydGVkIGluIE5vZGUgMTkgb253YXJkcylcbiAgICAvLyBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luc3RhbmNlT2YodmFsdWUsIEN1c3RvbUV2ZW50KSkge1xuICAgIC8vICAgbmV3T2JqLmRldGFpbCA9ICh2YWx1ZSBhcyB1bmtub3duIGFzIEN1c3RvbUV2ZW50KS5kZXRhaWxcbiAgICAvLyB9XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbi8qKiBGaWx0ZXJzIG91dCBhbGwgYnV0IGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzICovXG5mdW5jdGlvbiBnZXRPd25Qcm9wZXJ0aWVzKG9iaikge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgY29uc3QgZXh0cmFjdGVkUHJvcHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BlcnR5KSkge1xuICAgICAgICBleHRyYWN0ZWRQcm9wc1twcm9wZXJ0eV0gPSBvYmpbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXh0cmFjdGVkUHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG4vKiogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGFyZ2V0IG9mIGFuIGBFdmVudGAgb2JqZWN0ICovXG5mdW5jdGlvbiBzZXJpYWxpemVFdmVudFRhcmdldCh0YXJnZXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldCk7XG4gIH0gY2F0Y2ggKF9vTykge1xuICAgIHJldHVybiAnPHVua25vd24+JztcbiAgfVxufVxuLyoqXHJcbiAqIEV4dHJhY3RzIHN0YWNrIGZyYW1lcyBmcm9tIHRoZSBlcnJvciBhbmQgYnVpbGRzIGFuIEV4Y2VwdGlvblxyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4Y2VwdGlvbkZyb21FcnJvcihzdGFja1BhcnNlciwgZnJhbWVNb2RpZmllcnMsIGVycm9yKSB7XG4gIGNvbnN0IGV4Y2VwdGlvbiA9IHtcbiAgICB0eXBlOiBlcnJvci5uYW1lIHx8IGVycm9yLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgdmFsdWU6IGVycm9yLm1lc3NhZ2VcbiAgfTtcbiAgbGV0IGZyYW1lcyA9IHBhcnNlU3RhY2tGcmFtZXMoc3RhY2tQYXJzZXIsIGVycm9yKTtcbiAgZm9yIChjb25zdCBtb2RpZmllciBvZiBmcmFtZU1vZGlmaWVycykge1xuICAgIGZyYW1lcyA9IGF3YWl0IG1vZGlmaWVyKGZyYW1lcyk7XG4gIH1cbiAgaWYgKGZyYW1lcy5sZW5ndGgpIHtcbiAgICBleGNlcHRpb24uc3RhY2t0cmFjZSA9IHtcbiAgICAgIGZyYW1lcyxcbiAgICAgIHR5cGU6ICdyYXcnXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZXhjZXB0aW9uO1xufVxuLyoqXHJcbiAqIEV4dHJhY3RzIHN0YWNrIGZyYW1lcyBmcm9tIHRoZSBlcnJvci5zdGFjayBzdHJpbmdcclxuICovXG5mdW5jdGlvbiBwYXJzZVN0YWNrRnJhbWVzKHN0YWNrUGFyc2VyLCBlcnJvcikge1xuICByZXR1cm4gYXBwbHlDaHVua0lkcyhzdGFja1BhcnNlcihlcnJvci5zdGFjayB8fCAnJywgMSksIHN0YWNrUGFyc2VyKTtcbn1cbmZ1bmN0aW9uIGFwcGx5Q2h1bmtJZHMoZnJhbWVzLCBwYXJzZXIpIHtcbiAgY29uc3QgZmlsZW5hbWVDaHVua0lkTWFwID0gZ2V0RmlsZW5hbWVUb0NodW5rSWRNYXAocGFyc2VyKTtcbiAgZnJhbWVzLmZvckVhY2goZnJhbWUgPT4ge1xuICAgIGlmIChmcmFtZS5maWxlbmFtZSkge1xuICAgICAgZnJhbWUuY2h1bmtfaWQgPSBmaWxlbmFtZUNodW5rSWRNYXBbZnJhbWUuZmlsZW5hbWVdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmcmFtZXM7XG59XG5cbmNvbnN0IFNIVVRET1dOX1RJTUVPVVQgPSAyMDAwO1xuY2xhc3MgRXJyb3JUcmFja2luZyB7XG4gIHN0YXRpYyBhc3luYyBidWlsZEV2ZW50TWVzc2FnZShlcnJvciwgaGludCwgZGlzdGluY3RJZCwgYWRkaXRpb25hbFByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgLi4uYWRkaXRpb25hbFByb3BlcnRpZXNcbiAgICB9O1xuICAgIC8vIEdpdmVuIHN0YXRlbGVzcyBuYXR1cmUgb2YgTm9kZSBTREsgd2UgY2FwdHVyZSBleGNlcHRpb25zIHVzaW5nIHBlcnNvbmxlc3MgcHJvY2Vzc2luZyB3aGVuIG5vXG4gICAgLy8gdXNlciBjYW4gYmUgZGV0ZXJtaW5lZCBiZWNhdXNlIGEgZGlzdGluY3RfaWQgaXMgbm90IHByb3ZpZGVkIGUuZy4gZXhjZXB0aW9uIGF1dG9jYXB0dXJlXG4gICAgaWYgKCFkaXN0aW5jdElkKSB7XG4gICAgICBwcm9wZXJ0aWVzLiRwcm9jZXNzX3BlcnNvbl9wcm9maWxlID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGV4Y2VwdGlvblByb3BlcnRpZXMgPSBhd2FpdCBwcm9wZXJ0aWVzRnJvbVVua25vd25JbnB1dCh0aGlzLnN0YWNrUGFyc2VyLCB0aGlzLmZyYW1lTW9kaWZpZXJzLCBlcnJvciwgaGludCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV2ZW50OiAnJGV4Y2VwdGlvbicsXG4gICAgICBkaXN0aW5jdElkOiBkaXN0aW5jdElkIHx8IHV1aWR2NygpLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAuLi5leGNlcHRpb25Qcm9wZXJ0aWVzLFxuICAgICAgICAuLi5wcm9wZXJ0aWVzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBjb25zdHJ1Y3RvcihjbGllbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLl9leGNlcHRpb25BdXRvY2FwdHVyZUVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZUV4Y2VwdGlvbkF1dG9jYXB0dXJlIHx8IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRBdXRvY2FwdHVyZUlmRW5hYmxlZCgpO1xuICB9XG4gIHN0YXJ0QXV0b2NhcHR1cmVJZkVuYWJsZWQoKSB7XG4gICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHtcbiAgICAgIGFkZFVuY2F1Z2h0RXhjZXB0aW9uTGlzdGVuZXIodGhpcy5vbkV4Y2VwdGlvbi5iaW5kKHRoaXMpLCB0aGlzLm9uRmF0YWxFcnJvci5iaW5kKHRoaXMpKTtcbiAgICAgIGFkZFVuaGFuZGxlZFJlamVjdGlvbkxpc3RlbmVyKHRoaXMub25FeGNlcHRpb24uYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG4gIG9uRXhjZXB0aW9uKGV4Y2VwdGlvbiwgaGludCkge1xuICAgIHZvaWQgRXJyb3JUcmFja2luZy5idWlsZEV2ZW50TWVzc2FnZShleGNlcHRpb24sIGhpbnQpLnRoZW4obXNnID0+IHtcbiAgICAgIHRoaXMuY2xpZW50LmNhcHR1cmUobXNnKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBvbkZhdGFsRXJyb3IoKSB7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQuc2h1dGRvd24oU0hVVERPV05fVElNRU9VVCk7XG4gIH1cbiAgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiAhdGhpcy5jbGllbnQuaXNEaXNhYmxlZCAmJiB0aGlzLl9leGNlcHRpb25BdXRvY2FwdHVyZUVuYWJsZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBFeHByZXNzRXJyb3JIYW5kbGVyKF9wb3N0aG9nLCBhcHApIHtcbiAgYXBwLnVzZSgoZXJyb3IsIF8sIF9fLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgaGludCA9IHtcbiAgICAgIG1lY2hhbmlzbToge1xuICAgICAgICB0eXBlOiAnbWlkZGxld2FyZScsXG4gICAgICAgIGhhbmRsZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfTtcbiAgICAvLyBHaXZlbiBzdGF0ZWxlc3MgbmF0dXJlIG9mIE5vZGUgU0RLIHdlIGNhcHR1cmUgZXhjZXB0aW9ucyB1c2luZyBwZXJzb25sZXNzIHByb2Nlc3NpbmdcbiAgICAvLyB3aGVuIG5vIHVzZXIgY2FuIGJlIGRldGVybWluZWQgZS5nLiBpbiB0aGUgY2FzZSBvZiBleGNlcHRpb24gYXV0b2NhcHR1cmVcbiAgICBFcnJvclRyYWNraW5nLmJ1aWxkRXZlbnRNZXNzYWdlKGVycm9yLCBoaW50LCB1dWlkdjcoKSwge1xuICAgICAgJHByb2Nlc3NfcGVyc29uX3Byb2ZpbGU6IGZhbHNlXG4gICAgfSkudGhlbihtc2cgPT4gX3Bvc3Rob2cuY2FwdHVyZShtc2cpKTtcbiAgICBuZXh0KGVycm9yKTtcbiAgfSk7XG59XG5cbi8vIFBvcnRpb25zIG9mIHRoaXMgZmlsZSBhcmUgZGVyaXZlZCBmcm9tIGdldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCBieSBTb2Z0d2FyZSwgSW5jLiBkYmEgU2VudHJ5XG4vKiogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgbW9kdWxlIG5hbWUgZnJvbSBhIGZpbGVuYW1lICovXG5mdW5jdGlvbiBjcmVhdGVHZXRNb2R1bGVGcm9tRmlsZW5hbWUoYmFzZVBhdGggPSBwcm9jZXNzLmFyZ3ZbMV0gPyBkaXJuYW1lKHByb2Nlc3MuYXJndlsxXSkgOiBwcm9jZXNzLmN3ZCgpLCBpc1dpbmRvd3MgPSBzZXAgPT09ICdcXFxcJykge1xuICBjb25zdCBub3JtYWxpemVkQmFzZSA9IGlzV2luZG93cyA/IG5vcm1hbGl6ZVdpbmRvd3NQYXRoKGJhc2VQYXRoKSA6IGJhc2VQYXRoO1xuICByZXR1cm4gZmlsZW5hbWUgPT4ge1xuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZEZpbGVuYW1lID0gaXNXaW5kb3dzID8gbm9ybWFsaXplV2luZG93c1BhdGgoZmlsZW5hbWUpIDogZmlsZW5hbWU7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCB7XG4gICAgICBkaXIsXG4gICAgICBiYXNlOiBmaWxlLFxuICAgICAgZXh0XG4gICAgfSA9IHBvc2l4LnBhcnNlKG5vcm1hbGl6ZWRGaWxlbmFtZSk7XG4gICAgaWYgKGV4dCA9PT0gJy5qcycgfHwgZXh0ID09PSAnLm1qcycgfHwgZXh0ID09PSAnLmNqcycpIHtcbiAgICAgIGZpbGUgPSBmaWxlLnNsaWNlKDAsIGV4dC5sZW5ndGggKiAtMSk7XG4gICAgfVxuICAgIC8vIFRoZSBmaWxlIG5hbWUgbWlnaHQgYmUgVVJJLWVuY29kZWQgd2hpY2ggd2Ugd2FudCB0byBkZWNvZGUgdG9cbiAgICAvLyB0aGUgb3JpZ2luYWwgZmlsZSBuYW1lLlxuICAgIGNvbnN0IGRlY29kZWRGaWxlID0gZGVjb2RlVVJJQ29tcG9uZW50KGZpbGUpO1xuICAgIGlmICghZGlyKSB7XG4gICAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICAgIGRpciA9ICcuJztcbiAgICB9XG4gICAgY29uc3QgbiA9IGRpci5sYXN0SW5kZXhPZignL25vZGVfbW9kdWxlcycpO1xuICAgIGlmIChuID4gLTEpIHtcbiAgICAgIHJldHVybiBgJHtkaXIuc2xpY2UobiArIDE0KS5yZXBsYWNlKC9cXC8vZywgJy4nKX06JHtkZWNvZGVkRmlsZX1gO1xuICAgIH1cbiAgICAvLyBMZXQncyBzZWUgaWYgaXQncyBhIHBhcnQgb2YgdGhlIG1haW4gbW9kdWxlXG4gICAgLy8gVG8gYmUgYSBwYXJ0IG9mIG1haW4gbW9kdWxlLCBpdCBoYXMgdG8gc2hhcmUgdGhlIHNhbWUgYmFzZVxuICAgIGlmIChkaXIuc3RhcnRzV2l0aChub3JtYWxpemVkQmFzZSkpIHtcbiAgICAgIGNvbnN0IG1vZHVsZU5hbWUgPSBkaXIuc2xpY2Uobm9ybWFsaXplZEJhc2UubGVuZ3RoICsgMSkucmVwbGFjZSgvXFwvL2csICcuJyk7XG4gICAgICByZXR1cm4gbW9kdWxlTmFtZSA/IGAke21vZHVsZU5hbWV9OiR7ZGVjb2RlZEZpbGV9YCA6IGRlY29kZWRGaWxlO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZEZpbGU7XG4gIH07XG59XG4vKiogbm9ybWFsaXplcyBXaW5kb3dzIHBhdGhzICovXG5mdW5jdGlvbiBub3JtYWxpemVXaW5kb3dzUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL15bQS1aXTovLCAnJykgLy8gcmVtb3ZlIFdpbmRvd3Mtc3R5bGUgcHJlZml4XG4gIC5yZXBsYWNlKC9cXFxcL2csICcvJyk7IC8vIHJlcGxhY2UgYWxsIGBcXGAgaW5zdGFuY2VzIHdpdGggYC9gXG59XG5cbi8vIFBvcnRpb25zIG9mIHRoaXMgZmlsZSBhcmUgZGVyaXZlZCBmcm9tIGdldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCBieSBTb2Z0d2FyZSwgSW5jLiBkYmEgU2VudHJ5XG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2Vcbi8qKiBBIHNpbXBsZSBMZWFzdCBSZWNlbnRseSBVc2VkIG1hcCAqL1xuY2xhc3MgUmVkdWNlYWJsZUNhY2hlIHtcbiAgY29uc3RydWN0b3IoX21heFNpemUpIHtcbiAgICB0aGlzLl9tYXhTaXplID0gX21heFNpemU7XG4gICAgdGhpcy5fY2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cbiAgLyoqIEdldCBhbiBlbnRyeSBvciB1bmRlZmluZWQgaWYgaXQgd2FzIG5vdCBpbiB0aGUgY2FjaGUuIFJlLWluc2VydHMgdG8gdXBkYXRlIHRoZSByZWNlbnRseSB1c2VkIG9yZGVyICovXG4gIGdldChrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgYW5kIHJlLWluc2VydCB0byB1cGRhdGUgdGhlIG9yZGVyXG4gICAgdGhpcy5fY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5fY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKiogSW5zZXJ0IGFuIGVudHJ5IGFuZCBldmljdCBhbiBvbGRlciBlbnRyeSBpZiB3ZSd2ZSByZWFjaGVkIG1heFNpemUgKi9cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgLyoqIFJlbW92ZSBhbiBlbnRyeSBhbmQgcmV0dXJuIHRoZSBlbnRyeSBpZiBpdCB3YXMgaW4gdGhlIGNhY2hlICovXG4gIHJlZHVjZSgpIHtcbiAgICB3aGlsZSAodGhpcy5fY2FjaGUuc2l6ZSA+PSB0aGlzLl9tYXhTaXplKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2NhY2hlLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgLy8ga2V5cygpIHJldHVybnMgYW4gaXRlcmF0b3IgaW4gaW5zZXJ0aW9uIG9yZGVyIHNvIGtleXMoKS5uZXh0KCkgZ2l2ZXMgdXMgdGhlIG9sZGVzdCBrZXlcbiAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gUG9ydGlvbnMgb2YgdGhpcyBmaWxlIGFyZSBkZXJpdmVkIGZyb20gZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0IGJ5IFNvZnR3YXJlLCBJbmMuIGRiYSBTZW50cnlcbmNvbnN0IExSVV9GSUxFX0NPTlRFTlRTX0NBQ0hFID0gbmV3IFJlZHVjZWFibGVDYWNoZSgyNSk7XG5jb25zdCBMUlVfRklMRV9DT05URU5UU19GU19SRUFEX0ZBSUxFRCA9IG5ldyBSZWR1Y2VhYmxlQ2FjaGUoMjApO1xuY29uc3QgREVGQVVMVF9MSU5FU19PRl9DT05URVhUID0gNztcbi8vIERldGVybWluZXMgdGhlIHVwcGVyIGJvdW5kIG9mIGxpbmVuby9jb2xubyB0aGF0IHdlIHdpbGwgYXR0ZW1wdCB0byByZWFkLiBMYXJnZSBjb2xubyB2YWx1ZXMgYXJlIGxpa2VseSB0byBiZVxuLy8gbWluaWZpZWQgY29kZSB3aGlsZSBsYXJnZSBsaW5lbm8gdmFsdWVzIGFyZSBsaWtlbHkgdG8gYmUgYnVuZGxlZCBjb2RlLlxuLy8gRXhwb3J0ZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG5jb25zdCBNQVhfQ09OVEVYVExJTkVTX0NPTE5PID0gMTAwMDtcbmNvbnN0IE1BWF9DT05URVhUTElORVNfTElORU5PID0gMTAwMDA7XG5hc3luYyBmdW5jdGlvbiBhZGRTb3VyY2VDb250ZXh0KGZyYW1lcykge1xuICAvLyBrZWVwIGEgbG9va3VwIG1hcCBvZiB3aGljaCBmaWxlcyB3ZSd2ZSBhbHJlYWR5IGVucXVldWVkIHRvIHJlYWQsXG4gIC8vIHNvIHdlIGRvbid0IGVucXVldWUgdGhlIHNhbWUgZmlsZSBtdWx0aXBsZSB0aW1lcyB3aGljaCB3b3VsZCBjYXVzZSBtdWx0aXBsZSBpL28gcmVhZHNcbiAgY29uc3QgZmlsZXNUb0xpbmVzID0ge307XG4gIC8vIE1hcHMgcHJlc2VydmUgaW5zZXJ0aW9uIG9yZGVyLCBzbyB3ZSBpdGVyYXRlIGluIHJldmVyc2UsIHN0YXJ0aW5nIGF0IHRoZVxuICAvLyBvdXRlcm1vc3QgZnJhbWUgYW5kIGNsb3NlciB0byB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCAocG9vciBtYW5zIHByaW9yaXR5KVxuICBmb3IgKGxldCBpID0gZnJhbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgY29uc3QgZmlsZW5hbWUgPSBmcmFtZT8uZmlsZW5hbWU7XG4gICAgaWYgKCFmcmFtZSB8fCB0eXBlb2YgZmlsZW5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBmcmFtZS5saW5lbm8gIT09ICdudW1iZXInIHx8IHNob3VsZFNraXBDb250ZXh0TGluZXNGb3JGaWxlKGZpbGVuYW1lKSB8fCBzaG91bGRTa2lwQ29udGV4dExpbmVzRm9yRnJhbWUoZnJhbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZmlsZXNUb0xpbmVzT3V0cHV0ID0gZmlsZXNUb0xpbmVzW2ZpbGVuYW1lXTtcbiAgICBpZiAoIWZpbGVzVG9MaW5lc091dHB1dCkge1xuICAgICAgZmlsZXNUb0xpbmVzW2ZpbGVuYW1lXSA9IFtdO1xuICAgIH1cbiAgICBmaWxlc1RvTGluZXNbZmlsZW5hbWVdLnB1c2goZnJhbWUubGluZW5vKTtcbiAgfVxuICBjb25zdCBmaWxlcyA9IE9iamVjdC5rZXlzKGZpbGVzVG9MaW5lcyk7XG4gIGlmIChmaWxlcy5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiBmcmFtZXM7XG4gIH1cbiAgY29uc3QgcmVhZGxpbmVQcm9taXNlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAvLyBJZiB3ZSBmYWlsZWQgdG8gcmVhZCB0aGlzIGJlZm9yZSwgZG9udCB0cnkgcmVhZGluZyBpdCBhZ2Fpbi5cbiAgICBpZiAoTFJVX0ZJTEVfQ09OVEVOVFNfRlNfUkVBRF9GQUlMRUQuZ2V0KGZpbGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZmlsZXNUb0xpbmVSYW5nZXMgPSBmaWxlc1RvTGluZXNbZmlsZV07XG4gICAgaWYgKCFmaWxlc1RvTGluZVJhbmdlcykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIFNvcnQgcmFuZ2VzIHNvIHRoYXQgdGhleSBhcmUgc29ydGVkIGJ5IGxpbmUgaW5jcmVhc2luZyBvcmRlciBhbmQgbWF0Y2ggaG93IHRoZSBmaWxlIGlzIHJlYWQuXG4gICAgZmlsZXNUb0xpbmVSYW5nZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZW50cyBhcmUgYWxyZWFkeSBpbiB0aGUgY2FjaGUgYW5kIGlmIHdlIGNhbiBhdm9pZCByZWFkaW5nIHRoZSBmaWxlIGFnYWluLlxuICAgIGNvbnN0IHJhbmdlcyA9IG1ha2VMaW5lUmVhZGVyUmFuZ2VzKGZpbGVzVG9MaW5lUmFuZ2VzKTtcbiAgICBpZiAocmFuZ2VzLmV2ZXJ5KHIgPT4gcmFuZ2VFeGlzdHNJbkNvbnRlbnRDYWNoZShmaWxlLCByKSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZSA9IGVtcGxhY2UoTFJVX0ZJTEVfQ09OVEVOVFNfQ0FDSEUsIGZpbGUsIHt9KTtcbiAgICByZWFkbGluZVByb21pc2VzLnB1c2goZ2V0Q29udGV4dExpbmVzRnJvbUZpbGUoZmlsZSwgcmFuZ2VzLCBjYWNoZSkpO1xuICB9XG4gIC8vIFRoZSBwcm9taXNlIHJlamVjdGlvbnMgYXJlIGNhdWdodCBpbiBvcmRlciB0byBwcmV2ZW50IHRoZW0gZnJvbSBzaG9ydCBjaXJjdWl0aW5nIFByb21pc2UuYWxsXG4gIGF3YWl0IFByb21pc2UuYWxsKHJlYWRsaW5lUHJvbWlzZXMpLmNhdGNoKCgpID0+IHt9KTtcbiAgLy8gUGVyZm9ybSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlLCBidXQgdGhpcyB0aW1lIHdlIGNhbiBhc3N1bWUgYWxsIGZpbGVzIGFyZSBpbiB0aGUgY2FjaGVcbiAgLy8gYW5kIGF0dGVtcHQgdG8gYWRkIHNvdXJjZSBjb250ZXh0IHRvIGZyYW1lcy5cbiAgaWYgKGZyYW1lcyAmJiBmcmFtZXMubGVuZ3RoID4gMCkge1xuICAgIGFkZFNvdXJjZUNvbnRleHRUb0ZyYW1lcyhmcmFtZXMsIExSVV9GSUxFX0NPTlRFTlRTX0NBQ0hFKTtcbiAgfVxuICAvLyBPbmNlIHdlJ3JlIGZpbmlzaGVkIHByb2Nlc3NpbmcgYW4gZXhjZXB0aW9uIHJlZHVjZSB0aGUgZmlsZXMgaGVsZCBpbiB0aGUgY2FjaGVcbiAgLy8gc28gdGhhdCB3ZSBkb24ndCBpbmRlZmluZXRseSBpbmNyZWFzZSB0aGUgc2l6ZSBvZiB0aGlzIG1hcFxuICBMUlVfRklMRV9DT05URU5UU19DQUNIRS5yZWR1Y2UoKTtcbiAgcmV0dXJuIGZyYW1lcztcbn1cbi8qKlxyXG4gKiBFeHRyYWN0cyBsaW5lcyBmcm9tIGEgZmlsZSBhbmQgc3RvcmVzIHRoZW0gaW4gYSBjYWNoZS5cclxuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0TGluZXNGcm9tRmlsZShwYXRoLCByYW5nZXMsIG91dHB1dCkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgLy8gSXQgaXMgaW1wb3J0YW50ICpub3QqIHRvIGhhdmUgYW55IGFzeW5jIGNvZGUgYmV0d2VlbiBjcmVhdGVJbnRlcmZhY2UgYW5kIHRoZSAnbGluZScgZXZlbnQgbGlzdGVuZXJcbiAgICAvLyBhcyBpdCB3aWxsIGNhdXNlIHRoZSAnbGluZScgZXZlbnQgdG9cbiAgICAvLyBiZSBlbWl0dGVkIGJlZm9yZSB0aGUgbGlzdGVuZXIgaXMgYXR0YWNoZWQuXG4gICAgY29uc3Qgc3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbShwYXRoKTtcbiAgICBjb25zdCBsaW5lUmVhZGVkID0gY3JlYXRlSW50ZXJmYWNlKHtcbiAgICAgIGlucHV0OiBzdHJlYW1cbiAgICB9KTtcbiAgICAvLyBXZSBuZWVkIHRvIGV4cGxpY2l0bHkgZGVzdHJveSB0aGUgc3RyZWFtIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLFxuICAgIC8vIHJlbW92aW5nIHRoZSBsaXN0ZW5lcnMgb24gdGhlIHJlYWRsaW5lIGludGVyZmFjZSBpcyBub3QgZW5vdWdoLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy85MDAyIGFuZCBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8xNDg5MlxuICAgIGZ1bmN0aW9uIGRlc3Ryb3lTdHJlYW1BbmRSZXNvbHZlKCkge1xuICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9XG4gICAgLy8gSW5pdCBhdCB6ZXJvIGFuZCBpbmNyZW1lbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsb29wIGJlY2F1c2UgbGluZXMgYXJlIDEgaW5kZXhlZC5cbiAgICBsZXQgbGluZU51bWJlciA9IDA7XG4gICAgbGV0IGN1cnJlbnRSYW5nZUluZGV4ID0gMDtcbiAgICBjb25zdCByYW5nZSA9IHJhbmdlc1tjdXJyZW50UmFuZ2VJbmRleF07XG4gICAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFdlIHNob3VsZCBuZXZlciByZWFjaCB0aGlzIHBvaW50LCBidXQgaWYgd2UgZG8sIHdlIHNob3VsZCByZXNvbHZlIHRoZSBwcm9taXNlIHRvIHByZXZlbnQgaXQgZnJvbSBoYW5naW5nLlxuICAgICAgZGVzdHJveVN0cmVhbUFuZFJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJhbmdlU3RhcnQgPSByYW5nZVswXTtcbiAgICBsZXQgcmFuZ2VFbmQgPSByYW5nZVsxXTtcbiAgICAvLyBXZSB1c2UgdGhpcyBpbnNpZGUgUHJvbWlzZS5hbGwsIHNvIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgcHJvbWlzZSBldmVuIGlmIHRoZXJlIGlzIGFuIGVycm9yXG4gICAgLy8gdG8gcHJldmVudCBQcm9taXNlLmFsbCBmcm9tIHNob3J0IGNpcmN1aXRpbmcgdGhlIHJlc3QuXG4gICAgZnVuY3Rpb24gb25TdHJlYW1FcnJvcigpIHtcbiAgICAgIC8vIE1hcmsgZmlsZSBwYXRoIGFzIGZhaWxlZCB0byByZWFkIGFuZCBwcmV2ZW50IG11bHRpcGxlIHJlYWQgYXR0ZW1wdHMuXG4gICAgICBMUlVfRklMRV9DT05URU5UU19GU19SRUFEX0ZBSUxFRC5zZXQocGF0aCwgMSk7XG4gICAgICBsaW5lUmVhZGVkLmNsb3NlKCk7XG4gICAgICBsaW5lUmVhZGVkLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgZGVzdHJveVN0cmVhbUFuZFJlc29sdmUoKTtcbiAgICB9XG4gICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgdGhlIGVycm9yIGV2ZW50IHRvIHByZXZlbnQgdGhlIHByb2Nlc3MgZnJvbSBjcmFzaGluZyBpbiA8IE5vZGUgMTZcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMTYwM1xuICAgIHN0cmVhbS5vbignZXJyb3InLCBvblN0cmVhbUVycm9yKTtcbiAgICBsaW5lUmVhZGVkLm9uKCdlcnJvcicsIG9uU3RyZWFtRXJyb3IpO1xuICAgIGxpbmVSZWFkZWQub24oJ2Nsb3NlJywgZGVzdHJveVN0cmVhbUFuZFJlc29sdmUpO1xuICAgIGxpbmVSZWFkZWQub24oJ2xpbmUnLCBsaW5lID0+IHtcbiAgICAgIGxpbmVOdW1iZXIrKztcbiAgICAgIGlmIChsaW5lTnVtYmVyIDwgcmFuZ2VTdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyAhV2FybmluZzogVGhpcyBtdXRhdGVzIHRoZSBjYWNoZSBieSBzdG9yaW5nIHRoZSBzbmlwcGVkIGxpbmUgaW50byB0aGUgY2FjaGUuXG4gICAgICBvdXRwdXRbbGluZU51bWJlcl0gPSBzbmlwTGluZShsaW5lLCAwKTtcbiAgICAgIGlmIChsaW5lTnVtYmVyID49IHJhbmdlRW5kKSB7XG4gICAgICAgIGlmIChjdXJyZW50UmFuZ2VJbmRleCA9PT0gcmFuZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNsb3NlIHRoZSBmaWxlIHN0cmVhbSBhbmQgcmVtb3ZlIGxpc3RlbmVycywgZWxzZSB0aGUgcmVhZGVyIHdpbGwgY29udGludWUgdG8gcnVuIG91ciBsaXN0ZW5lcjtcbiAgICAgICAgICBsaW5lUmVhZGVkLmNsb3NlKCk7XG4gICAgICAgICAgbGluZVJlYWRlZC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFJhbmdlSW5kZXgrKztcbiAgICAgICAgY29uc3QgcmFuZ2UgPSByYW5nZXNbY3VycmVudFJhbmdlSW5kZXhdO1xuICAgICAgICBpZiAocmFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBhcyBpdCBtZWFucyB3ZSBoYXZlIGEgYnVnIGluIHRoZSBjb250ZXh0LlxuICAgICAgICAgIGxpbmVSZWFkZWQuY2xvc2UoKTtcbiAgICAgICAgICBsaW5lUmVhZGVkLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByYW5nZVN0YXJ0ID0gcmFuZ2VbMF07XG4gICAgICAgIHJhbmdlRW5kID0gcmFuZ2VbMV07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqIEFkZHMgY29udGV4dCBsaW5lcyB0byBmcmFtZXMgKi9cbmZ1bmN0aW9uIGFkZFNvdXJjZUNvbnRleHRUb0ZyYW1lcyhmcmFtZXMsIGNhY2hlKSB7XG4gIGZvciAoY29uc3QgZnJhbWUgb2YgZnJhbWVzKSB7XG4gICAgLy8gT25seSBhZGQgY29udGV4dCBpZiB3ZSBoYXZlIGEgZmlsZW5hbWUgYW5kIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gYWRkZWRcbiAgICBpZiAoZnJhbWUuZmlsZW5hbWUgJiYgZnJhbWUuY29udGV4dF9saW5lID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIGZyYW1lLmxpbmVubyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gY2FjaGUuZ2V0KGZyYW1lLmZpbGVuYW1lKTtcbiAgICAgIGlmIChjb250ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYWRkQ29udGV4dFRvRnJhbWUoZnJhbWUubGluZW5vLCBmcmFtZSwgY29udGVudHMpO1xuICAgIH1cbiAgfVxufVxuLyoqXHJcbiAqIFJlc29sdmVzIGNvbnRleHQgbGluZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgZ2l2ZW4gbGluZSBudW1iZXIgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGUgZnJhbWU7XHJcbiAqL1xuZnVuY3Rpb24gYWRkQ29udGV4dFRvRnJhbWUobGluZW5vLCBmcmFtZSwgY29udGVudHMpIHtcbiAgLy8gV2hlbiB0aGVyZSBpcyBubyBsaW5lIG51bWJlciBpbiB0aGUgZnJhbWUsIGF0dGFjaGluZyBjb250ZXh0IGlzIG5vbnNlbnNpY2FsIGFuZCB3aWxsIGV2ZW4gYnJlYWsgZ3JvdXBpbmcuXG4gIC8vIFdlIGFscmVhZHkgY2hlY2sgZm9yIGxpbmVubyBiZWZvcmUgY2FsbGluZyB0aGlzLCBidXQgc2luY2UgU3RhY2tGcmFtZSBsaW5lbm8gaXMgb3B0aW9uYWwsIHdlIGNoZWNrIGl0IGFnYWluLlxuICBpZiAoZnJhbWUubGluZW5vID09PSB1bmRlZmluZWQgfHwgY29udGVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmcmFtZS5wcmVfY29udGV4dCA9IFtdO1xuICBmb3IgKGxldCBpID0gbWFrZVJhbmdlU3RhcnQobGluZW5vKTsgaSA8IGxpbmVubzsgaSsrKSB7XG4gICAgLy8gV2UgYWx3YXlzIGV4cGVjdCB0aGUgc3RhcnQgY29udGV4dCBhcyBsaW5lIG51bWJlcnMgY2Fubm90IGJlIG5lZ2F0aXZlLiBJZiB3ZSBkb250IGZpbmQgYSBsaW5lLCB0aGVuXG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3Jvbmcgc29tZXdoZXJlLiBDbGVhciB0aGUgY29udGV4dCBhbmQgcmV0dXJuIHdpdGhvdXQgYWRkaW5nIGFueSBsaW5lY29udGV4dC5cbiAgICBjb25zdCBsaW5lID0gY29udGVudHNbaV07XG4gICAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJMaW5lQ29udGV4dChmcmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZyYW1lLnByZV9jb250ZXh0LnB1c2gobGluZSk7XG4gIH1cbiAgLy8gV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHRoZSBjb250ZXh0IGxpbmUuIElmIHdlIGRvbnQsIHNvbWV0aGluZyB3ZW50IHdyb25nLCBzbyB3ZSBjbGVhciB0aGUgY29udGV4dCBhbmQgcmV0dXJuXG4gIC8vIHdpdGhvdXQgYWRkaW5nIGFueSBsaW5lY29udGV4dC5cbiAgaWYgKGNvbnRlbnRzW2xpbmVub10gPT09IHVuZGVmaW5lZCkge1xuICAgIGNsZWFyTGluZUNvbnRleHQoZnJhbWUpO1xuICAgIHJldHVybjtcbiAgfVxuICBmcmFtZS5jb250ZXh0X2xpbmUgPSBjb250ZW50c1tsaW5lbm9dO1xuICBjb25zdCBlbmQgPSBtYWtlUmFuZ2VFbmQobGluZW5vKTtcbiAgZnJhbWUucG9zdF9jb250ZXh0ID0gW107XG4gIGZvciAobGV0IGkgPSBsaW5lbm8gKyAxOyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgLy8gU2luY2Ugd2UgZG9udCB0cmFjayB3aGVuIHRoZSBmaWxlIGVuZHMsIHdlIGNhbnQgY2xlYXIgdGhlIGNvbnRleHQgaWYgd2UgZG9udCBmaW5kIGEgbGluZSBhcyBpdCBjb3VsZFxuICAgIC8vIGp1c3QgYmUgdGhhdCB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gICAgY29uc3QgbGluZSA9IGNvbnRlbnRzW2ldO1xuICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmcmFtZS5wb3N0X2NvbnRleHQucHVzaChsaW5lKTtcbiAgfVxufVxuLyoqXHJcbiAqIENsZWFycyB0aGUgY29udGV4dCBsaW5lcyBmcm9tIGEgZnJhbWUsIHVzZWQgdG8gcmVzZXQgYSBmcmFtZSB0byBpdHMgb3JpZ2luYWwgc3RhdGVcclxuICogaWYgd2UgZmFpbCB0byByZXNvbHZlIGFsbCBjb250ZXh0IGxpbmVzIGZvciBpdC5cclxuICovXG5mdW5jdGlvbiBjbGVhckxpbmVDb250ZXh0KGZyYW1lKSB7XG4gIGRlbGV0ZSBmcmFtZS5wcmVfY29udGV4dDtcbiAgZGVsZXRlIGZyYW1lLmNvbnRleHRfbGluZTtcbiAgZGVsZXRlIGZyYW1lLnBvc3RfY29udGV4dDtcbn1cbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIGNvbnRleHQgbGluZXMgc2hvdWxkIGJlIHNraXBwZWQgZm9yIGEgZmlsZS5cclxuICogLSAubWluLihtanN8Y2pzfGpzKSBmaWxlcyBhcmUgYW5kIG5vdCB1c2VmdWwgc2luY2UgdGhleSBkb250IHBvaW50IHRvIHRoZSBvcmlnaW5hbCBzb3VyY2VcclxuICogLSBub2RlOiBwcmVmaXhlZCBtb2R1bGVzIGFyZSBwYXJ0IG9mIHRoZSBydW50aW1lIGFuZCBjYW5ub3QgYmUgcmVzb2x2ZWQgdG8gYSBmaWxlXHJcbiAqIC0gZGF0YTogc2tpcCBqc29uLCB3YXNtIGFuZCBpbmxpbmUganMgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9lc20uaHRtbCNkYXRhLWltcG9ydHNcclxuICovXG5mdW5jdGlvbiBzaG91bGRTa2lwQ29udGV4dExpbmVzRm9yRmlsZShwYXRoKSB7XG4gIC8vIFRlc3QgdGhlIG1vc3QgY29tbW9uIHByZWZpeCBhbmQgZXh0ZW5zaW9uIGZpcnN0LiBUaGVzZSBhcmUgdGhlIG9uZXMgd2VcbiAgLy8gYXJlIG1vc3QgbGlrZWx5IHRvIHNlZSBpbiB1c2VyIGFwcGxpY2F0aW9ucyBhbmQgYXJlIHRoZSBvbmVzIHdlIGNhbiBicmVhayBvdXQgb2YgZmlyc3QuXG4gIHJldHVybiBwYXRoLnN0YXJ0c1dpdGgoJ25vZGU6JykgfHwgcGF0aC5lbmRzV2l0aCgnLm1pbi5qcycpIHx8IHBhdGguZW5kc1dpdGgoJy5taW4uY2pzJykgfHwgcGF0aC5lbmRzV2l0aCgnLm1pbi5tanMnKSB8fCBwYXRoLnN0YXJ0c1dpdGgoJ2RhdGE6Jyk7XG59XG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiB3ZSBzaG91bGQgc2tpcCBjb250ZXh0bGluZXMgYmFzZWQgb2ZmIHRoZSBtYXggbGluZW5vIGFuZCBjb2xubyB2YWx1ZXMuXHJcbiAqL1xuZnVuY3Rpb24gc2hvdWxkU2tpcENvbnRleHRMaW5lc0ZvckZyYW1lKGZyYW1lKSB7XG4gIGlmIChmcmFtZS5saW5lbm8gIT09IHVuZGVmaW5lZCAmJiBmcmFtZS5saW5lbm8gPiBNQVhfQ09OVEVYVExJTkVTX0xJTkVOTykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChmcmFtZS5jb2xubyAhPT0gdW5kZWZpbmVkICYmIGZyYW1lLmNvbG5vID4gTUFYX0NPTlRFWFRMSU5FU19DT0xOTykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxyXG4gKiBDaGVja3MgaWYgd2UgaGF2ZSBhbGwgdGhlIGNvbnRlbnRzIHRoYXQgd2UgbmVlZCBpbiB0aGUgY2FjaGUuXHJcbiAqL1xuZnVuY3Rpb24gcmFuZ2VFeGlzdHNJbkNvbnRlbnRDYWNoZShmaWxlLCByYW5nZSkge1xuICBjb25zdCBjb250ZW50cyA9IExSVV9GSUxFX0NPTlRFTlRTX0NBQ0hFLmdldChmaWxlKTtcbiAgaWYgKGNvbnRlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IHJhbmdlWzBdOyBpIDw9IHJhbmdlWzFdOyBpKyspIHtcbiAgICBpZiAoY29udGVudHNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGNvbnRpZ3VvdXMgcmFuZ2VzIG9mIGxpbmVzIHRvIHJlYWQgZnJvbSBhIGZpbGUuIEluIHRoZSBjYXNlIHdoZXJlIGNvbnRleHQgbGluZXMgb3ZlcmxhcCxcclxuICogdGhlIHJhbmdlcyBhcmUgbWVyZ2VkIHRvIGNyZWF0ZSBhIHNpbmdsZSByYW5nZS5cclxuICovXG5mdW5jdGlvbiBtYWtlTGluZVJlYWRlclJhbmdlcyhsaW5lcykge1xuICBpZiAoIWxpbmVzLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxpbmUgPSBsaW5lc1swXTtcbiAgaWYgKHR5cGVvZiBsaW5lICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBsZXQgY3VycmVudCA9IG1ha2VDb250ZXh0UmFuZ2UobGluZSk7XG4gIGNvbnN0IG91dCA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChpID09PSBsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbmV4dCBsaW5lIGZhbGxzIGludG8gdGhlIGN1cnJlbnQgcmFuZ2UsIGV4dGVuZCB0aGUgY3VycmVudCByYW5nZSB0byBsaW5lbm8gKyBsaW5lY29udGV4dC5cbiAgICBjb25zdCBuZXh0ID0gbGluZXNbaSArIDFdO1xuICAgIGlmICh0eXBlb2YgbmV4dCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobmV4dCA8PSBjdXJyZW50WzFdKSB7XG4gICAgICBjdXJyZW50WzFdID0gbmV4dCArIERFRkFVTFRfTElORVNfT0ZfQ09OVEVYVDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gbWFrZUNvbnRleHRSYW5nZShuZXh0KTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4vLyBEZXRlcm1pbmUgc3RhcnQgYW5kIGVuZCBpbmRpY2VzIGZvciBjb250ZXh0IHJhbmdlIChpbmNsdXNpdmUpO1xuZnVuY3Rpb24gbWFrZUNvbnRleHRSYW5nZShsaW5lKSB7XG4gIHJldHVybiBbbWFrZVJhbmdlU3RhcnQobGluZSksIG1ha2VSYW5nZUVuZChsaW5lKV07XG59XG4vLyBDb21wdXRlIGluY2x1c2l2ZSBlbmQgY29udGV4dCByYW5nZVxuZnVuY3Rpb24gbWFrZVJhbmdlU3RhcnQobGluZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMSwgbGluZSAtIERFRkFVTFRfTElORVNfT0ZfQ09OVEVYVCk7XG59XG4vLyBDb21wdXRlIGluY2x1c2l2ZSBzdGFydCBjb250ZXh0IHJhbmdlXG5mdW5jdGlvbiBtYWtlUmFuZ2VFbmQobGluZSkge1xuICByZXR1cm4gbGluZSArIERFRkFVTFRfTElORVNfT0ZfQ09OVEVYVDtcbn1cbi8qKlxyXG4gKiBHZXQgb3IgaW5pdCBtYXAgdmFsdWVcclxuICovXG5mdW5jdGlvbiBlbXBsYWNlKG1hcCwga2V5LCBjb250ZW50cykge1xuICBjb25zdCB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXAuc2V0KGtleSwgY29udGVudHMpO1xuICAgIHJldHVybiBjb250ZW50cztcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzbmlwTGluZShsaW5lLCBjb2xubykge1xuICBsZXQgbmV3TGluZSA9IGxpbmU7XG4gIGNvbnN0IGxpbmVMZW5ndGggPSBuZXdMaW5lLmxlbmd0aDtcbiAgaWYgKGxpbmVMZW5ndGggPD0gMTUwKSB7XG4gICAgcmV0dXJuIG5ld0xpbmU7XG4gIH1cbiAgaWYgKGNvbG5vID4gbGluZUxlbmd0aCkge1xuICAgIGNvbG5vID0gbGluZUxlbmd0aDtcbiAgfVxuICBsZXQgc3RhcnQgPSBNYXRoLm1heChjb2xubyAtIDYwLCAwKTtcbiAgaWYgKHN0YXJ0IDwgNSkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICBsZXQgZW5kID0gTWF0aC5taW4oc3RhcnQgKyAxNDAsIGxpbmVMZW5ndGgpO1xuICBpZiAoZW5kID4gbGluZUxlbmd0aCAtIDUpIHtcbiAgICBlbmQgPSBsaW5lTGVuZ3RoO1xuICB9XG4gIGlmIChlbmQgPT09IGxpbmVMZW5ndGgpIHtcbiAgICBzdGFydCA9IE1hdGgubWF4KGVuZCAtIDE0MCwgMCk7XG4gIH1cbiAgbmV3TGluZSA9IG5ld0xpbmUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChzdGFydCA+IDApIHtcbiAgICBuZXdMaW5lID0gYC4uLiR7bmV3TGluZX1gO1xuICB9XG4gIGlmIChlbmQgPCBsaW5lTGVuZ3RoKSB7XG4gICAgbmV3TGluZSArPSAnLi4uJztcbiAgfVxuICByZXR1cm4gbmV3TGluZTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjUuNi4wXCI7XG5cbnZhciBQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHk7XHJcbihmdW5jdGlvbiAoUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5KSB7XHJcbiAgICBQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHlbXCJBbm9ueW1vdXNJZFwiXSA9IFwiYW5vbnltb3VzX2lkXCI7XHJcbiAgICBQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHlbXCJEaXN0aW5jdElkXCJdID0gXCJkaXN0aW5jdF9pZFwiO1xyXG4gICAgUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5W1wiUHJvcHNcIl0gPSBcInByb3BzXCI7XHJcbiAgICBQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHlbXCJGZWF0dXJlRmxhZ0RldGFpbHNcIl0gPSBcImZlYXR1cmVfZmxhZ19kZXRhaWxzXCI7XHJcbiAgICBQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHlbXCJGZWF0dXJlRmxhZ3NcIl0gPSBcImZlYXR1cmVfZmxhZ3NcIjtcclxuICAgIFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eVtcIkZlYXR1cmVGbGFnUGF5bG9hZHNcIl0gPSBcImZlYXR1cmVfZmxhZ19wYXlsb2Fkc1wiO1xyXG4gICAgUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5W1wiQm9vdHN0cmFwRmVhdHVyZUZsYWdEZXRhaWxzXCJdID0gXCJib290c3RyYXBfZmVhdHVyZV9mbGFnX2RldGFpbHNcIjtcclxuICAgIFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eVtcIkJvb3RzdHJhcEZlYXR1cmVGbGFnc1wiXSA9IFwiYm9vdHN0cmFwX2ZlYXR1cmVfZmxhZ3NcIjtcclxuICAgIFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eVtcIkJvb3RzdHJhcEZlYXR1cmVGbGFnUGF5bG9hZHNcIl0gPSBcImJvb3RzdHJhcF9mZWF0dXJlX2ZsYWdfcGF5bG9hZHNcIjtcclxuICAgIFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eVtcIk92ZXJyaWRlRmVhdHVyZUZsYWdzXCJdID0gXCJvdmVycmlkZV9mZWF0dXJlX2ZsYWdzXCI7XHJcbiAgICBQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHlbXCJRdWV1ZVwiXSA9IFwicXVldWVcIjtcclxuICAgIFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eVtcIk9wdGVkT3V0XCJdID0gXCJvcHRlZF9vdXRcIjtcclxuICAgIFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eVtcIlNlc3Npb25JZFwiXSA9IFwic2Vzc2lvbl9pZFwiO1xyXG4gICAgUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5W1wiU2Vzc2lvblN0YXJ0VGltZXN0YW1wXCJdID0gXCJzZXNzaW9uX3N0YXJ0X3RpbWVzdGFtcFwiO1xyXG4gICAgUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5W1wiU2Vzc2lvbkxhc3RUaW1lc3RhbXBcIl0gPSBcInNlc3Npb25fdGltZXN0YW1wXCI7XHJcbiAgICBQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHlbXCJQZXJzb25Qcm9wZXJ0aWVzXCJdID0gXCJwZXJzb25fcHJvcGVydGllc1wiO1xyXG4gICAgUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5W1wiR3JvdXBQcm9wZXJ0aWVzXCJdID0gXCJncm91cF9wcm9wZXJ0aWVzXCI7XHJcbiAgICBQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHlbXCJJbnN0YWxsZWRBcHBCdWlsZFwiXSA9IFwiaW5zdGFsbGVkX2FwcF9idWlsZFwiO1xyXG4gICAgUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5W1wiSW5zdGFsbGVkQXBwVmVyc2lvblwiXSA9IFwiaW5zdGFsbGVkX2FwcF92ZXJzaW9uXCI7XHJcbiAgICBQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHlbXCJTZXNzaW9uUmVwbGF5XCJdID0gXCJzZXNzaW9uX3JlcGxheVwiO1xyXG4gICAgUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5W1wiU3VydmV5TGFzdFNlZW5EYXRlXCJdID0gXCJzdXJ2ZXlfbGFzdF9zZWVuX2RhdGVcIjtcclxuICAgIFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eVtcIlN1cnZleXNTZWVuXCJdID0gXCJzdXJ2ZXlzX3NlZW5cIjtcclxuICAgIFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eVtcIlN1cnZleXNcIl0gPSBcInN1cnZleXNcIjtcclxuICAgIFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eVtcIlJlbW90ZUNvbmZpZ1wiXSA9IFwicmVtb3RlX2NvbmZpZ1wiO1xyXG4gICAgUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5W1wiRmxhZ3NFbmRwb2ludFdhc0hpdFwiXSA9IFwiZmxhZ3NfZW5kcG9pbnRfd2FzX2hpdFwiO1xyXG59KShQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHkgfHwgKFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eSA9IHt9KSk7XHJcbi8vIEFueSBrZXkgcHJlZml4ZWQgd2l0aCBgYXR0cl9fYCBjYW4gYmUgYWRkZWRcclxudmFyIENvbXByZXNzaW9uO1xyXG4oZnVuY3Rpb24gKENvbXByZXNzaW9uKSB7XHJcbiAgICBDb21wcmVzc2lvbltcIkdaaXBKU1wiXSA9IFwiZ3ppcC1qc1wiO1xyXG4gICAgQ29tcHJlc3Npb25bXCJCYXNlNjRcIl0gPSBcImJhc2U2NFwiO1xyXG59KShDb21wcmVzc2lvbiB8fCAoQ29tcHJlc3Npb24gPSB7fSkpO1xyXG52YXIgU3VydmV5UG9zaXRpb247XHJcbihmdW5jdGlvbiAoU3VydmV5UG9zaXRpb24pIHtcclxuICAgIFN1cnZleVBvc2l0aW9uW1wiVG9wTGVmdFwiXSA9IFwidG9wX2xlZnRcIjtcclxuICAgIFN1cnZleVBvc2l0aW9uW1wiVG9wQ2VudGVyXCJdID0gXCJ0b3BfY2VudGVyXCI7XHJcbiAgICBTdXJ2ZXlQb3NpdGlvbltcIlRvcFJpZ2h0XCJdID0gXCJ0b3BfcmlnaHRcIjtcclxuICAgIFN1cnZleVBvc2l0aW9uW1wiTWlkZGxlTGVmdFwiXSA9IFwibWlkZGxlX2xlZnRcIjtcclxuICAgIFN1cnZleVBvc2l0aW9uW1wiTWlkZGxlQ2VudGVyXCJdID0gXCJtaWRkbGVfY2VudGVyXCI7XHJcbiAgICBTdXJ2ZXlQb3NpdGlvbltcIk1pZGRsZVJpZ2h0XCJdID0gXCJtaWRkbGVfcmlnaHRcIjtcclxuICAgIFN1cnZleVBvc2l0aW9uW1wiTGVmdFwiXSA9IFwibGVmdFwiO1xyXG4gICAgU3VydmV5UG9zaXRpb25bXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcclxuICAgIFN1cnZleVBvc2l0aW9uW1wiQ2VudGVyXCJdID0gXCJjZW50ZXJcIjtcclxufSkoU3VydmV5UG9zaXRpb24gfHwgKFN1cnZleVBvc2l0aW9uID0ge30pKTtcclxudmFyIFN1cnZleVdpZGdldFR5cGU7XHJcbihmdW5jdGlvbiAoU3VydmV5V2lkZ2V0VHlwZSkge1xyXG4gICAgU3VydmV5V2lkZ2V0VHlwZVtcIkJ1dHRvblwiXSA9IFwiYnV0dG9uXCI7XHJcbiAgICBTdXJ2ZXlXaWRnZXRUeXBlW1wiVGFiXCJdID0gXCJ0YWJcIjtcclxuICAgIFN1cnZleVdpZGdldFR5cGVbXCJTZWxlY3RvclwiXSA9IFwic2VsZWN0b3JcIjtcclxufSkoU3VydmV5V2lkZ2V0VHlwZSB8fCAoU3VydmV5V2lkZ2V0VHlwZSA9IHt9KSk7XHJcbnZhciBTdXJ2ZXlUeXBlO1xyXG4oZnVuY3Rpb24gKFN1cnZleVR5cGUpIHtcclxuICAgIFN1cnZleVR5cGVbXCJQb3BvdmVyXCJdID0gXCJwb3BvdmVyXCI7XHJcbiAgICBTdXJ2ZXlUeXBlW1wiQVBJXCJdID0gXCJhcGlcIjtcclxuICAgIFN1cnZleVR5cGVbXCJXaWRnZXRcIl0gPSBcIndpZGdldFwiO1xyXG59KShTdXJ2ZXlUeXBlIHx8IChTdXJ2ZXlUeXBlID0ge30pKTtcclxudmFyIFN1cnZleVF1ZXN0aW9uRGVzY3JpcHRpb25Db250ZW50VHlwZTtcclxuKGZ1bmN0aW9uIChTdXJ2ZXlRdWVzdGlvbkRlc2NyaXB0aW9uQ29udGVudFR5cGUpIHtcclxuICAgIFN1cnZleVF1ZXN0aW9uRGVzY3JpcHRpb25Db250ZW50VHlwZVtcIkh0bWxcIl0gPSBcImh0bWxcIjtcclxuICAgIFN1cnZleVF1ZXN0aW9uRGVzY3JpcHRpb25Db250ZW50VHlwZVtcIlRleHRcIl0gPSBcInRleHRcIjtcclxufSkoU3VydmV5UXVlc3Rpb25EZXNjcmlwdGlvbkNvbnRlbnRUeXBlIHx8IChTdXJ2ZXlRdWVzdGlvbkRlc2NyaXB0aW9uQ29udGVudFR5cGUgPSB7fSkpO1xyXG52YXIgU3VydmV5UmF0aW5nRGlzcGxheTtcclxuKGZ1bmN0aW9uIChTdXJ2ZXlSYXRpbmdEaXNwbGF5KSB7XHJcbiAgICBTdXJ2ZXlSYXRpbmdEaXNwbGF5W1wiTnVtYmVyXCJdID0gXCJudW1iZXJcIjtcclxuICAgIFN1cnZleVJhdGluZ0Rpc3BsYXlbXCJFbW9qaVwiXSA9IFwiZW1vamlcIjtcclxufSkoU3VydmV5UmF0aW5nRGlzcGxheSB8fCAoU3VydmV5UmF0aW5nRGlzcGxheSA9IHt9KSk7XHJcbnZhciBTdXJ2ZXlRdWVzdGlvblR5cGU7XHJcbihmdW5jdGlvbiAoU3VydmV5UXVlc3Rpb25UeXBlKSB7XHJcbiAgICBTdXJ2ZXlRdWVzdGlvblR5cGVbXCJPcGVuXCJdID0gXCJvcGVuXCI7XHJcbiAgICBTdXJ2ZXlRdWVzdGlvblR5cGVbXCJNdWx0aXBsZUNob2ljZVwiXSA9IFwibXVsdGlwbGVfY2hvaWNlXCI7XHJcbiAgICBTdXJ2ZXlRdWVzdGlvblR5cGVbXCJTaW5nbGVDaG9pY2VcIl0gPSBcInNpbmdsZV9jaG9pY2VcIjtcclxuICAgIFN1cnZleVF1ZXN0aW9uVHlwZVtcIlJhdGluZ1wiXSA9IFwicmF0aW5nXCI7XHJcbiAgICBTdXJ2ZXlRdWVzdGlvblR5cGVbXCJMaW5rXCJdID0gXCJsaW5rXCI7XHJcbn0pKFN1cnZleVF1ZXN0aW9uVHlwZSB8fCAoU3VydmV5UXVlc3Rpb25UeXBlID0ge30pKTtcclxudmFyIFN1cnZleVF1ZXN0aW9uQnJhbmNoaW5nVHlwZTtcclxuKGZ1bmN0aW9uIChTdXJ2ZXlRdWVzdGlvbkJyYW5jaGluZ1R5cGUpIHtcclxuICAgIFN1cnZleVF1ZXN0aW9uQnJhbmNoaW5nVHlwZVtcIk5leHRRdWVzdGlvblwiXSA9IFwibmV4dF9xdWVzdGlvblwiO1xyXG4gICAgU3VydmV5UXVlc3Rpb25CcmFuY2hpbmdUeXBlW1wiRW5kXCJdID0gXCJlbmRcIjtcclxuICAgIFN1cnZleVF1ZXN0aW9uQnJhbmNoaW5nVHlwZVtcIlJlc3BvbnNlQmFzZWRcIl0gPSBcInJlc3BvbnNlX2Jhc2VkXCI7XHJcbiAgICBTdXJ2ZXlRdWVzdGlvbkJyYW5jaGluZ1R5cGVbXCJTcGVjaWZpY1F1ZXN0aW9uXCJdID0gXCJzcGVjaWZpY19xdWVzdGlvblwiO1xyXG59KShTdXJ2ZXlRdWVzdGlvbkJyYW5jaGluZ1R5cGUgfHwgKFN1cnZleVF1ZXN0aW9uQnJhbmNoaW5nVHlwZSA9IHt9KSk7XHJcbnZhciBTdXJ2ZXlNYXRjaFR5cGU7XHJcbihmdW5jdGlvbiAoU3VydmV5TWF0Y2hUeXBlKSB7XHJcbiAgICBTdXJ2ZXlNYXRjaFR5cGVbXCJSZWdleFwiXSA9IFwicmVnZXhcIjtcclxuICAgIFN1cnZleU1hdGNoVHlwZVtcIk5vdFJlZ2V4XCJdID0gXCJub3RfcmVnZXhcIjtcclxuICAgIFN1cnZleU1hdGNoVHlwZVtcIkV4YWN0XCJdID0gXCJleGFjdFwiO1xyXG4gICAgU3VydmV5TWF0Y2hUeXBlW1wiSXNOb3RcIl0gPSBcImlzX25vdFwiO1xyXG4gICAgU3VydmV5TWF0Y2hUeXBlW1wiSWNvbnRhaW5zXCJdID0gXCJpY29udGFpbnNcIjtcclxuICAgIFN1cnZleU1hdGNoVHlwZVtcIk5vdEljb250YWluc1wiXSA9IFwibm90X2ljb250YWluc1wiO1xyXG59KShTdXJ2ZXlNYXRjaFR5cGUgfHwgKFN1cnZleU1hdGNoVHlwZSA9IHt9KSk7XHJcbi8qKiBTeW5jIHdpdGggcGx1Z2luLXNlcnZlci9zcmMvdHlwZXMudHMgKi9cclxudmFyIEFjdGlvblN0ZXBTdHJpbmdNYXRjaGluZztcclxuKGZ1bmN0aW9uIChBY3Rpb25TdGVwU3RyaW5nTWF0Y2hpbmcpIHtcclxuICAgIEFjdGlvblN0ZXBTdHJpbmdNYXRjaGluZ1tcIkNvbnRhaW5zXCJdID0gXCJjb250YWluc1wiO1xyXG4gICAgQWN0aW9uU3RlcFN0cmluZ01hdGNoaW5nW1wiRXhhY3RcIl0gPSBcImV4YWN0XCI7XHJcbiAgICBBY3Rpb25TdGVwU3RyaW5nTWF0Y2hpbmdbXCJSZWdleFwiXSA9IFwicmVnZXhcIjtcclxufSkoQWN0aW9uU3RlcFN0cmluZ01hdGNoaW5nIHx8IChBY3Rpb25TdGVwU3RyaW5nTWF0Y2hpbmcgPSB7fSkpO1xuXG5jb25zdCBub3JtYWxpemVGbGFnc1Jlc3BvbnNlID0gKGZsYWdzUmVzcG9uc2UpID0+IHtcclxuICAgIGlmICgnZmxhZ3MnIGluIGZsYWdzUmVzcG9uc2UpIHtcclxuICAgICAgICAvLyBDb252ZXJ0IHYyIGZvcm1hdCB0byB2MSBmb3JtYXRcclxuICAgICAgICBjb25zdCBmZWF0dXJlRmxhZ3MgPSBnZXRGbGFnVmFsdWVzRnJvbUZsYWdzKGZsYWdzUmVzcG9uc2UuZmxhZ3MpO1xyXG4gICAgICAgIGNvbnN0IGZlYXR1cmVGbGFnUGF5bG9hZHMgPSBnZXRQYXlsb2Fkc0Zyb21GbGFncyhmbGFnc1Jlc3BvbnNlLmZsYWdzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5mbGFnc1Jlc3BvbnNlLFxyXG4gICAgICAgICAgICBmZWF0dXJlRmxhZ3MsXHJcbiAgICAgICAgICAgIGZlYXR1cmVGbGFnUGF5bG9hZHMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIENvbnZlcnQgdjEgZm9ybWF0IHRvIHYyIGZvcm1hdFxyXG4gICAgICAgIGNvbnN0IGZlYXR1cmVGbGFncyA9IGZsYWdzUmVzcG9uc2UuZmVhdHVyZUZsYWdzID8/IHt9O1xyXG4gICAgICAgIGNvbnN0IGZlYXR1cmVGbGFnUGF5bG9hZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZmxhZ3NSZXNwb25zZS5mZWF0dXJlRmxhZ1BheWxvYWRzIHx8IHt9KS5tYXAoKFtrLCB2XSkgPT4gW2ssIHBhcnNlUGF5bG9hZCh2KV0pKTtcclxuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhmZWF0dXJlRmxhZ3MpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXHJcbiAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgZ2V0RmxhZ0RldGFpbEZyb21GbGFnQW5kUGF5bG9hZChrZXksIHZhbHVlLCBmZWF0dXJlRmxhZ1BheWxvYWRzW2tleV0pLFxyXG4gICAgICAgIF0pKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5mbGFnc1Jlc3BvbnNlLFxyXG4gICAgICAgICAgICBmZWF0dXJlRmxhZ3MsXHJcbiAgICAgICAgICAgIGZlYXR1cmVGbGFnUGF5bG9hZHMsXHJcbiAgICAgICAgICAgIGZsYWdzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGdldEZsYWdEZXRhaWxGcm9tRmxhZ0FuZFBheWxvYWQoa2V5LCB2YWx1ZSwgcGF5bG9hZCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICBlbmFibGVkOiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdHJ1ZSA6IHZhbHVlLFxyXG4gICAgICAgIHZhcmlhbnQ6IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IHVuZGVmaW5lZCxcclxuICAgICAgICByZWFzb246IHVuZGVmaW5lZCxcclxuICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgICBpZDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQgPyBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHVuZGVmaW5lZCxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogR2V0IHRoZSBmbGFnIHZhbHVlcyBmcm9tIHRoZSBmbGFncyB2NCByZXNwb25zZS5cclxuICogQHBhcmFtIGZsYWdzIC0gVGhlIGZsYWdzXHJcbiAqIEByZXR1cm5zIFRoZSBmbGFnIHZhbHVlc1xyXG4gKi9cclxuY29uc3QgZ2V0RmxhZ1ZhbHVlc0Zyb21GbGFncyA9IChmbGFncykgPT4ge1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhmbGFncyA/PyB7fSlcclxuICAgICAgICAubWFwKChba2V5LCBkZXRhaWxdKSA9PiBba2V5LCBnZXRGZWF0dXJlRmxhZ1ZhbHVlKGRldGFpbCldKVxyXG4gICAgICAgIC5maWx0ZXIoKFssIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCkpO1xyXG59O1xyXG4vKipcclxuICogR2V0IHRoZSBwYXlsb2FkcyBmcm9tIHRoZSBmbGFncyB2NCByZXNwb25zZS5cclxuICogQHBhcmFtIGZsYWdzIC0gVGhlIGZsYWdzXHJcbiAqIEByZXR1cm5zIFRoZSBwYXlsb2Fkc1xyXG4gKi9cclxuY29uc3QgZ2V0UGF5bG9hZHNGcm9tRmxhZ3MgPSAoZmxhZ3MpID0+IHtcclxuICAgIGNvbnN0IHNhZmVGbGFncyA9IGZsYWdzID8/IHt9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhzYWZlRmxhZ3MpXHJcbiAgICAgICAgLmZpbHRlcigoZmxhZykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBzYWZlRmxhZ3NbZmxhZ107XHJcbiAgICAgICAgcmV0dXJuIGRldGFpbHMuZW5hYmxlZCAmJiBkZXRhaWxzLm1ldGFkYXRhICYmIGRldGFpbHMubWV0YWRhdGEucGF5bG9hZCAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfSlcclxuICAgICAgICAubWFwKChmbGFnKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHNhZmVGbGFnc1tmbGFnXS5tZXRhZGF0YT8ucGF5bG9hZDtcclxuICAgICAgICByZXR1cm4gW2ZsYWcsIHBheWxvYWQgPyBwYXJzZVBheWxvYWQocGF5bG9hZCkgOiB1bmRlZmluZWRdO1xyXG4gICAgfSkpO1xyXG59O1xyXG5jb25zdCBnZXRGZWF0dXJlRmxhZ1ZhbHVlID0gKGRldGFpbCkgPT4ge1xyXG4gICAgcmV0dXJuIGRldGFpbCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZGV0YWlsLnZhcmlhbnQgPz8gZGV0YWlsLmVuYWJsZWQ7XHJcbn07XHJcbmNvbnN0IHBhcnNlUGF5bG9hZCA9IChyZXNwb25zZSkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiByZXNwb25zZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3BvbnNlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIHtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICB9XHJcbn07XG5cbmNvbnN0IFNUUklOR19GT1JNQVQgPSAndXRmOCc7XHJcbmZ1bmN0aW9uIGFzc2VydCh0cnV0aHlWYWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgaWYgKCF0cnV0aHlWYWx1ZSB8fCB0eXBlb2YgdHJ1dGh5VmFsdWUgIT09ICdzdHJpbmcnIHx8IGlzRW1wdHkodHJ1dGh5VmFsdWUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzRW1wdHkodHJ1dGh5VmFsdWUpIHtcclxuICAgIGlmICh0cnV0aHlWYWx1ZS50cmltKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdTbGFzaCh1cmwpIHtcclxuICAgIHJldHVybiB1cmw/LnJlcGxhY2UoL1xcLyskLywgJycpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHJldHJpYWJsZShmbiwgcHJvcHMpIHtcclxuICAgIGxldCBsYXN0RXJyb3IgPSBudWxsO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5yZXRyeUNvdW50ICsgMTsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIGRvbid0IHdhaXQgd2hlbiBpdCdzIHRoZSBsYXN0IHRyeVxyXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCBwcm9wcy5yZXRyeURlbGF5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZuKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxhc3RFcnJvciA9IGU7XHJcbiAgICAgICAgICAgIGlmICghcHJvcHMucmV0cnlDaGVjayhlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRocm93IGxhc3RFcnJvcjtcclxufVxyXG5mdW5jdGlvbiBjdXJyZW50SVNPVGltZSgpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gc2FmZVNldFRpbWVvdXQoZm4sIHRpbWVvdXQpIHtcclxuICAgIC8vIE5PVEU6IHdlIHVzZSB0aGlzIHNvIHJhcmVseSB0aGF0IGl0IGlzIHRvdGFsbHkgZmluZSB0byBkbyBgc2FmZVNldFRpbWVvdXQoZm4sIDApYGBcclxuICAgIC8vIHJhdGhlciB0aGFuIHNldEltbWVkaWF0ZS5cclxuICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KGZuLCB0aW1lb3V0KTtcclxuICAgIC8vIFdlIHVucmVmIGlmIGF2YWlsYWJsZSB0byBwcmV2ZW50IE5vZGUuanMgaGFuZ2luZyBvbiBleGl0XHJcbiAgICB0Py51bnJlZiAmJiB0Py51bnJlZigpO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuZnVuY3Rpb24gYWxsU2V0dGxlZChwcm9taXNlcykge1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzLm1hcCgocCkgPT4gKHAgPz8gUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oKHZhbHVlKSA9PiAoeyBzdGF0dXM6ICdmdWxmaWxsZWQnLCB2YWx1ZSB9KSwgKHJlYXNvbikgPT4gKHsgc3RhdHVzOiAncmVqZWN0ZWQnLCByZWFzb24gfSkpKSk7XHJcbn1cblxuLyoqXHJcbiAqIE9sZGVyIGJyb3dzZXJzIGFuZCBzb21lIHJ1bnRpbWVzIGRvbid0IHN1cHBvcnQgdGhpcyB5ZXRcclxuICogVGhpcyBBUEkgKGFzIG9mIDIwMjUtMDUtMDcpIGlzIG5vdCBhdmFpbGFibGUgb24gUmVhY3QgTmF0aXZlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNHemlwU3VwcG9ydGVkKCkge1xyXG4gICAgcmV0dXJuICdDb21wcmVzc2lvblN0cmVhbScgaW4gZ2xvYmFsVGhpcztcclxufVxyXG4vKipcclxuICogR3ppcCBhIHN0cmluZyB1c2luZyBDb21wcmVzc2lvbiBTdHJlYW1zIEFQSSBpZiBpdCdzIGF2YWlsYWJsZVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ3ppcENvbXByZXNzKGlucHV0LCBpc0RlYnVnID0gdHJ1ZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBUdXJuIHRoZSBzdHJpbmcgaW50byBhIHN0cmVhbSB1c2luZyBhIEJsb2IsIGFuZCB0aGVuIGNvbXByZXNzIGl0XHJcbiAgICAgICAgY29uc3QgZGF0YVN0cmVhbSA9IG5ldyBCbG9iKFtpbnB1dF0sIHtcclxuICAgICAgICAgICAgdHlwZTogJ3RleHQvcGxhaW4nLFxyXG4gICAgICAgIH0pLnN0cmVhbSgpO1xyXG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWRTdHJlYW0gPSBkYXRhU3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBDb21wcmVzc2lvblN0cmVhbSgnZ3ppcCcpKTtcclxuICAgICAgICAvLyBVc2luZyBhIFJlc3BvbnNlIHRvIGVhc2lseSBleHRyYWN0IHRoZSByZWFkYWJsZXN0cmVhbSB2YWx1ZS4gRGVjb2RpbmcgaW50byBhIHN0cmluZyBmb3IgZmV0Y2hcclxuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFJlc3BvbnNlKGNvbXByZXNzZWRTdHJlYW0pLmJsb2IoKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGlmIChpc0RlYnVnKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnemlwIGNvbXByZXNzIGRhdGEnLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNpbXBsZUV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge307XHJcbiAgICB9XHJcbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50XSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudHNbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IHRoaXMuZXZlbnRzW2V2ZW50XS5maWx0ZXIoKHgpID0+IHggIT09IGxpc3RlbmVyKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZW1pdChldmVudCwgcGF5bG9hZCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKHBheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuZXZlbnRzWycqJ10gfHwgW10pIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIoZXZlbnQsIHBheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBQb3N0SG9nRmV0Y2hIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgcmVxQnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIHN1cGVyKCdIVFRQIGVycm9yIHdoaWxlIGZldGNoaW5nIFBvc3RIb2c6IHN0YXR1cz0nICsgcmVzcG9uc2Uuc3RhdHVzICsgJywgcmVxQnl0ZUxlbmd0aD0nICsgcmVxQnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xyXG4gICAgICAgIHRoaXMucmVxQnl0ZUxlbmd0aCA9IHJlcUJ5dGVMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Bvc3RIb2dGZXRjaEh0dHBFcnJvcic7XHJcbiAgICB9XHJcbiAgICBnZXQgc3RhdHVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1cztcclxuICAgIH1cclxuICAgIGdldCB0ZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnRleHQoKTtcclxuICAgIH1cclxuICAgIGdldCBqc29uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLmpzb24oKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBQb3N0SG9nRmV0Y2hOZXR3b3JrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xyXG4gICAgICAgIC8vIFRSSUNLWTogXCJjYXVzZVwiIGlzIGEgbmV3ZXIgcHJvcGVydHkgYnV0IGlzIGp1c3QgaWdub3JlZCBvdGhlcndpc2UuIENhc3QgdG8gYW55IHRvIGlnbm9yZSB0aGUgdHlwZSBpc3N1ZS5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci10cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgc3VwZXIoJ05ldHdvcmsgZXJyb3Igd2hpbGUgZmV0Y2hpbmcgUG9zdEhvZycsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyB7IGNhdXNlOiBlcnJvciB9IDoge30pO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnUG9zdEhvZ0ZldGNoTmV0d29ya0Vycm9yJztcclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiBsb2dGbHVzaEVycm9yKGVycikge1xyXG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFBvc3RIb2dGZXRjaEh0dHBFcnJvcikge1xyXG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGV4dCA9IGF3YWl0IGVyci50ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCB7IH1cclxuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGlsZSBmbHVzaGluZyBQb3N0SG9nOiBtZXNzYWdlPSR7ZXJyLm1lc3NhZ2V9LCByZXNwb25zZSBib2R5PSR7dGV4dH1gLCBlcnIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igd2hpbGUgZmx1c2hpbmcgUG9zdEhvZycsIGVycik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbn1cclxuZnVuY3Rpb24gaXNQb3N0SG9nRmV0Y2hFcnJvcihlcnIpIHtcclxuICAgIHJldHVybiB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiAoZXJyIGluc3RhbmNlb2YgUG9zdEhvZ0ZldGNoSHR0cEVycm9yIHx8IGVyciBpbnN0YW5jZW9mIFBvc3RIb2dGZXRjaE5ldHdvcmtFcnJvcik7XHJcbn1cclxuZnVuY3Rpb24gaXNQb3N0SG9nRmV0Y2hDb250ZW50VG9vTGFyZ2VFcnJvcihlcnIpIHtcclxuICAgIHJldHVybiB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiBlcnIgaW5zdGFuY2VvZiBQb3N0SG9nRmV0Y2hIdHRwRXJyb3IgJiYgZXJyLnN0YXR1cyA9PT0gNDEzO1xyXG59XHJcbnZhciBRdW90YUxpbWl0ZWRGZWF0dXJlO1xyXG4oZnVuY3Rpb24gKFF1b3RhTGltaXRlZEZlYXR1cmUpIHtcclxuICAgIFF1b3RhTGltaXRlZEZlYXR1cmVbXCJGZWF0dXJlRmxhZ3NcIl0gPSBcImZlYXR1cmVfZmxhZ3NcIjtcclxuICAgIFF1b3RhTGltaXRlZEZlYXR1cmVbXCJSZWNvcmRpbmdzXCJdID0gXCJyZWNvcmRpbmdzXCI7XHJcbn0pKFF1b3RhTGltaXRlZEZlYXR1cmUgfHwgKFF1b3RhTGltaXRlZEZlYXR1cmUgPSB7fSkpO1xyXG5jbGFzcyBQb3N0SG9nQ29yZVN0YXRlbGVzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcGlLZXksIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaHV0ZG93blByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Byb21pc2VzID0ge307XHJcbiAgICAgICAgLy8gaW50ZXJuYWxcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgU2ltcGxlRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIGFzc2VydChhcGlLZXksIFwiWW91IG11c3QgcGFzcyB5b3VyIFBvc3RIb2cgcHJvamVjdCdzIGFwaSBrZXkuXCIpO1xyXG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xyXG4gICAgICAgIHRoaXMuaG9zdCA9IHJlbW92ZVRyYWlsaW5nU2xhc2gob3B0aW9ucz8uaG9zdCB8fCAnaHR0cHM6Ly91cy5pLnBvc3Rob2cuY29tJyk7XHJcbiAgICAgICAgdGhpcy5mbHVzaEF0ID0gb3B0aW9ucz8uZmx1c2hBdCA/IE1hdGgubWF4KG9wdGlvbnM/LmZsdXNoQXQsIDEpIDogMjA7XHJcbiAgICAgICAgdGhpcy5tYXhCYXRjaFNpemUgPSBNYXRoLm1heCh0aGlzLmZsdXNoQXQsIG9wdGlvbnM/Lm1heEJhdGNoU2l6ZSA/PyAxMDApO1xyXG4gICAgICAgIHRoaXMubWF4UXVldWVTaXplID0gTWF0aC5tYXgodGhpcy5mbHVzaEF0LCBvcHRpb25zPy5tYXhRdWV1ZVNpemUgPz8gMTAwMCk7XHJcbiAgICAgICAgdGhpcy5mbHVzaEludGVydmFsID0gb3B0aW9ucz8uZmx1c2hJbnRlcnZhbCA/PyAxMDAwMDtcclxuICAgICAgICB0aGlzLnByZWxvYWRGZWF0dXJlRmxhZ3MgPSBvcHRpb25zPy5wcmVsb2FkRmVhdHVyZUZsYWdzID8/IHRydWU7XHJcbiAgICAgICAgLy8gSWYgZW5hYmxlIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlIHdlIG92ZXJyaWRlIHRoZSBvcHRvdXRcclxuICAgICAgICB0aGlzLmRlZmF1bHRPcHRJbiA9IG9wdGlvbnM/LmRlZmF1bHRPcHRJbiA/PyB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZVN1cnZleXMgPSBvcHRpb25zPy5kaXNhYmxlU3VydmV5cyA/PyBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZXRyeU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHJldHJ5Q291bnQ6IG9wdGlvbnM/LmZldGNoUmV0cnlDb3VudCA/PyAzLFxyXG4gICAgICAgICAgICByZXRyeURlbGF5OiBvcHRpb25zPy5mZXRjaFJldHJ5RGVsYXkgPz8gMzAwMCxcclxuICAgICAgICAgICAgcmV0cnlDaGVjazogaXNQb3N0SG9nRmV0Y2hFcnJvcixcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRpb25zPy5yZXF1ZXN0VGltZW91dCA/PyAxMDAwMDsgLy8gMTAgc2Vjb25kc1xyXG4gICAgICAgIHRoaXMuZmVhdHVyZUZsYWdzUmVxdWVzdFRpbWVvdXRNcyA9IG9wdGlvbnM/LmZlYXR1cmVGbGFnc1JlcXVlc3RUaW1lb3V0TXMgPz8gMzAwMDsgLy8gMyBzZWNvbmRzXHJcbiAgICAgICAgdGhpcy5yZW1vdGVDb25maWdSZXF1ZXN0VGltZW91dE1zID0gb3B0aW9ucz8ucmVtb3RlQ29uZmlnUmVxdWVzdFRpbWVvdXRNcyA/PyAzMDAwOyAvLyAzIHNlY29uZHNcclxuICAgICAgICB0aGlzLmRpc2FibGVHZW9pcCA9IG9wdGlvbnM/LmRpc2FibGVHZW9pcCA/PyB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBvcHRpb25zPy5kaXNhYmxlZCA/PyBmYWxzZTtcclxuICAgICAgICB0aGlzLmhpc3RvcmljYWxNaWdyYXRpb24gPSBvcHRpb25zPy5oaXN0b3JpY2FsTWlncmF0aW9uID8/IGZhbHNlO1xyXG4gICAgICAgIC8vIEluaXQgcHJvbWlzZSBhbGxvd3MgdGhlIGRlcml2ZWQgY2xhc3MgdG8gYmxvY2sgY2FsbHMgdW50aWwgaXQgaXMgcmVhZHlcclxuICAgICAgICB0aGlzLl9pbml0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZUNvbXByZXNzaW9uID0gIWlzR3ppcFN1cHBvcnRlZCgpIHx8IChvcHRpb25zPy5kaXNhYmxlQ29tcHJlc3Npb24gPz8gZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgbG9nTXNnSWZEZWJ1Zyhmbikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVidWcpIHtcclxuICAgICAgICAgICAgZm4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3cmFwKGZuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dNc2dJZkRlYnVnKCgpID0+IGNvbnNvbGUud2FybignW1Bvc3RIb2ddIFRoZSBjbGllbnQgaXMgZGlzYWJsZWQnKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gTk9URTogV2UgY291bGQgYWxzbyBjaGVjayBmb3IgdGhlIFwib3B0IGluXCIgc3RhdHVzIGhlcmUuLi5cclxuICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2luaXRQcm9taXNlLnRoZW4oKCkgPT4gZm4oKSk7XHJcbiAgICB9XHJcbiAgICBnZXRDb21tb25FdmVudFByb3BlcnRpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJGxpYjogdGhpcy5nZXRMaWJyYXJ5SWQoKSxcclxuICAgICAgICAgICAgJGxpYl92ZXJzaW9uOiB0aGlzLmdldExpYnJhcnlWZXJzaW9uKCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldCBvcHRlZE91dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQZXJzaXN0ZWRQcm9wZXJ0eShQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHkuT3B0ZWRPdXQpID8/ICF0aGlzLmRlZmF1bHRPcHRJbjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9wdEluKCkge1xyXG4gICAgICAgIHRoaXMud3JhcCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGVyc2lzdGVkUHJvcGVydHkoUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5Lk9wdGVkT3V0LCBmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvcHRPdXQoKSB7XHJcbiAgICAgICAgdGhpcy53cmFwKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZXRQZXJzaXN0ZWRQcm9wZXJ0eShQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHkuT3B0ZWRPdXQsIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnQsIGNiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5vbihldmVudCwgY2IpO1xyXG4gICAgfVxyXG4gICAgZGVidWcoZW5hYmxlZCA9IHRydWUpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZURlYnVnQ2FsbGJhY2s/LigpO1xyXG4gICAgICAgIGlmIChlbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZURlYnVnQ2FsbGJhY2sgPSB0aGlzLm9uKCcqJywgKGV2ZW50LCBwYXlsb2FkKSA9PiBjb25zb2xlLmxvZygnUG9zdEhvZyBEZWJ1ZycsIGV2ZW50LCBwYXlsb2FkKSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVidWdDYWxsYmFjayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZURlYnVnQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVidWdDYWxsYmFjayA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgaXNEZWJ1ZygpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLnJlbW92ZURlYnVnQ2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNEaXNhYmxlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZDtcclxuICAgIH1cclxuICAgIGJ1aWxkUGF5bG9hZChwYXlsb2FkKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGlzdGluY3RfaWQ6IHBheWxvYWQuZGlzdGluY3RfaWQsXHJcbiAgICAgICAgICAgIGV2ZW50OiBwYXlsb2FkLmV2ZW50LFxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICAuLi4ocGF5bG9hZC5wcm9wZXJ0aWVzIHx8IHt9KSxcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0Q29tbW9uRXZlbnRQcm9wZXJ0aWVzKCksIC8vIENvbW1vbiBQSCBwcm9wc1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhZGRQZW5kaW5nUHJvbWlzZShwcm9taXNlKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZVVVSUQgPSB1dWlkdjcoKTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdQcm9taXNlc1twcm9taXNlVVVJRF0gPSBwcm9taXNlO1xyXG4gICAgICAgIHByb21pc2VcclxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHsgfSlcclxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nUHJvbWlzZXNbcHJvbWlzZVVVSURdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqKlxyXG4gICAgICoqKiBUUkFDS0lOR1xyXG4gICAgICoqKi9cclxuICAgIGlkZW50aWZ5U3RhdGVsZXNzKGRpc3RpbmN0SWQsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLndyYXAoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBUaGUgcHJvcGVydGllcyBwYXNzZWQgdG8gaWRlbnRpZnlTdGF0ZWxlc3MgYXJlIGV2ZW50IHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgIC8vIFRvIGFkZCBwZXJzb24gcHJvcGVydGllcywgcGFzcyBpbiBhbGwgcGVyc29uIHByb3BlcnRpZXMgdG8gdGhlIGAkc2V0YCBhbmQgYCRzZXRfb25jZWAga2V5cy5cclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMuYnVpbGRQYXlsb2FkKHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0aW5jdF9pZDogZGlzdGluY3RJZCxcclxuICAgICAgICAgICAgICAgICAgICBldmVudDogJyRpZGVudGlmeScsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyxcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmVucXVldWUoJ2lkZW50aWZ5JywgcGF5bG9hZCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBpZGVudGlmeVN0YXRlbGVzc0ltbWVkaWF0ZShkaXN0aW5jdElkLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgICAgICAgLi4udGhpcy5idWlsZFBheWxvYWQoe1xyXG4gICAgICAgICAgICAgICAgZGlzdGluY3RfaWQ6IGRpc3RpbmN0SWQsXHJcbiAgICAgICAgICAgICAgICBldmVudDogJyRpZGVudGlmeScsXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEltbWVkaWF0ZSgnaWRlbnRpZnknLCBwYXlsb2FkLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGNhcHR1cmVTdGF0ZWxlc3MoZGlzdGluY3RJZCwgZXZlbnQsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLndyYXAoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5idWlsZFBheWxvYWQoeyBkaXN0aW5jdF9pZDogZGlzdGluY3RJZCwgZXZlbnQsIHByb3BlcnRpZXMgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZW5xdWV1ZSgnY2FwdHVyZScsIHBheWxvYWQsIG9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgY2FwdHVyZVN0YXRlbGVzc0ltbWVkaWF0ZShkaXN0aW5jdElkLCBldmVudCwgcHJvcGVydGllcywgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLmJ1aWxkUGF5bG9hZCh7IGRpc3RpbmN0X2lkOiBkaXN0aW5jdElkLCBldmVudCwgcHJvcGVydGllcyB9KTtcclxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRJbW1lZGlhdGUoJ2NhcHR1cmUnLCBwYXlsb2FkLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGFsaWFzU3RhdGVsZXNzKGFsaWFzLCBkaXN0aW5jdElkLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy53cmFwKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuYnVpbGRQYXlsb2FkKHtcclxuICAgICAgICAgICAgICAgIGV2ZW50OiAnJGNyZWF0ZV9hbGlhcycsXHJcbiAgICAgICAgICAgICAgICBkaXN0aW5jdF9pZDogZGlzdGluY3RJZCxcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAuLi4ocHJvcGVydGllcyB8fCB7fSksXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGluY3RfaWQ6IGRpc3RpbmN0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXMsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5lbnF1ZXVlKCdhbGlhcycsIHBheWxvYWQsIG9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgYWxpYXNTdGF0ZWxlc3NJbW1lZGlhdGUoYWxpYXMsIGRpc3RpbmN0SWQsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5idWlsZFBheWxvYWQoe1xyXG4gICAgICAgICAgICBldmVudDogJyRjcmVhdGVfYWxpYXMnLFxyXG4gICAgICAgICAgICBkaXN0aW5jdF9pZDogZGlzdGluY3RJZCxcclxuICAgICAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgICAgICAgLi4uKHByb3BlcnRpZXMgfHwge30pLFxyXG4gICAgICAgICAgICAgICAgZGlzdGluY3RfaWQ6IGRpc3RpbmN0SWQsXHJcbiAgICAgICAgICAgICAgICBhbGlhcyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRJbW1lZGlhdGUoJ2FsaWFzJywgcGF5bG9hZCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKioqXHJcbiAgICAgKioqIEdST1VQU1xyXG4gICAgICoqKi9cclxuICAgIGdyb3VwSWRlbnRpZnlTdGF0ZWxlc3MoZ3JvdXBUeXBlLCBncm91cEtleSwgZ3JvdXBQcm9wZXJ0aWVzLCBvcHRpb25zLCBkaXN0aW5jdElkLCBldmVudFByb3BlcnRpZXMpIHtcclxuICAgICAgICB0aGlzLndyYXAoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5idWlsZFBheWxvYWQoe1xyXG4gICAgICAgICAgICAgICAgZGlzdGluY3RfaWQ6IGRpc3RpbmN0SWQgfHwgYCQke2dyb3VwVHlwZX1fJHtncm91cEtleX1gLFxyXG4gICAgICAgICAgICAgICAgZXZlbnQ6ICckZ3JvdXBpZGVudGlmeScsXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJGdyb3VwX3R5cGU6IGdyb3VwVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAkZ3JvdXBfa2V5OiBncm91cEtleSxcclxuICAgICAgICAgICAgICAgICAgICAkZ3JvdXBfc2V0OiBncm91cFByb3BlcnRpZXMgfHwge30sXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uKGV2ZW50UHJvcGVydGllcyB8fCB7fSksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5lbnF1ZXVlKCdjYXB0dXJlJywgcGF5bG9hZCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRSZW1vdGVDb25maWcoKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5faW5pdFByb21pc2U7XHJcbiAgICAgICAgbGV0IGhvc3QgPSB0aGlzLmhvc3Q7XHJcbiAgICAgICAgaWYgKGhvc3QgPT09ICdodHRwczovL3VzLmkucG9zdGhvZy5jb20nKSB7XHJcbiAgICAgICAgICAgIGhvc3QgPSAnaHR0cHM6Ly91cy1hc3NldHMuaS5wb3N0aG9nLmNvbSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhvc3QgPT09ICdodHRwczovL2V1LmkucG9zdGhvZy5jb20nKSB7XHJcbiAgICAgICAgICAgIGhvc3QgPSAnaHR0cHM6Ly9ldS1hc3NldHMuaS5wb3N0aG9nLmNvbSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVybCA9IGAke2hvc3R9L2FycmF5LyR7dGhpcy5hcGlLZXl9L2NvbmZpZ2A7XHJcbiAgICAgICAgY29uc3QgZmV0Y2hPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuZ2V0Q3VzdG9tSGVhZGVycygpLCAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBEb24ndCByZXRyeSByZW1vdGUgY29uZmlnIEFQSSBjYWxsc1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoV2l0aFJldHJ5KHVybCwgZmV0Y2hPcHRpb25zLCB7IHJldHJ5Q291bnQ6IDAgfSwgdGhpcy5yZW1vdGVDb25maWdSZXF1ZXN0VGltZW91dE1zKVxyXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcclxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ01zZ0lmRGVidWcoKCkgPT4gY29uc29sZS5lcnJvcignUmVtb3RlIGNvbmZpZyBjb3VsZCBub3QgYmUgbG9hZGVkJywgZXJyb3IpKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqKlxyXG4gICAgICoqKiBGRUFUVVJFIEZMQUdTXHJcbiAgICAgKioqL1xyXG4gICAgYXN5bmMgZ2V0RmxhZ3MoZGlzdGluY3RJZCwgZ3JvdXBzID0ge30sIHBlcnNvblByb3BlcnRpZXMgPSB7fSwgZ3JvdXBQcm9wZXJ0aWVzID0ge30sIGV4dHJhUGF5bG9hZCA9IHt9KSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5faW5pdFByb21pc2U7XHJcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5ob3N0fS9mbGFncy8/dj0yJmNvbmZpZz10cnVlYDtcclxuICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuZ2V0Q3VzdG9tSGVhZGVycygpLCAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLmFwaUtleSxcclxuICAgICAgICAgICAgICAgIGRpc3RpbmN0X2lkOiBkaXN0aW5jdElkLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXBzLFxyXG4gICAgICAgICAgICAgICAgcGVyc29uX3Byb3BlcnRpZXM6IHBlcnNvblByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgICAgICBncm91cF9wcm9wZXJ0aWVzOiBncm91cFByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgICAgICAuLi5leHRyYVBheWxvYWQsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sb2dNc2dJZkRlYnVnKCgpID0+IGNvbnNvbGUubG9nKCdQb3N0SG9nIERlYnVnJywgJ0ZsYWdzIFVSTCcsIHVybCkpO1xyXG4gICAgICAgIC8vIERvbid0IHJldHJ5IC9mbGFncyBBUEkgY2FsbHNcclxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFdpdGhSZXRyeSh1cmwsIGZldGNoT3B0aW9ucywgeyByZXRyeUNvdW50OiAwIH0sIHRoaXMuZmVhdHVyZUZsYWdzUmVxdWVzdFRpbWVvdXRNcylcclxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXHJcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gbm9ybWFsaXplRmxhZ3NSZXNwb25zZShyZXNwb25zZSkpXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0RmVhdHVyZUZsYWdTdGF0ZWxlc3Moa2V5LCBkaXN0aW5jdElkLCBncm91cHMgPSB7fSwgcGVyc29uUHJvcGVydGllcyA9IHt9LCBncm91cFByb3BlcnRpZXMgPSB7fSwgZGlzYWJsZUdlb2lwKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5faW5pdFByb21pc2U7XHJcbiAgICAgICAgY29uc3QgZmxhZ0RldGFpbFJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRGZWF0dXJlRmxhZ0RldGFpbFN0YXRlbGVzcyhrZXksIGRpc3RpbmN0SWQsIGdyb3VwcywgcGVyc29uUHJvcGVydGllcywgZ3JvdXBQcm9wZXJ0aWVzLCBkaXNhYmxlR2VvaXApO1xyXG4gICAgICAgIGlmIChmbGFnRGV0YWlsUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IGxvYWRlZCBmbGFncyB5ZXQsIG9yIGVycm9yZWQgb3V0LCB3ZSByZXNwb25kIHdpdGggdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXNwb25zZSA9IGdldEZlYXR1cmVGbGFnVmFsdWUoZmxhZ0RldGFpbFJlc3BvbnNlLnJlc3BvbnNlKTtcclxuICAgICAgICBpZiAocmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBGb3IgY2FzZXMgd2hlcmUgdGhlIGZsYWcgaXMgdW5rbm93biwgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgIHJlc3BvbnNlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGhhdmUgZmxhZ3Mgd2UgZWl0aGVyIHJldHVybiB0aGUgdmFsdWUgKHRydWUgb3Igc3RyaW5nKSBvciBmYWxzZVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlLFxyXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IGZsYWdEZXRhaWxSZXNwb25zZS5yZXF1ZXN0SWQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldEZlYXR1cmVGbGFnRGV0YWlsU3RhdGVsZXNzKGtleSwgZGlzdGluY3RJZCwgZ3JvdXBzID0ge30sIHBlcnNvblByb3BlcnRpZXMgPSB7fSwgZ3JvdXBQcm9wZXJ0aWVzID0ge30sIGRpc2FibGVHZW9pcCkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuX2luaXRQcm9taXNlO1xyXG4gICAgICAgIGNvbnN0IGZsYWdzUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldEZlYXR1cmVGbGFnRGV0YWlsc1N0YXRlbGVzcyhkaXN0aW5jdElkLCBncm91cHMsIHBlcnNvblByb3BlcnRpZXMsIGdyb3VwUHJvcGVydGllcywgZGlzYWJsZUdlb2lwLCBba2V5XSk7XHJcbiAgICAgICAgaWYgKGZsYWdzUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmZWF0dXJlRmxhZ3MgPSBmbGFnc1Jlc3BvbnNlLmZsYWdzO1xyXG4gICAgICAgIGNvbnN0IGZsYWdEZXRhaWwgPSBmZWF0dXJlRmxhZ3Nba2V5XTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZXNwb25zZTogZmxhZ0RldGFpbCxcclxuICAgICAgICAgICAgcmVxdWVzdElkOiBmbGFnc1Jlc3BvbnNlLnJlcXVlc3RJZCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0RmVhdHVyZUZsYWdQYXlsb2FkU3RhdGVsZXNzKGtleSwgZGlzdGluY3RJZCwgZ3JvdXBzID0ge30sIHBlcnNvblByb3BlcnRpZXMgPSB7fSwgZ3JvdXBQcm9wZXJ0aWVzID0ge30sIGRpc2FibGVHZW9pcCkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuX2luaXRQcm9taXNlO1xyXG4gICAgICAgIGNvbnN0IHBheWxvYWRzID0gYXdhaXQgdGhpcy5nZXRGZWF0dXJlRmxhZ1BheWxvYWRzU3RhdGVsZXNzKGRpc3RpbmN0SWQsIGdyb3VwcywgcGVyc29uUHJvcGVydGllcywgZ3JvdXBQcm9wZXJ0aWVzLCBkaXNhYmxlR2VvaXAsIFtrZXldKTtcclxuICAgICAgICBpZiAoIXBheWxvYWRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcGF5bG9hZHNba2V5XTtcclxuICAgICAgICAvLyBVbmRlZmluZWQgbWVhbnMgYSBsb2FkaW5nIG9yIG1pc3NpbmcgZGF0YSBpc3N1ZS4gTnVsbCBtZWFucyBldmFsdWF0aW9uIGhhcHBlbmVkIGFuZCB0aGVyZSB3YXMgbm8gbWF0Y2hcclxuICAgICAgICBpZiAocmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0RmVhdHVyZUZsYWdQYXlsb2Fkc1N0YXRlbGVzcyhkaXN0aW5jdElkLCBncm91cHMgPSB7fSwgcGVyc29uUHJvcGVydGllcyA9IHt9LCBncm91cFByb3BlcnRpZXMgPSB7fSwgZGlzYWJsZUdlb2lwLCBmbGFnS2V5c1RvRXZhbHVhdGUpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLl9pbml0UHJvbWlzZTtcclxuICAgICAgICBjb25zdCBwYXlsb2FkcyA9IChhd2FpdCB0aGlzLmdldEZlYXR1cmVGbGFnc0FuZFBheWxvYWRzU3RhdGVsZXNzKGRpc3RpbmN0SWQsIGdyb3VwcywgcGVyc29uUHJvcGVydGllcywgZ3JvdXBQcm9wZXJ0aWVzLCBkaXNhYmxlR2VvaXAsIGZsYWdLZXlzVG9FdmFsdWF0ZSkpLnBheWxvYWRzO1xyXG4gICAgICAgIHJldHVybiBwYXlsb2FkcztcclxuICAgIH1cclxuICAgIGFzeW5jIGdldEZlYXR1cmVGbGFnc1N0YXRlbGVzcyhkaXN0aW5jdElkLCBncm91cHMgPSB7fSwgcGVyc29uUHJvcGVydGllcyA9IHt9LCBncm91cFByb3BlcnRpZXMgPSB7fSwgZGlzYWJsZUdlb2lwLCBmbGFnS2V5c1RvRXZhbHVhdGUpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLl9pbml0UHJvbWlzZTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRGZWF0dXJlRmxhZ3NBbmRQYXlsb2Fkc1N0YXRlbGVzcyhkaXN0aW5jdElkLCBncm91cHMsIHBlcnNvblByb3BlcnRpZXMsIGdyb3VwUHJvcGVydGllcywgZGlzYWJsZUdlb2lwLCBmbGFnS2V5c1RvRXZhbHVhdGUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0RmVhdHVyZUZsYWdzQW5kUGF5bG9hZHNTdGF0ZWxlc3MoZGlzdGluY3RJZCwgZ3JvdXBzID0ge30sIHBlcnNvblByb3BlcnRpZXMgPSB7fSwgZ3JvdXBQcm9wZXJ0aWVzID0ge30sIGRpc2FibGVHZW9pcCwgZmxhZ0tleXNUb0V2YWx1YXRlKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5faW5pdFByb21pc2U7XHJcbiAgICAgICAgY29uc3QgZmVhdHVyZUZsYWdEZXRhaWxzID0gYXdhaXQgdGhpcy5nZXRGZWF0dXJlRmxhZ0RldGFpbHNTdGF0ZWxlc3MoZGlzdGluY3RJZCwgZ3JvdXBzLCBwZXJzb25Qcm9wZXJ0aWVzLCBncm91cFByb3BlcnRpZXMsIGRpc2FibGVHZW9pcCwgZmxhZ0tleXNUb0V2YWx1YXRlKTtcclxuICAgICAgICBpZiAoIWZlYXR1cmVGbGFnRGV0YWlscykge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHBheWxvYWRzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmxhZ3M6IGZlYXR1cmVGbGFnRGV0YWlscy5mZWF0dXJlRmxhZ3MsXHJcbiAgICAgICAgICAgIHBheWxvYWRzOiBmZWF0dXJlRmxhZ0RldGFpbHMuZmVhdHVyZUZsYWdQYXlsb2FkcyxcclxuICAgICAgICAgICAgcmVxdWVzdElkOiBmZWF0dXJlRmxhZ0RldGFpbHMucmVxdWVzdElkLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRGZWF0dXJlRmxhZ0RldGFpbHNTdGF0ZWxlc3MoZGlzdGluY3RJZCwgZ3JvdXBzID0ge30sIHBlcnNvblByb3BlcnRpZXMgPSB7fSwgZ3JvdXBQcm9wZXJ0aWVzID0ge30sIGRpc2FibGVHZW9pcCwgZmxhZ0tleXNUb0V2YWx1YXRlKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5faW5pdFByb21pc2U7XHJcbiAgICAgICAgY29uc3QgZXh0cmFQYXlsb2FkID0ge307XHJcbiAgICAgICAgaWYgKGRpc2FibGVHZW9pcCA/PyB0aGlzLmRpc2FibGVHZW9pcCkge1xyXG4gICAgICAgICAgICBleHRyYVBheWxvYWRbJ2dlb2lwX2Rpc2FibGUnXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmbGFnS2V5c1RvRXZhbHVhdGUpIHtcclxuICAgICAgICAgICAgZXh0cmFQYXlsb2FkWydmbGFnX2tleXNfdG9fZXZhbHVhdGUnXSA9IGZsYWdLZXlzVG9FdmFsdWF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmxhZ3NSZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0RmxhZ3MoZGlzdGluY3RJZCwgZ3JvdXBzLCBwZXJzb25Qcm9wZXJ0aWVzLCBncm91cFByb3BlcnRpZXMsIGV4dHJhUGF5bG9hZCk7XHJcbiAgICAgICAgaWYgKGZsYWdzUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBXZSBwcm9iYWJseSBlcnJvcmVkIG91dCwgc28gcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGVyZSdzIGFuIGVycm9yIG9uIHRoZSBmbGFnc1Jlc3BvbnNlLCBsb2cgYSBjb25zb2xlIGVycm9yLCBidXQgZG9uJ3QgdGhyb3cgYW4gZXJyb3JcclxuICAgICAgICBpZiAoZmxhZ3NSZXNwb25zZS5lcnJvcnNXaGlsZUNvbXB1dGluZ0ZsYWdzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tGRUFUVVJFIEZMQUdTXSBFcnJvciB3aGlsZSBjb21wdXRpbmcgZmVhdHVyZSBmbGFncywgc29tZSBmbGFncyBtYXkgYmUgbWlzc2luZyBvciBpbmNvcnJlY3QuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9wb3N0aG9nLmNvbS9kb2NzL2ZlYXR1cmUtZmxhZ3MvYmVzdC1wcmFjdGljZXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGNoZWNrIGZvciBxdW90YSBsaW1pdGF0aW9uIG9uIGZlYXR1cmUgZmxhZ3NcclxuICAgICAgICBpZiAoZmxhZ3NSZXNwb25zZS5xdW90YUxpbWl0ZWQ/LmluY2x1ZGVzKFF1b3RhTGltaXRlZEZlYXR1cmUuRmVhdHVyZUZsYWdzKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tGRUFUVVJFIEZMQUdTXSBGZWF0dXJlIGZsYWdzIHF1b3RhIGxpbWl0IGV4Y2VlZGVkIC0gZmVhdHVyZSBmbGFncyB1bmF2YWlsYWJsZS4gTGVhcm4gbW9yZSBhYm91dCBiaWxsaW5nIGxpbWl0cyBhdCBodHRwczovL3Bvc3Rob2cuY29tL2RvY3MvYmlsbGluZy9saW1pdHMtYWxlcnRzJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBmbGFnczoge30sXHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlRmxhZ3M6IHt9LFxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZUZsYWdQYXlsb2Fkczoge30sXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IGZsYWdzUmVzcG9uc2U/LnJlcXVlc3RJZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZsYWdzUmVzcG9uc2U7XHJcbiAgICB9XHJcbiAgICAvKioqXHJcbiAgICAgKioqIFNVUlZFWVNcclxuICAgICAqKiovXHJcbiAgICBhc3luYyBnZXRTdXJ2ZXlzU3RhdGVsZXNzKCkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuX2luaXRQcm9taXNlO1xyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVTdXJ2ZXlzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nTXNnSWZEZWJ1ZygoKSA9PiBjb25zb2xlLmxvZygnUG9zdEhvZyBEZWJ1ZycsICdMb2FkaW5nIHN1cnZleXMgaXMgZGlzYWJsZWQuJykpO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuaG9zdH0vYXBpL3N1cnZleXMvP3Rva2VuPSR7dGhpcy5hcGlLZXl9YDtcclxuICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5nZXRDdXN0b21IZWFkZXJzKCksICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhSZXRyeSh1cmwsIGZldGNoT3B0aW9ucylcclxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCB8fCAhcmVzcG9uc2UuanNvbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYFN1cnZleXMgQVBJIGNvdWxkIG5vdCBiZSBsb2FkZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtc2cpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dNc2dJZkRlYnVnKCgpID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtc2cpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nTXNnSWZEZWJ1ZygoKSA9PiBjb25zb2xlLmVycm9yKCdTdXJ2ZXlzIEFQSSBjb3VsZCBub3QgYmUgbG9hZGVkJywgZXJyb3IpKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IG5ld1N1cnZleXMgPSByZXNwb25zZT8uc3VydmV5cztcclxuICAgICAgICBpZiAobmV3U3VydmV5cykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ01zZ0lmRGVidWcoKCkgPT4gY29uc29sZS5sb2coJ1Bvc3RIb2cgRGVidWcnLCAnU3VydmV5cyBmZXRjaGVkIGZyb20gQVBJOiAnLCBKU09OLnN0cmluZ2lmeShuZXdTdXJ2ZXlzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3U3VydmV5cyA/PyBbXTtcclxuICAgIH1cclxuICAgIGdldCBwcm9wcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Byb3BzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzID0gdGhpcy5nZXRQZXJzaXN0ZWRQcm9wZXJ0eShQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHkuUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHMgfHwge307XHJcbiAgICB9XHJcbiAgICBzZXQgcHJvcHModmFsKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvcHMgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBhc3luYyByZWdpc3Rlcihwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdGhpcy53cmFwKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMucHJvcHMsXHJcbiAgICAgICAgICAgICAgICAuLi5wcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnNldFBlcnNpc3RlZFByb3BlcnR5KFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eS5Qcm9wcywgdGhpcy5wcm9wcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyB1bnJlZ2lzdGVyKHByb3BlcnR5KSB7XHJcbiAgICAgICAgdGhpcy53cmFwKCgpID0+IHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucHJvcHNbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB0aGlzLnNldFBlcnNpc3RlZFByb3BlcnR5KFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eS5Qcm9wcywgdGhpcy5wcm9wcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKioqXHJcbiAgICAgKioqIFFVRVVFSU5HIEFORCBGTFVTSElOR1xyXG4gICAgICoqKi9cclxuICAgIGVucXVldWUodHlwZSwgX21lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLndyYXAoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRlZE91dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmVtaXQodHlwZSwgYExpYnJhcnkgaXMgZGlzYWJsZWQuIE5vdCBzZW5kaW5nIGV2ZW50LiBUbyByZS1lbmFibGUsIGNhbGwgcG9zdGhvZy5vcHRJbigpYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMucHJlcGFyZU1lc3NhZ2UodHlwZSwgX21lc3NhZ2UsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMuZ2V0UGVyc2lzdGVkUHJvcGVydHkoUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5LlF1ZXVlKSB8fCBbXTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+PSB0aGlzLm1heFF1ZXVlU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgcXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nTXNnSWZEZWJ1ZygoKSA9PiBjb25zb2xlLmluZm8oJ1F1ZXVlIGlzIGZ1bGwsIHRoZSBvbGRlc3QgZXZlbnQgaXMgZHJvcHBlZC4nKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcXVldWUucHVzaCh7IG1lc3NhZ2UgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGVyc2lzdGVkUHJvcGVydHkoUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5LlF1ZXVlLCBxdWV1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5lbWl0KHR5cGUsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAvLyBGbHVzaCBxdWV1ZWQgZXZlbnRzIGlmIHdlIG1lZXQgdGhlIGZsdXNoQXQgbGVuZ3RoXHJcbiAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPj0gdGhpcy5mbHVzaEF0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQmFja2dyb3VuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZsdXNoSW50ZXJ2YWwgJiYgIXRoaXMuX2ZsdXNoVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXNoVGltZXIgPSBzYWZlU2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoQmFja2dyb3VuZCgpLCB0aGlzLmZsdXNoSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZW5kSW1tZWRpYXRlKHR5cGUsIF9tZXNzYWdlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dNc2dJZkRlYnVnKCgpID0+IGNvbnNvbGUud2FybignW1Bvc3RIb2ddIFRoZSBjbGllbnQgaXMgZGlzYWJsZWQnKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2luaXRQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRlZE91dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuZW1pdCh0eXBlLCBgTGlicmFyeSBpcyBkaXNhYmxlZC4gTm90IHNlbmRpbmcgZXZlbnQuIFRvIHJlLWVuYWJsZSwgY2FsbCBwb3N0aG9nLm9wdEluKClgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICBhcGlfa2V5OiB0aGlzLmFwaUtleSxcclxuICAgICAgICAgICAgYmF0Y2g6IFt0aGlzLnByZXBhcmVNZXNzYWdlKHR5cGUsIF9tZXNzYWdlLCBvcHRpb25zKV0sXHJcbiAgICAgICAgICAgIHNlbnRfYXQ6IGN1cnJlbnRJU09UaW1lKCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5oaXN0b3JpY2FsTWlncmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGRhdGEuaGlzdG9yaWNhbF9taWdyYXRpb24gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5ob3N0fS9iYXRjaC9gO1xyXG4gICAgICAgIGNvbnN0IGd6aXBwZWRQYXlsb2FkID0gIXRoaXMuZGlzYWJsZUNvbXByZXNzaW9uID8gYXdhaXQgZ3ppcENvbXByZXNzKHBheWxvYWQsIHRoaXMuaXNEZWJ1ZykgOiBudWxsO1xyXG4gICAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0Q3VzdG9tSGVhZGVycygpLFxyXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgIC4uLihnemlwcGVkUGF5bG9hZCAhPT0gbnVsbCAmJiB7ICdDb250ZW50LUVuY29kaW5nJzogJ2d6aXAnIH0pLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBib2R5OiBnemlwcGVkUGF5bG9hZCB8fCBwYXlsb2FkLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaFdpdGhSZXRyeSh1cmwsIGZldGNoT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmVtaXQoJ2Vycm9yJywgZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcmVwYXJlTWVzc2FnZSh0eXBlLCBfbWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgIC4uLl9tZXNzYWdlLFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICBsaWJyYXJ5OiB0aGlzLmdldExpYnJhcnlJZCgpLFxyXG4gICAgICAgICAgICBsaWJyYXJ5X3ZlcnNpb246IHRoaXMuZ2V0TGlicmFyeVZlcnNpb24oKSxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBvcHRpb25zPy50aW1lc3RhbXAgPyBvcHRpb25zPy50aW1lc3RhbXAgOiBjdXJyZW50SVNPVGltZSgpLFxyXG4gICAgICAgICAgICB1dWlkOiBvcHRpb25zPy51dWlkID8gb3B0aW9ucy51dWlkIDogdXVpZHY3KCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhZGRHZW9pcERpc2FibGVQcm9wZXJ0eSA9IG9wdGlvbnM/LmRpc2FibGVHZW9pcCA/PyB0aGlzLmRpc2FibGVHZW9pcDtcclxuICAgICAgICBpZiAoYWRkR2VvaXBEaXNhYmxlUHJvcGVydHkpIHtcclxuICAgICAgICAgICAgaWYgKCFtZXNzYWdlLnByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJvcGVydGllcyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1lc3NhZ2VbJ3Byb3BlcnRpZXMnXVsnJGdlb2lwX2Rpc2FibGUnXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXNzYWdlLmRpc3RpbmN0SWQpIHtcclxuICAgICAgICAgICAgbWVzc2FnZS5kaXN0aW5jdF9pZCA9IG1lc3NhZ2UuZGlzdGluY3RJZDtcclxuICAgICAgICAgICAgZGVsZXRlIG1lc3NhZ2UuZGlzdGluY3RJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBjbGVhckZsdXNoVGltZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsdXNoVGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2ZsdXNoVGltZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9mbHVzaFRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZvciBmbHVzaGluZyB0aGUgcXVldWUgaW4gdGhlIGJhY2tncm91bmRcclxuICAgICAqIEF2b2lkcyB1bm5lY2Vzc2FyeSBwcm9taXNlIGVycm9yc1xyXG4gICAgICovXHJcbiAgICBmbHVzaEJhY2tncm91bmQoKSB7XHJcbiAgICAgICAgdm9pZCB0aGlzLmZsdXNoKCkuY2F0Y2goYXN5bmMgKGVycikgPT4ge1xyXG4gICAgICAgICAgICBhd2FpdCBsb2dGbHVzaEVycm9yKGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZsdXNoZXMgdGhlIHF1ZXVlXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiB0aGUgZmx1c2ggaXMgY29tcGxldGUsXHJcbiAgICAgKiBvciByZWplY3QgaWYgdGhlcmUgd2FzIGFuIGVycm9yIChmb3IgZXhhbXBsZSBpZiB0aGUgc2VydmVyIG9yIG5ldHdvcmsgaXMgZG93bikuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlcmUgaXMgYWxyZWFkeSBhIGZsdXNoIGluIHByb2dyZXNzLCB0aGlzIGZ1bmN0aW9uIHdpbGwgd2FpdCBmb3IgdGhhdCBmbHVzaCB0byBjb21wbGV0ZS5cclxuICAgICAqXHJcbiAgICAgKiBJdCdzIHJlY29tbWVuZGVkIHRvIGRvIGVycm9yIGhhbmRsaW5nIGluIHRoZSBjYWxsYmFjayBvZiB0aGUgcHJvbWlzZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcG9zdGhvZy5mbHVzaCgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICogICBjb25zb2xlLmxvZygnRmx1c2ggY29tcGxldGUnKVxyXG4gICAgICogfSkuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICogICBjb25zb2xlLmVycm9yKCdGbHVzaCBmYWlsZWQnLCBlcnIpXHJcbiAgICAgKiB9KVxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIFBvc3RIb2dGZXRjaEh0dHBFcnJvclxyXG4gICAgICogQHRocm93cyBQb3N0SG9nRmV0Y2hOZXR3b3JrRXJyb3JcclxuICAgICAqIEB0aHJvd3MgRXJyb3JcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmx1c2goKSB7XHJcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGN1cnJlbnQgZmx1c2ggb3BlcmF0aW9uIHRvIGZpbmlzaCAocmVnYXJkbGVzcyBvZiBzdWNjZXNzIG9yIGZhaWx1cmUpLCB0aGVuIHRyeSB0byBmbHVzaCBhZ2Fpbi5cclxuICAgICAgICAvLyBVc2UgYWxsU2V0dGxlZCBpbnN0ZWFkIG9mIGZpbmFsbHkgdG8gYmUgZGVmZW5zaXZlIGFyb3VuZCBmbHVzaCB0aHJvd2luZyBlcnJvcnMgaW1tZWRpYXRlbHkgcmF0aGVyIHRoYW4gcmVqZWN0aW5nLlxyXG4gICAgICAgIC8vIFVzZSBhIGN1c3RvbSBhbGxTZXR0bGVkIGltcGxlbWVudGF0aW9uIHRvIGF2b2lkIGlzc3VlcyB3aXRoIHBhdGNoaW5nIFByb21pc2Ugb24gUk5cclxuICAgICAgICBjb25zdCBuZXh0Rmx1c2hQcm9taXNlID0gYWxsU2V0dGxlZChbdGhpcy5mbHVzaFByb21pc2VdKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZsdXNoKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5mbHVzaFByb21pc2UgPSBuZXh0Rmx1c2hQcm9taXNlO1xyXG4gICAgICAgIHZvaWQgdGhpcy5hZGRQZW5kaW5nUHJvbWlzZShuZXh0Rmx1c2hQcm9taXNlKTtcclxuICAgICAgICBhbGxTZXR0bGVkKFtuZXh0Rmx1c2hQcm9taXNlXSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlcnMgd2FpdGluZyB0byBmbHVzaCwgY2xlYXIgdGhlIHByb21pc2UuXHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHN0cmljdGx5IG5lZWQgdG8gZG8gdGhpcywgYnV0IGl0IGNvdWxkIG1ha2UgZGVidWdnaW5nIGVhc2llclxyXG4gICAgICAgICAgICBpZiAodGhpcy5mbHVzaFByb21pc2UgPT09IG5leHRGbHVzaFByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXh0Rmx1c2hQcm9taXNlO1xyXG4gICAgfVxyXG4gICAgZ2V0Q3VzdG9tSGVhZGVycygpIHtcclxuICAgICAgICAvLyBEb24ndCBzZXQgdGhlIHVzZXIgYWdlbnQgaWYgd2UncmUgbm90IG9uIGEgYnJvd3Nlci4gVGhlIGxhdGVzdCBzcGVjIGFsbG93c1xyXG4gICAgICAgIC8vIHRoZSBVc2VyLUFnZW50IGhlYWRlciAoc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyN0ZXJtaW5vbG9neS1oZWFkZXJzXHJcbiAgICAgICAgLy8gYW5kIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9zZXRSZXF1ZXN0SGVhZGVyKSxcclxuICAgICAgICAvLyBidXQgYnJvd3NlcnMgc3VjaCBhcyBDaHJvbWUgYW5kIFNhZmFyaSBoYXZlIG5vdCBjYXVnaHQgdXAuXHJcbiAgICAgICAgY29uc3QgY3VzdG9tVXNlckFnZW50ID0gdGhpcy5nZXRDdXN0b21Vc2VyQWdlbnQoKTtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XHJcbiAgICAgICAgaWYgKGN1c3RvbVVzZXJBZ2VudCAmJiBjdXN0b21Vc2VyQWdlbnQgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnNbJ1VzZXItQWdlbnQnXSA9IGN1c3RvbVVzZXJBZ2VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBfZmx1c2goKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckZsdXNoVGltZXIoKTtcclxuICAgICAgICBhd2FpdCB0aGlzLl9pbml0UHJvbWlzZTtcclxuICAgICAgICBsZXQgcXVldWUgPSB0aGlzLmdldFBlcnNpc3RlZFByb3BlcnR5KFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eS5RdWV1ZSkgfHwgW107XHJcbiAgICAgICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzZW50TWVzc2FnZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFF1ZXVlTGVuZ3RoID0gcXVldWUubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwICYmIHNlbnRNZXNzYWdlcy5sZW5ndGggPCBvcmlnaW5hbFF1ZXVlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoSXRlbXMgPSBxdWV1ZS5zbGljZSgwLCB0aGlzLm1heEJhdGNoU2l6ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoTWVzc2FnZXMgPSBiYXRjaEl0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgY29uc3QgcGVyc2lzdFF1ZXVlQ2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVmcmVzaGVkUXVldWUgPSB0aGlzLmdldFBlcnNpc3RlZFByb3BlcnR5KFBvc3RIb2dQZXJzaXN0ZWRQcm9wZXJ0eS5RdWV1ZSkgfHwgW107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdRdWV1ZSA9IHJlZnJlc2hlZFF1ZXVlLnNsaWNlKGJhdGNoSXRlbXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGVyc2lzdGVkUHJvcGVydHkoUG9zdEhvZ1BlcnNpc3RlZFByb3BlcnR5LlF1ZXVlLCBuZXdRdWV1ZSk7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IG5ld1F1ZXVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgYXBpX2tleTogdGhpcy5hcGlLZXksXHJcbiAgICAgICAgICAgICAgICBiYXRjaDogYmF0Y2hNZXNzYWdlcyxcclxuICAgICAgICAgICAgICAgIHNlbnRfYXQ6IGN1cnJlbnRJU09UaW1lKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhpc3RvcmljYWxNaWdyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGRhdGEuaGlzdG9yaWNhbF9taWdyYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5ob3N0fS9iYXRjaC9gO1xyXG4gICAgICAgICAgICBjb25zdCBnemlwcGVkUGF5bG9hZCA9ICF0aGlzLmRpc2FibGVDb21wcmVzc2lvbiA/IGF3YWl0IGd6aXBDb21wcmVzcyhwYXlsb2FkLCB0aGlzLmlzRGVidWcpIDogbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgZmV0Y2hPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5nZXRDdXN0b21IZWFkZXJzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgICAgICAuLi4oZ3ppcHBlZFBheWxvYWQgIT09IG51bGwgJiYgeyAnQ29udGVudC1FbmNvZGluZyc6ICdnemlwJyB9KSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBib2R5OiBnemlwcGVkUGF5bG9hZCB8fCBwYXlsb2FkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCByZXRyeU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICByZXRyeUNoZWNrOiAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgYXV0b21hdGljYWxseSByZXRyeSBvbiA0MTMgZXJyb3JzLCB3ZSB3YW50IHRvIHJlZHVjZSB0aGUgYmF0Y2ggc2l6ZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Bvc3RIb2dGZXRjaENvbnRlbnRUb29MYXJnZUVycm9yKGVycikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIHJldHJ5IG9uIG5ldHdvcmsgZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzUG9zdEhvZ0ZldGNoRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZldGNoV2l0aFJldHJ5KHVybCwgZmV0Y2hPcHRpb25zLCByZXRyeU9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1Bvc3RIb2dGZXRjaENvbnRlbnRUb29MYXJnZUVycm9yKGVycikgJiYgYmF0Y2hNZXNzYWdlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZ2V0IGEgNDEzIGVycm9yLCB3ZSB3YW50IHRvIHJlZHVjZSB0aGUgYmF0Y2ggc2l6ZSBhbmQgdHJ5IGFnYWluXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhCYXRjaFNpemUgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGJhdGNoTWVzc2FnZXMubGVuZ3RoIC8gMikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nTXNnSWZEZWJ1ZygoKSA9PiBjb25zb2xlLndhcm4oYFJlY2VpdmVkIDQxMyB3aGVuIHNlbmRpbmcgYmF0Y2ggb2Ygc2l6ZSAke2JhdGNoTWVzc2FnZXMubGVuZ3RofSwgcmVkdWNpbmcgYmF0Y2ggc2l6ZSB0byAke3RoaXMubWF4QmF0Y2hTaXplfWApKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgcGVyc2lzdCB0aGUgcXVldWUgY2hhbmdlLCB3ZSB3YW50IHRvIHJldHJ5IHRoZSBzYW1lIGJhdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBkZXBlbmRpbmcgb24gdGhlIGVycm9yIHR5cGUsIGVnIGEgbWFsZm9ybWVkIEpTT04gb3IgYnJva2VuIHF1ZXVlLCBpdCdsbCBhbHdheXMgcmV0dXJuIGFuIGVycm9yXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhpcyB3aWxsIGJlIGFuIGVuZGxlc3MgbG9vcCwgaW4gdGhpcyBjYXNlLCBpZiB0aGUgZXJyb3IgaXNuJ3QgYSBuZXR3b3JrIGlzc3VlLCB3ZSBhbHdheXMgcmVtb3ZlIHRoZSBpdGVtcyBmcm9tIHRoZSBxdWV1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgUG9zdEhvZ0ZldGNoTmV0d29ya0Vycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RRdWV1ZUNoYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmVtaXQoJ2Vycm9yJywgZXJyKTtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwZXJzaXN0UXVldWVDaGFuZ2UoKTtcclxuICAgICAgICAgICAgc2VudE1lc3NhZ2VzLnB1c2goLi4uYmF0Y2hNZXNzYWdlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5lbWl0KCdmbHVzaCcsIHNlbnRNZXNzYWdlcyk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBmZXRjaFdpdGhSZXRyeSh1cmwsIG9wdGlvbnMsIHJldHJ5T3B0aW9ucywgcmVxdWVzdFRpbWVvdXQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gQWJvcnRTaWduYWwpLnRpbWVvdXQgPz8gKF9hLnRpbWVvdXQgPSBmdW5jdGlvbiB0aW1lb3V0KG1zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0cmwgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY3RybC5hYm9ydCgpLCBtcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdHJsLnNpZ25hbDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5ID8gb3B0aW9ucy5ib2R5IDogJyc7XHJcbiAgICAgICAgbGV0IHJlcUJ5dGVMZW5ndGggPSAtMTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoYm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcclxuICAgICAgICAgICAgICAgIHJlcUJ5dGVMZW5ndGggPSBib2R5LnNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXFCeXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoYm9keSwgU1RSSU5HX0ZPUk1BVCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2gge1xyXG4gICAgICAgICAgICBpZiAoYm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcclxuICAgICAgICAgICAgICAgIHJlcUJ5dGVMZW5ndGggPSBib2R5LnNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgcmVxQnl0ZUxlbmd0aCA9IGVuY29kZWQubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCByZXRyaWFibGUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gbnVsbDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IHRoaXMuZmV0Y2godXJsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHJlcXVlc3RUaW1lb3V0ID8/IHRoaXMucmVxdWVzdFRpbWVvdXQpLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmV0Y2ggd2lsbCBvbmx5IHRocm93IG9uIG5ldHdvcmsgZXJyb3JzIG9yIG9uIHRpbWVvdXRzXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUG9zdEhvZ0ZldGNoTmV0d29ya0Vycm9yKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIG5vLWNvcnMgbW9kZSwgd2UgY2FuJ3QgYWNjZXNzIHRoZSByZXNwb25zZSBzdGF0dXNcclxuICAgICAgICAgICAgLy8gV2Ugb25seSB0aHJvdyBvbiBIVFRQIGVycm9ycyBpZiB3ZSdyZSBub3QgaW4gbm8tY29ycyBtb2RlXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXF1ZXN0L21vZGUjbm8tY29yc1xyXG4gICAgICAgICAgICBjb25zdCBpc05vQ29ycyA9IG9wdGlvbnMubW9kZSA9PT0gJ25vLWNvcnMnO1xyXG4gICAgICAgICAgICBpZiAoIWlzTm9Db3JzICYmIChyZXMuc3RhdHVzIDwgMjAwIHx8IHJlcy5zdGF0dXMgPj0gNDAwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBvc3RIb2dGZXRjaEh0dHBFcnJvcihyZXMsIHJlcUJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSwgeyAuLi50aGlzLl9yZXRyeU9wdGlvbnMsIC4uLnJldHJ5T3B0aW9ucyB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9zaHV0ZG93bihzaHV0ZG93blRpbWVvdXRNcyA9IDMwMDAwKSB7XHJcbiAgICAgICAgLy8gQSBsaXR0bGUgdHJpY2t5IC0gd2Ugd2FudCB0byBoYXZlIGEgbWF4IHNodXRkb3duIHRpbWUgYW5kIGVuZm9yY2UgaXQsIGV2ZW4gaWYgdGhhdCBtZWFucyB3ZSBoYXZlIHNvbWVcclxuICAgICAgICAvLyBkYW5nbGluZyBwcm9taXNlcy4gV2UnbGwga2VlcCB0cmFjayBvZiB0aGUgdGltZW91dCBhbmQgcmVzb2x2ZS9yZWplY3QgYmFzZWQgb24gdGhhdC5cclxuICAgICAgICBhd2FpdCB0aGlzLl9pbml0UHJvbWlzZTtcclxuICAgICAgICBsZXQgaGFzVGltZWRPdXQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNsZWFyRmx1c2hUaW1lcigpO1xyXG4gICAgICAgIGNvbnN0IGRvU2h1dGRvd24gPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKHRoaXMucGVuZGluZ1Byb21pc2VzKSk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5nZXRQZXJzaXN0ZWRQcm9wZXJ0eShQb3N0SG9nUGVyc2lzdGVkUHJvcGVydHkuUXVldWUpIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoIGFnYWluIHRvIG1ha2Ugc3VyZSB3ZSBzZW5kIGFsbCBldmVudHMsIHNvbWUgb2Ygd2hpY2ggbWlnaHQndmUgYmVlbiBhZGRlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIHdlIHdlcmUgd2FpdGluZyBmb3IgdGhlIHBlbmRpbmcgcHJvbWlzZXMgdG8gcmVzb2x2ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCBzZWUgc2VuZEZlYXR1cmVGbGFncyBpbiBwb3N0aG9nLW5vZGUvc3JjL3Bvc3Rob2ctbm9kZS50czo6Y2FwdHVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmx1c2goKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVGltZWRPdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzUG9zdEhvZ0ZldGNoRXJyb3IoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXdhaXQgbG9nRmx1c2hFcnJvcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXHJcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIHNhZmVTZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ01zZ0lmRGVidWcoKCkgPT4gY29uc29sZS5lcnJvcignVGltZWQgb3V0IHdoaWxlIHNodXR0aW5nIGRvd24gUG9zdEhvZycpKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNUaW1lZE91dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCdUaW1lb3V0IHdoaWxlIHNodXR0aW5nIGRvd24gUG9zdEhvZy4gU29tZSBldmVudHMgbWF5IG5vdCBoYXZlIGJlZW4gc2VudC4nKTtcclxuICAgICAgICAgICAgICAgIH0sIHNodXRkb3duVGltZW91dE1zKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIGRvU2h1dGRvd24oKSxcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIENhbGwgc2h1dGRvd24oKSBvbmNlIGJlZm9yZSB0aGUgbm9kZSBwcm9jZXNzIGV4aXRzLCBzbyBlbnN1cmUgdGhhdCBhbGwgZXZlbnRzIGhhdmUgYmVlbiBzZW50IGFuZCBhbGwgcHJvbWlzZXNcclxuICAgICAqICBoYXZlIHJlc29sdmVkLiBEbyBub3QgdXNlIHRoaXMgZnVuY3Rpb24gaWYgeW91IGludGVuZCB0byBrZWVwIHVzaW5nIHRoaXMgUG9zdEhvZyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGl0LlxyXG4gICAgICogQHBhcmFtIHNodXRkb3duVGltZW91dE1zXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHNodXRkb3duKHNodXRkb3duVGltZW91dE1zID0gMzAwMDApIHtcclxuICAgICAgICBpZiAodGhpcy5zaHV0ZG93blByb21pc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dNc2dJZkRlYnVnKCgpID0+IGNvbnNvbGUud2Fybignc2h1dGRvd24oKSBjYWxsZWQgd2hpbGUgYWxyZWFkeSBzaHV0dGluZyBkb3duLiBzaHV0ZG93bigpIGlzIG1lYW50IHRvIGJlIGNhbGxlZCBvbmNlIGJlZm9yZSBwcm9jZXNzIGV4aXQgLSB1c2UgZmx1c2goKSBmb3IgcGVyLXJlcXVlc3QgY2xlYW51cCcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2h1dGRvd25Qcm9taXNlID0gdGhpcy5fc2h1dGRvd24oc2h1dGRvd25UaW1lb3V0TXMpLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaHV0ZG93blByb21pc2UgPSBudWxsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2h1dGRvd25Qcm9taXNlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBBIGxhenkgdmFsdWUgdGhhdCBpcyBvbmx5IGNvbXB1dGVkIHdoZW4gbmVlZGVkLiBJbnNwaXJlZCBieSBDIydzIExhenk8VD4gY2xhc3MuXHJcbiAqL1xuY2xhc3MgTGF6eSB7XG4gIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICB9XG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHZhbHVlLCBpbml0aWFsaXppbmcgaXQgaWYgbmVjZXNzYXJ5LlxyXG4gICAqIE11bHRpcGxlIGNvbmN1cnJlbnQgY2FsbHMgd2lsbCBzaGFyZSB0aGUgc2FtZSBpbml0aWFsaXphdGlvbiBwcm9taXNlLlxyXG4gICAqL1xuICBhc3luYyBnZXRWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmZhY3RvcnkoKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gQ2xlYXIgdGhlIHByb21pc2Ugc28gd2UgY2FuIHJldHJ5IGlmIG5lZWRlZFxuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbml0aWFsaXphdGlvblByb21pc2U7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBoYXMgYmVlbiBpbml0aWFsaXplZC5cclxuICAgKi9cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgdmFsdWUgaXMgaW5pdGlhbGl6ZWQuXHJcbiAgICogSWYgYWxyZWFkeSBpbml0aWFsaXplZCwgcmVzb2x2ZXMgaW1tZWRpYXRlbHkuXHJcbiAgICovXG4gIGFzeW5jIHdhaXRGb3JJbml0aWFsaXphdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5nZXRWYWx1ZSgpO1xuICB9XG59XG5cbi8vLyA8cmVmZXJlbmNlIGxpYj1cImRvbVwiIC8+XG5jb25zdCBub2RlQ3J5cHRvID0gbmV3IExhenkoYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBpbXBvcnQoJ2NyeXB0bycpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KTtcbmFzeW5jIGZ1bmN0aW9uIGdldE5vZGVDcnlwdG8oKSB7XG4gIHJldHVybiBhd2FpdCBub2RlQ3J5cHRvLmdldFZhbHVlKCk7XG59XG5jb25zdCB3ZWJDcnlwdG8gPSBuZXcgTGF6eShhc3luYyAoKSA9PiB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8/LnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gTm9kZS5qczogdXNlIGJ1aWx0LWluIHdlYmNyeXB0byBhbmQgYXNzaWduIGl0IGlmIG5lZWRlZFxuICAgIGNvbnN0IGNyeXB0byA9IGF3YWl0IG5vZGVDcnlwdG8uZ2V0VmFsdWUoKTtcbiAgICBpZiAoY3J5cHRvPy53ZWJjcnlwdG8/LnN1YnRsZSkge1xuICAgICAgcmV0dXJuIGNyeXB0by53ZWJjcnlwdG8uc3VidGxlO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gSWdub3JlIGlmIG5vdCBhdmFpbGFibGVcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufSk7XG5hc3luYyBmdW5jdGlvbiBnZXRXZWJDcnlwdG8oKSB7XG4gIHJldHVybiBhd2FpdCB3ZWJDcnlwdG8uZ2V0VmFsdWUoKTtcbn1cblxuLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbmFzeW5jIGZ1bmN0aW9uIGhhc2hTSEExKHRleHQpIHtcbiAgLy8gVHJ5IE5vZGUuanMgY3J5cHRvIGZpcnN0XG4gIGNvbnN0IG5vZGVDcnlwdG8gPSBhd2FpdCBnZXROb2RlQ3J5cHRvKCk7XG4gIGlmIChub2RlQ3J5cHRvKSB7XG4gICAgcmV0dXJuIG5vZGVDcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZSh0ZXh0KS5kaWdlc3QoJ2hleCcpO1xuICB9XG4gIGNvbnN0IHdlYkNyeXB0byA9IGF3YWl0IGdldFdlYkNyeXB0bygpO1xuICAvLyBGYWxsIGJhY2sgdG8gV2ViIENyeXB0byBBUElcbiAgaWYgKHdlYkNyeXB0bykge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSBhd2FpdCB3ZWJDcnlwdG8uZGlnZXN0KCdTSEEtMScsIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0KSk7XG4gICAgY29uc3QgaGFzaEFycmF5ID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShoYXNoQnVmZmVyKSk7XG4gICAgcmV0dXJuIGhhc2hBcnJheS5tYXAoYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNyeXB0byBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUuIFRyaWVkIE5vZGUgQ3J5cHRvIEFQSSBhbmQgV2ViIFN1YnRsZUNyeXB0byBBUEknKTtcbn1cblxuY29uc3QgU0lYVFlfU0VDT05EUyA9IDYwICogMTAwMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuY29uc3QgTE9OR19TQ0FMRSA9IDB4ZmZmZmZmZmZmZmZmZmZmO1xuY29uc3QgTlVMTF9WQUxVRVNfQUxMT1dFRF9PUEVSQVRPUlMgPSBbJ2lzX25vdCddO1xuY2xhc3MgQ2xpZW50RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIHRoaXMubmFtZSA9ICdDbGllbnRFcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ2xpZW50RXJyb3IucHJvdG90eXBlKTtcbiAgfVxufVxuY2xhc3MgSW5jb25jbHVzaXZlTWF0Y2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAvLyBpbnN0YW5jZW9mIGRvZXNuJ3Qgd29yayBpbiBFUzMgb3IgRVM1XG4gICAgLy8gaHR0cHM6Ly93d3cuZGFubnlndW8uY29tL2Jsb2cvaG93LXRvLWZpeC1pbnN0YW5jZW9mLW5vdC13b3JraW5nLWZvci1jdXN0b20tZXJyb3JzLWluLXR5cGVzY3JpcHQvXG4gICAgLy8gdGhpcyBpcyB0aGUgd29ya2Fyb3VuZFxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBJbmNvbmNsdXNpdmVNYXRjaEVycm9yLnByb3RvdHlwZSk7XG4gIH1cbn1cbmNsYXNzIEZlYXR1cmVGbGFnc1BvbGxlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwb2xsaW5nSW50ZXJ2YWwsXG4gICAgcGVyc29uYWxBcGlLZXksXG4gICAgcHJvamVjdEFwaUtleSxcbiAgICB0aW1lb3V0LFxuICAgIGhvc3QsXG4gICAgY3VzdG9tSGVhZGVycyxcbiAgICAuLi5vcHRpb25zXG4gIH0pIHtcbiAgICB0aGlzLmRlYnVnTW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuc2hvdWxkQmVnaW5FeHBvbmVudGlhbEJhY2tvZmYgPSBmYWxzZTtcbiAgICB0aGlzLmJhY2tPZmZDb3VudCA9IDA7XG4gICAgdGhpcy5wb2xsaW5nSW50ZXJ2YWwgPSBwb2xsaW5nSW50ZXJ2YWw7XG4gICAgdGhpcy5wZXJzb25hbEFwaUtleSA9IHBlcnNvbmFsQXBpS2V5O1xuICAgIHRoaXMuZmVhdHVyZUZsYWdzID0gW107XG4gICAgdGhpcy5mZWF0dXJlRmxhZ3NCeUtleSA9IHt9O1xuICAgIHRoaXMuZ3JvdXBUeXBlTWFwcGluZyA9IHt9O1xuICAgIHRoaXMuY29ob3J0cyA9IHt9O1xuICAgIHRoaXMubG9hZGVkU3VjY2Vzc2Z1bGx5T25jZSA9IGZhbHNlO1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgdGhpcy5wcm9qZWN0QXBpS2V5ID0gcHJvamVjdEFwaUtleTtcbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIHRoaXMucG9sbGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZmV0Y2ggPSBvcHRpb25zLmZldGNoIHx8IGZldGNoO1xuICAgIHRoaXMub25FcnJvciA9IG9wdGlvbnMub25FcnJvcjtcbiAgICB0aGlzLmN1c3RvbUhlYWRlcnMgPSBjdXN0b21IZWFkZXJzO1xuICAgIHRoaXMub25Mb2FkID0gb3B0aW9ucy5vbkxvYWQ7XG4gICAgdm9pZCB0aGlzLmxvYWRGZWF0dXJlRmxhZ3MoKTtcbiAgfVxuICBkZWJ1ZyhlbmFibGVkID0gdHJ1ZSkge1xuICAgIHRoaXMuZGVidWdNb2RlID0gZW5hYmxlZDtcbiAgfVxuICBsb2dNc2dJZkRlYnVnKGZuKSB7XG4gICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICBmbigpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRGZWF0dXJlRmxhZyhrZXksIGRpc3RpbmN0SWQsIGdyb3VwcyA9IHt9LCBwZXJzb25Qcm9wZXJ0aWVzID0ge30sIGdyb3VwUHJvcGVydGllcyA9IHt9KSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkRmVhdHVyZUZsYWdzKCk7XG4gICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgIGxldCBmZWF0dXJlRmxhZyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoIXRoaXMubG9hZGVkU3VjY2Vzc2Z1bGx5T25jZSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBmZWF0dXJlRmxhZyA9IHRoaXMuZmVhdHVyZUZsYWdzQnlLZXlba2V5XTtcbiAgICBpZiAoZmVhdHVyZUZsYWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbXB1dGVGbGFnTG9jYWxseShmZWF0dXJlRmxhZywgZGlzdGluY3RJZCwgZ3JvdXBzLCBwZXJzb25Qcm9wZXJ0aWVzLCBncm91cFByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLmxvZ01zZ0lmRGVidWcoKCkgPT4gY29uc29sZS5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IGNvbXB1dGVkIGZsYWcgbG9jYWxseTogJHtrZXl9IC0+ICR7cmVzcG9uc2V9YCkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEluY29uY2x1c2l2ZU1hdGNoRXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmxvZ01zZ0lmRGVidWcoKCkgPT4gY29uc29sZS5kZWJ1ZyhgSW5jb25jbHVzaXZlTWF0Y2hFcnJvciB3aGVuIGNvbXB1dGluZyBmbGFnIGxvY2FsbHk6ICR7a2V5fTogJHtlfWApKTtcbiAgICAgICAgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICB0aGlzLm9uRXJyb3I/LihuZXcgRXJyb3IoYEVycm9yIGNvbXB1dGluZyBmbGFnIGxvY2FsbHk6ICR7a2V5fTogJHtlfWApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgY29tcHV0ZUZlYXR1cmVGbGFnUGF5bG9hZExvY2FsbHkoa2V5LCBtYXRjaFZhbHVlKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkRmVhdHVyZUZsYWdzKCk7XG4gICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgIGlmICghdGhpcy5sb2FkZWRTdWNjZXNzZnVsbHlPbmNlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1hdGNoVmFsdWUgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXNwb25zZSA9IHRoaXMuZmVhdHVyZUZsYWdzQnlLZXk/LltrZXldPy5maWx0ZXJzPy5wYXlsb2Fkcz8uW21hdGNoVmFsdWUudG9TdHJpbmcoKV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWF0Y2hWYWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgcmVzcG9uc2UgPSB0aGlzLmZlYXR1cmVGbGFnc0J5S2V5Py5ba2V5XT8uZmlsdGVycz8ucGF5bG9hZHM/LlttYXRjaFZhbHVlXTtcbiAgICB9XG4gICAgLy8gVW5kZWZpbmVkIG1lYW5zIGEgbG9hZGluZyBvciBtaXNzaW5nIGRhdGEgaXNzdWUuIE51bGwgbWVhbnMgZXZhbHVhdGlvbiBoYXBwZW5lZCBhbmQgdGhlcmUgd2FzIG5vIG1hdGNoXG4gICAgaWYgKHJlc3BvbnNlID09PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRBbGxGbGFnc0FuZFBheWxvYWRzKGRpc3RpbmN0SWQsIGdyb3VwcyA9IHt9LCBwZXJzb25Qcm9wZXJ0aWVzID0ge30sIGdyb3VwUHJvcGVydGllcyA9IHt9LCBmbGFnS2V5c1RvRXhwbGljaXRseUV2YWx1YXRlKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkRmVhdHVyZUZsYWdzKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB7fTtcbiAgICBjb25zdCBwYXlsb2FkcyA9IHt9O1xuICAgIGxldCBmYWxsYmFja1RvRmxhZ3MgPSB0aGlzLmZlYXR1cmVGbGFncy5sZW5ndGggPT0gMDtcbiAgICBjb25zdCBmbGFnc1RvRXZhbHVhdGUgPSBmbGFnS2V5c1RvRXhwbGljaXRseUV2YWx1YXRlID8gZmxhZ0tleXNUb0V4cGxpY2l0bHlFdmFsdWF0ZS5tYXAoa2V5ID0+IHRoaXMuZmVhdHVyZUZsYWdzQnlLZXlba2V5XSkuZmlsdGVyKEJvb2xlYW4pIDogdGhpcy5mZWF0dXJlRmxhZ3M7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoZmxhZ3NUb0V2YWx1YXRlLm1hcChhc3luYyBmbGFnID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1hdGNoVmFsdWUgPSBhd2FpdCB0aGlzLmNvbXB1dGVGbGFnTG9jYWxseShmbGFnLCBkaXN0aW5jdElkLCBncm91cHMsIHBlcnNvblByb3BlcnRpZXMsIGdyb3VwUHJvcGVydGllcyk7XG4gICAgICAgIHJlc3BvbnNlW2ZsYWcua2V5XSA9IG1hdGNoVmFsdWU7XG4gICAgICAgIGNvbnN0IG1hdGNoUGF5bG9hZCA9IGF3YWl0IHRoaXMuY29tcHV0ZUZlYXR1cmVGbGFnUGF5bG9hZExvY2FsbHkoZmxhZy5rZXksIG1hdGNoVmFsdWUpO1xuICAgICAgICBpZiAobWF0Y2hQYXlsb2FkKSB7XG4gICAgICAgICAgcGF5bG9hZHNbZmxhZy5rZXldID0gbWF0Y2hQYXlsb2FkO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgSW5jb25jbHVzaXZlTWF0Y2hFcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nTXNnSWZEZWJ1ZygoKSA9PiBjb25zb2xlLmRlYnVnKGBJbmNvbmNsdXNpdmVNYXRjaEVycm9yIHdoZW4gY29tcHV0aW5nIGZsYWcgbG9jYWxseTogJHtmbGFnLmtleX06ICR7ZX1gKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgdGhpcy5vbkVycm9yPy4obmV3IEVycm9yKGBFcnJvciBjb21wdXRpbmcgZmxhZyBsb2NhbGx5OiAke2ZsYWcua2V5fTogJHtlfWApKTtcbiAgICAgICAgfVxuICAgICAgICBmYWxsYmFja1RvRmxhZ3MgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBwYXlsb2FkcyxcbiAgICAgIGZhbGxiYWNrVG9GbGFnc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgY29tcHV0ZUZsYWdMb2NhbGx5KGZsYWcsIGRpc3RpbmN0SWQsIGdyb3VwcyA9IHt9LCBwZXJzb25Qcm9wZXJ0aWVzID0ge30sIGdyb3VwUHJvcGVydGllcyA9IHt9KSB7XG4gICAgaWYgKGZsYWcuZW5zdXJlX2V4cGVyaWVuY2VfY29udGludWl0eSkge1xuICAgICAgdGhyb3cgbmV3IEluY29uY2x1c2l2ZU1hdGNoRXJyb3IoJ0ZsYWcgaGFzIGV4cGVyaWVuY2UgY29udGludWl0eSBlbmFibGVkJyk7XG4gICAgfVxuICAgIGlmICghZmxhZy5hY3RpdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZmxhZ0ZpbHRlcnMgPSBmbGFnLmZpbHRlcnMgfHwge307XG4gICAgY29uc3QgYWdncmVnYXRpb25fZ3JvdXBfdHlwZV9pbmRleCA9IGZsYWdGaWx0ZXJzLmFnZ3JlZ2F0aW9uX2dyb3VwX3R5cGVfaW5kZXg7XG4gICAgaWYgKGFnZ3JlZ2F0aW9uX2dyb3VwX3R5cGVfaW5kZXggIT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBncm91cE5hbWUgPSB0aGlzLmdyb3VwVHlwZU1hcHBpbmdbU3RyaW5nKGFnZ3JlZ2F0aW9uX2dyb3VwX3R5cGVfaW5kZXgpXTtcbiAgICAgIGlmICghZ3JvdXBOYW1lKSB7XG4gICAgICAgIHRoaXMubG9nTXNnSWZEZWJ1ZygoKSA9PiBjb25zb2xlLndhcm4oYFtGRUFUVVJFIEZMQUdTXSBVbmtub3duIGdyb3VwIHR5cGUgaW5kZXggJHthZ2dyZWdhdGlvbl9ncm91cF90eXBlX2luZGV4fSBmb3IgZmVhdHVyZSBmbGFnICR7ZmxhZy5rZXl9YCkpO1xuICAgICAgICB0aHJvdyBuZXcgSW5jb25jbHVzaXZlTWF0Y2hFcnJvcignRmxhZyBoYXMgdW5rbm93biBncm91cCB0eXBlIGluZGV4Jyk7XG4gICAgICB9XG4gICAgICBpZiAoIShncm91cE5hbWUgaW4gZ3JvdXBzKSkge1xuICAgICAgICB0aGlzLmxvZ01zZ0lmRGVidWcoKCkgPT4gY29uc29sZS53YXJuKGBbRkVBVFVSRSBGTEFHU10gQ2FuJ3QgY29tcHV0ZSBncm91cCBmZWF0dXJlIGZsYWc6ICR7ZmxhZy5rZXl9IHdpdGhvdXQgZ3JvdXAgbmFtZXMgcGFzc2VkIGluYCkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBmb2N1c2VkR3JvdXBQcm9wZXJ0aWVzID0gZ3JvdXBQcm9wZXJ0aWVzW2dyb3VwTmFtZV07XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5tYXRjaEZlYXR1cmVGbGFnUHJvcGVydGllcyhmbGFnLCBncm91cHNbZ3JvdXBOYW1lXSwgZm9jdXNlZEdyb3VwUHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1hdGNoRmVhdHVyZUZsYWdQcm9wZXJ0aWVzKGZsYWcsIGRpc3RpbmN0SWQsIHBlcnNvblByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBtYXRjaEZlYXR1cmVGbGFnUHJvcGVydGllcyhmbGFnLCBkaXN0aW5jdElkLCBwcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgZmxhZ0ZpbHRlcnMgPSBmbGFnLmZpbHRlcnMgfHwge307XG4gICAgY29uc3QgZmxhZ0NvbmRpdGlvbnMgPSBmbGFnRmlsdGVycy5ncm91cHMgfHwgW107XG4gICAgbGV0IGlzSW5jb25jbHVzaXZlID0gZmFsc2U7XG4gICAgbGV0IHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAvLyAjIFN0YWJsZSBzb3J0IGNvbmRpdGlvbnMgd2l0aCB2YXJpYW50IG92ZXJyaWRlcyB0byB0aGUgdG9wLiBUaGlzIGVuc3VyZXMgdGhhdCBpZiBvdmVycmlkZXMgYXJlIHByZXNlbnQsIHRoZXkgYXJlXG4gICAgLy8gIyBldmFsdWF0ZWQgZmlyc3QsIGFuZCB0aGUgdmFyaWFudCBvdmVycmlkZSBpcyBhcHBsaWVkIHRvIHRoZSBmaXJzdCBtYXRjaGluZyBjb25kaXRpb24uXG4gICAgY29uc3Qgc29ydGVkRmxhZ0NvbmRpdGlvbnMgPSBbLi4uZmxhZ0NvbmRpdGlvbnNdLnNvcnQoKGNvbmRpdGlvbkEsIGNvbmRpdGlvbkIpID0+IHtcbiAgICAgIGNvbnN0IEFIYXNWYXJpYW50T3ZlcnJpZGUgPSAhIWNvbmRpdGlvbkEudmFyaWFudDtcbiAgICAgIGNvbnN0IEJIYXNWYXJpYW50T3ZlcnJpZGUgPSAhIWNvbmRpdGlvbkIudmFyaWFudDtcbiAgICAgIGlmIChBSGFzVmFyaWFudE92ZXJyaWRlICYmIEJIYXNWYXJpYW50T3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKEFIYXNWYXJpYW50T3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChCSGFzVmFyaWFudE92ZXJyaWRlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBjb25kaXRpb24gb2Ygc29ydGVkRmxhZ0NvbmRpdGlvbnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmlzQ29uZGl0aW9uTWF0Y2goZmxhZywgZGlzdGluY3RJZCwgY29uZGl0aW9uLCBwcm9wZXJ0aWVzKSkge1xuICAgICAgICAgIGNvbnN0IHZhcmlhbnRPdmVycmlkZSA9IGNvbmRpdGlvbi52YXJpYW50O1xuICAgICAgICAgIGNvbnN0IGZsYWdWYXJpYW50cyA9IGZsYWdGaWx0ZXJzLm11bHRpdmFyaWF0ZT8udmFyaWFudHMgfHwgW107XG4gICAgICAgICAgaWYgKHZhcmlhbnRPdmVycmlkZSAmJiBmbGFnVmFyaWFudHMuc29tZSh2YXJpYW50ID0+IHZhcmlhbnQua2V5ID09PSB2YXJpYW50T3ZlcnJpZGUpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YXJpYW50T3ZlcnJpZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChhd2FpdCB0aGlzLmdldE1hdGNoaW5nVmFyaWFudChmbGFnLCBkaXN0aW5jdElkKSkgfHwgdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBJbmNvbmNsdXNpdmVNYXRjaEVycm9yKSB7XG4gICAgICAgICAgaXNJbmNvbmNsdXNpdmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoaXNJbmNvbmNsdXNpdmUpIHtcbiAgICAgIHRocm93IG5ldyBJbmNvbmNsdXNpdmVNYXRjaEVycm9yKFwiQ2FuJ3QgZGV0ZXJtaW5lIGlmIGZlYXR1cmUgZmxhZyBpcyBlbmFibGVkIG9yIG5vdCB3aXRoIGdpdmVuIHByb3BlcnRpZXNcIik7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBvbmx5IHJldHVybiBGYWxzZSB3aGVuIGFsbCBjb25kaXRpb25zIGFyZSBGYWxzZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyBpc0NvbmRpdGlvbk1hdGNoKGZsYWcsIGRpc3RpbmN0SWQsIGNvbmRpdGlvbiwgcHJvcGVydGllcykge1xuICAgIGNvbnN0IHJvbGxvdXRQZXJjZW50YWdlID0gY29uZGl0aW9uLnJvbGxvdXRfcGVyY2VudGFnZTtcbiAgICBjb25zdCB3YXJuRnVuY3Rpb24gPSBtc2cgPT4ge1xuICAgICAgdGhpcy5sb2dNc2dJZkRlYnVnKCgpID0+IGNvbnNvbGUud2Fybihtc2cpKTtcbiAgICB9O1xuICAgIGlmICgoY29uZGl0aW9uLnByb3BlcnRpZXMgfHwgW10pLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBjb25kaXRpb24ucHJvcGVydGllcykge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eVR5cGUgPSBwcm9wLnR5cGU7XG4gICAgICAgIGxldCBtYXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9wZXJ0eVR5cGUgPT09ICdjb2hvcnQnKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoQ29ob3J0KHByb3AsIHByb3BlcnRpZXMsIHRoaXMuY29ob3J0cywgdGhpcy5kZWJ1Z01vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5VHlwZSA9PT0gJ2ZsYWcnKSB7XG4gICAgICAgICAgdGhpcy5sb2dNc2dJZkRlYnVnKCgpID0+IGNvbnNvbGUud2FybihgW0ZFQVRVUkUgRkxBR1NdIEZsYWcgZGVwZW5kZW5jeSBmaWx0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGxvY2FsIGV2YWx1YXRpb24uIGAgKyBgU2tpcHBpbmcgY29uZGl0aW9uIGZvciBmbGFnICcke2ZsYWcua2V5fScgd2l0aCBkZXBlbmRlbmN5IG9uIGZsYWcgJyR7cHJvcC5rZXkgfHwgJ3Vua25vd24nfSdgKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoUHJvcGVydHkocHJvcCwgcHJvcGVydGllcywgd2FybkZ1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyb2xsb3V0UGVyY2VudGFnZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb2xsb3V0UGVyY2VudGFnZSAhPSB1bmRlZmluZWQgJiYgKGF3YWl0IF9oYXNoKGZsYWcua2V5LCBkaXN0aW5jdElkKSkgPiByb2xsb3V0UGVyY2VudGFnZSAvIDEwMC4wKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFzeW5jIGdldE1hdGNoaW5nVmFyaWFudChmbGFnLCBkaXN0aW5jdElkKSB7XG4gICAgY29uc3QgaGFzaFZhbHVlID0gYXdhaXQgX2hhc2goZmxhZy5rZXksIGRpc3RpbmN0SWQsICd2YXJpYW50Jyk7XG4gICAgY29uc3QgbWF0Y2hpbmdWYXJpYW50ID0gdGhpcy52YXJpYW50TG9va3VwVGFibGUoZmxhZykuZmluZCh2YXJpYW50ID0+IHtcbiAgICAgIHJldHVybiBoYXNoVmFsdWUgPj0gdmFyaWFudC52YWx1ZU1pbiAmJiBoYXNoVmFsdWUgPCB2YXJpYW50LnZhbHVlTWF4O1xuICAgIH0pO1xuICAgIGlmIChtYXRjaGluZ1ZhcmlhbnQpIHtcbiAgICAgIHJldHVybiBtYXRjaGluZ1ZhcmlhbnQua2V5O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHZhcmlhbnRMb29rdXBUYWJsZShmbGFnKSB7XG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBbXTtcbiAgICBsZXQgdmFsdWVNaW4gPSAwO1xuICAgIGxldCB2YWx1ZU1heCA9IDA7XG4gICAgY29uc3QgZmxhZ0ZpbHRlcnMgPSBmbGFnLmZpbHRlcnMgfHwge307XG4gICAgY29uc3QgbXVsdGl2YXJpYXRlcyA9IGZsYWdGaWx0ZXJzLm11bHRpdmFyaWF0ZT8udmFyaWFudHMgfHwgW107XG4gICAgbXVsdGl2YXJpYXRlcy5mb3JFYWNoKHZhcmlhbnQgPT4ge1xuICAgICAgdmFsdWVNYXggPSB2YWx1ZU1pbiArIHZhcmlhbnQucm9sbG91dF9wZXJjZW50YWdlIC8gMTAwLjA7XG4gICAgICBsb29rdXBUYWJsZS5wdXNoKHtcbiAgICAgICAgdmFsdWVNaW4sXG4gICAgICAgIHZhbHVlTWF4LFxuICAgICAgICBrZXk6IHZhcmlhbnQua2V5XG4gICAgICB9KTtcbiAgICAgIHZhbHVlTWluID0gdmFsdWVNYXg7XG4gICAgfSk7XG4gICAgcmV0dXJuIGxvb2t1cFRhYmxlO1xuICB9XG4gIGFzeW5jIGxvYWRGZWF0dXJlRmxhZ3MoZm9yY2VSZWxvYWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy5sb2FkZWRTdWNjZXNzZnVsbHlPbmNlIHx8IGZvcmNlUmVsb2FkKSB7XG4gICAgICBhd2FpdCB0aGlzLl9sb2FkRmVhdHVyZUZsYWdzKCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmVhdHVyZSBmbGFncyBwb2xsZXIgaGFzIGxvYWRlZCBzdWNjZXNzZnVsbHkgYXQgbGVhc3Qgb25jZSBhbmQgaGFzIG1vcmUgdGhhbiAwIGZlYXR1cmUgZmxhZ3MuXHJcbiAgICogVGhpcyBpcyB1c2VmdWwgdG8gY2hlY2sgaWYgbG9jYWwgZXZhbHVhdGlvbiBpcyByZWFkeSBiZWZvcmUgY2FsbGluZyBnZXRGZWF0dXJlRmxhZy5cclxuICAgKi9cbiAgaXNMb2NhbEV2YWx1YXRpb25SZWFkeSgpIHtcbiAgICByZXR1cm4gKHRoaXMubG9hZGVkU3VjY2Vzc2Z1bGx5T25jZSA/PyBmYWxzZSkgJiYgKHRoaXMuZmVhdHVyZUZsYWdzPy5sZW5ndGggPz8gMCkgPiAwO1xuICB9XG4gIC8qKlxyXG4gICAqIElmIGEgY2xpZW50IGlzIG1pc2NvbmZpZ3VyZWQgd2l0aCBhbiBpbnZhbGlkIG9yIGltcHJvcGVyIEFQSSBrZXksIHRoZSBwb2xsaW5nIGludGVydmFsIGlzIGRvdWJsZWQgZWFjaCB0aW1lXHJcbiAgICogdW50aWwgYSBzdWNjZXNzZnVsIHJlcXVlc3QgaXMgbWFkZSwgdXAgdG8gYSBtYXhpbXVtIG9mIDYwIHNlY29uZHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBUaGUgcG9sbGluZyBpbnRlcnZhbCB0byB1c2UgZm9yIHRoZSBuZXh0IHJlcXVlc3QuXHJcbiAgICovXG4gIGdldFBvbGxpbmdJbnRlcnZhbCgpIHtcbiAgICBpZiAoIXRoaXMuc2hvdWxkQmVnaW5FeHBvbmVudGlhbEJhY2tvZmYpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvbGxpbmdJbnRlcnZhbDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKFNJWFRZX1NFQ09ORFMsIHRoaXMucG9sbGluZ0ludGVydmFsICogMiAqKiB0aGlzLmJhY2tPZmZDb3VudCk7XG4gIH1cbiAgYXN5bmMgX2xvYWRGZWF0dXJlRmxhZ3MoKSB7XG4gICAgaWYgKHRoaXMucG9sbGVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5wb2xsZXIpO1xuICAgICAgdGhpcy5wb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMucG9sbGVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9sb2FkRmVhdHVyZUZsYWdzKCksIHRoaXMuZ2V0UG9sbGluZ0ludGVydmFsKCkpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0RmVhdHVyZUZsYWdEZWZpbml0aW9ucygpO1xuICAgICAgLy8gSGFuZGxlIHVuZGVmaW5lZCByZXMgY2FzZSwgdGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBidXQgaXQgZG9lc24ndCBodXJ0IHRvIGhhbmRsZSBpdCBhbnl3YXlcbiAgICAgIGlmICghcmVzKSB7XG4gICAgICAgIC8vIERvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGZsYWdzIHdoZW4gc29tZXRoaW5nIGdvZXMgd3JvbmdcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gTkIgT04gRVJST1IgSEFORExJTkcgJiBgbG9hZGVkU3VjY2Vzc2Z1bGx5T25jZWA6XG4gICAgICAvL1xuICAgICAgLy8gYGxvYWRlZFN1Y2Nlc3NmdWxseU9uY2VgIGluZGljYXRlcyB3ZSd2ZSBzdWNjZXNzZnVsbHkgbG9hZGVkIGEgdmFsaWQgc2V0IG9mIGZsYWdzIGF0IGxlYXN0IG9uY2UuXG4gICAgICAvLyBJZiB3ZSBzZXQgaXQgdG8gYHRydWVgIGluIGFuIGVycm9yIHNjZW5hcmlvIChlLmcuIDQwMiBPdmVyIFF1b3RhLCA0MDEgSW52YWxpZCBLZXksIGV0Yy4pLFxuICAgICAgLy8gYW55IG1hbnVhbCBjYWxsIHRvIGBsb2FkRmVhdHVyZUZsYWdzKClgICh3aXRob3V0IGZvcmNlUmVsb2FkKSB3aWxsIHNraXAgcmVmZXRjaGluZyBlbnRpcmVseSxcbiAgICAgIC8vIGxlYXZpbmcgdXMgc3R1Y2sgd2l0aCB6ZXJvIG9yIG91dGRhdGVkIGZsYWdzLiBUaGUgcG9sbGVyIGRvZXMga2VlcCBydW5uaW5nLCBidXQgd2UgYWxzbyB3YW50XG4gICAgICAvLyBtYW51YWwgcmVsb2FkcyB0byBiZSBwb3NzaWJsZSBhcyBzb29uIGFzIHRoZSBlcnJvciBjb25kaXRpb24gaXMgcmVzb2x2ZWQuXG4gICAgICAvL1xuICAgICAgLy8gVGhlcmVmb3JlLCBvbiBlcnJvciBzdGF0dXNlcywgd2UgZG8gKm5vdCogc2V0IGBsb2FkZWRTdWNjZXNzZnVsbHlPbmNlID0gdHJ1ZWAsIGVuc3VyaW5nIHRoYXRcbiAgICAgIC8vIGJvdGggdGhlIGJhY2tncm91bmQgcG9sbGVyIGFuZCBhbnkgc3Vic2VxdWVudCBtYW51YWwgY2FsbHMgY2FuIGtlZXAgdHJ5aW5nIHRvIGxvYWQgZmxhZ3NcbiAgICAgIC8vIG9uY2UgdGhlIGlzc3VlIChxdW90YSwgcGVybWlzc2lvbiwgcmF0ZSBsaW1pdCwgZXRjLikgaXMgcmVzb2x2ZWQuXG4gICAgICBzd2l0Y2ggKHJlcy5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSA0MDE6XG4gICAgICAgICAgLy8gSW52YWxpZCBBUEkga2V5XG4gICAgICAgICAgdGhpcy5zaG91bGRCZWdpbkV4cG9uZW50aWFsQmFja29mZiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5iYWNrT2ZmQ291bnQgKz0gMTtcbiAgICAgICAgICB0aHJvdyBuZXcgQ2xpZW50RXJyb3IoYFlvdXIgcHJvamVjdCBrZXkgb3IgcGVyc29uYWwgQVBJIGtleSBpcyBpbnZhbGlkLiBTZXR0aW5nIG5leHQgcG9sbGluZyBpbnRlcnZhbCB0byAke3RoaXMuZ2V0UG9sbGluZ0ludGVydmFsKCl9bXMuIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vcG9zdGhvZy5jb20vZG9jcy9hcGkjcmF0ZS1saW1pdGluZ2ApO1xuICAgICAgICBjYXNlIDQwMjpcbiAgICAgICAgICAvLyBRdW90YSBleGNlZWRlZCAtIGNsZWFyIGFsbCBmbGFnc1xuICAgICAgICAgIGNvbnNvbGUud2FybignW0ZFQVRVUkUgRkxBR1NdIEZlYXR1cmUgZmxhZ3MgcXVvdGEgbGltaXQgZXhjZWVkZWQgLSB1bnNldHRpbmcgYWxsIGxvY2FsIGZsYWdzLiBMZWFybiBtb3JlIGFib3V0IGJpbGxpbmcgbGltaXRzIGF0IGh0dHBzOi8vcG9zdGhvZy5jb20vZG9jcy9iaWxsaW5nL2xpbWl0cy1hbGVydHMnKTtcbiAgICAgICAgICB0aGlzLmZlYXR1cmVGbGFncyA9IFtdO1xuICAgICAgICAgIHRoaXMuZmVhdHVyZUZsYWdzQnlLZXkgPSB7fTtcbiAgICAgICAgICB0aGlzLmdyb3VwVHlwZU1hcHBpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLmNvaG9ydHMgPSB7fTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgIC8vIFBlcm1pc3Npb25zIGlzc3VlXG4gICAgICAgICAgdGhpcy5zaG91bGRCZWdpbkV4cG9uZW50aWFsQmFja29mZiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5iYWNrT2ZmQ291bnQgKz0gMTtcbiAgICAgICAgICB0aHJvdyBuZXcgQ2xpZW50RXJyb3IoYFlvdXIgcGVyc29uYWwgQVBJIGtleSBkb2VzIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gZmV0Y2ggZmVhdHVyZSBmbGFnIGRlZmluaXRpb25zIGZvciBsb2NhbCBldmFsdWF0aW9uLiBTZXR0aW5nIG5leHQgcG9sbGluZyBpbnRlcnZhbCB0byAke3RoaXMuZ2V0UG9sbGluZ0ludGVydmFsKCl9bXMuIEFyZSB5b3Ugc3VyZSB5b3UncmUgdXNpbmcgdGhlIGNvcnJlY3QgcGVyc29uYWwgYW5kIFByb2plY3QgQVBJIGtleSBwYWlyPyBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL3Bvc3Rob2cuY29tL2RvY3MvYXBpL292ZXJ2aWV3YCk7XG4gICAgICAgIGNhc2UgNDI5OlxuICAgICAgICAgIC8vIFJhdGUgbGltaXRlZFxuICAgICAgICAgIHRoaXMuc2hvdWxkQmVnaW5FeHBvbmVudGlhbEJhY2tvZmYgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYmFja09mZkNvdW50ICs9IDE7XG4gICAgICAgICAgdGhyb3cgbmV3IENsaWVudEVycm9yKGBZb3UgYXJlIGJlaW5nIHJhdGUgbGltaXRlZC4gU2V0dGluZyBuZXh0IHBvbGxpbmcgaW50ZXJ2YWwgdG8gJHt0aGlzLmdldFBvbGxpbmdJbnRlcnZhbCgpfW1zLiBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL3Bvc3Rob2cuY29tL2RvY3MvYXBpI3JhdGUtbGltaXRpbmdgKTtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyBzdWNjZXNzZnVsIHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUpzb24gPSAoYXdhaXQgcmVzLmpzb24oKSkgPz8ge307XG4gICAgICAgICAgICBpZiAoISgnZmxhZ3MnIGluIHJlc3BvbnNlSnNvbikpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbkVycm9yPy4obmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIHdoZW4gZ2V0dGluZyBmZWF0dXJlIGZsYWdzOiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlSnNvbil9YCkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVGbGFncyA9IHJlc3BvbnNlSnNvbi5mbGFncyA/PyBbXTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUZsYWdzQnlLZXkgPSB0aGlzLmZlYXR1cmVGbGFncy5yZWR1Y2UoKGFjYywgY3VycikgPT4gKGFjY1tjdXJyLmtleV0gPSBjdXJyLCBhY2MpLCB7fSk7XG4gICAgICAgICAgICB0aGlzLmdyb3VwVHlwZU1hcHBpbmcgPSByZXNwb25zZUpzb24uZ3JvdXBfdHlwZV9tYXBwaW5nIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5jb2hvcnRzID0gcmVzcG9uc2VKc29uLmNvaG9ydHMgfHwge307XG4gICAgICAgICAgICB0aGlzLmxvYWRlZFN1Y2Nlc3NmdWxseU9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRCZWdpbkV4cG9uZW50aWFsQmFja29mZiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5iYWNrT2ZmQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5vbkxvYWQ/Lih0aGlzLmZlYXR1cmVGbGFncy5sZW5ndGgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFNvbWV0aGluZyBlbHNlIHdlbnQgd3JvbmcsIG9yIHRoZSBzZXJ2ZXIgaXMgZG93bi5cbiAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGRvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGZsYWdzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENsaWVudEVycm9yKSB7XG4gICAgICAgIHRoaXMub25FcnJvcj8uKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldFBlcnNvbmFsQXBpS2V5UmVxdWVzdE9wdGlvbnMobWV0aG9kID0gJ0dFVCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0aG9kLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50aGlzLmN1c3RvbUhlYWRlcnMsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLnBlcnNvbmFsQXBpS2V5fWBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jIF9yZXF1ZXN0RmVhdHVyZUZsYWdEZWZpbml0aW9ucygpIHtcbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmhvc3R9L2FwaS9mZWF0dXJlX2ZsYWcvbG9jYWxfZXZhbHVhdGlvbj90b2tlbj0ke3RoaXMucHJvamVjdEFwaUtleX0mc2VuZF9jb2hvcnRzYDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRQZXJzb25hbEFwaUtleVJlcXVlc3RPcHRpb25zKCk7XG4gICAgbGV0IGFib3J0VGltZW91dCA9IG51bGw7XG4gICAgaWYgKHRoaXMudGltZW91dCAmJiB0eXBlb2YgdGhpcy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGFib3J0VGltZW91dCA9IHNhZmVTZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICAgIG9wdGlvbnMuc2lnbmFsID0gY29udHJvbGxlci5zaWduYWw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbGVhclRpbWVvdXQoYWJvcnRUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgc3RvcFBvbGxlcigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5wb2xsZXIpO1xuICB9XG59XG4vLyAjIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBkaXN0aW5jdF9pZCBhbmQgYSBmZWF0dXJlIGZsYWcga2V5IGFuZCByZXR1cm5zIGEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuLy8gIyBHaXZlbiB0aGUgc2FtZSBkaXN0aW5jdF9pZCBhbmQga2V5LCBpdCdsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIGZsb2F0LiBUaGVzZSBmbG9hdHMgYXJlXG4vLyAjIHVuaWZvcm1seSBkaXN0cmlidXRlZCBiZXR3ZWVuIDAgYW5kIDEsIHNvIGlmIHdlIHdhbnQgdG8gc2hvdyB0aGlzIGZlYXR1cmUgdG8gMjAlIG9mIHRyYWZmaWNcbi8vICMgd2UgY2FuIGRvIF9oYXNoKGtleSwgZGlzdGluY3RfaWQpIDwgMC4yXG5hc3luYyBmdW5jdGlvbiBfaGFzaChrZXksIGRpc3RpbmN0SWQsIHNhbHQgPSAnJykge1xuICBjb25zdCBoYXNoU3RyaW5nID0gYXdhaXQgaGFzaFNIQTEoYCR7a2V5fS4ke2Rpc3RpbmN0SWR9JHtzYWx0fWApO1xuICByZXR1cm4gcGFyc2VJbnQoaGFzaFN0cmluZy5zbGljZSgwLCAxNSksIDE2KSAvIExPTkdfU0NBTEU7XG59XG5mdW5jdGlvbiBtYXRjaFByb3BlcnR5KHByb3BlcnR5LCBwcm9wZXJ0eVZhbHVlcywgd2FybkZ1bmN0aW9uKSB7XG4gIGNvbnN0IGtleSA9IHByb3BlcnR5LmtleTtcbiAgY29uc3QgdmFsdWUgPSBwcm9wZXJ0eS52YWx1ZTtcbiAgY29uc3Qgb3BlcmF0b3IgPSBwcm9wZXJ0eS5vcGVyYXRvciB8fCAnZXhhY3QnO1xuICBpZiAoIShrZXkgaW4gcHJvcGVydHlWYWx1ZXMpKSB7XG4gICAgdGhyb3cgbmV3IEluY29uY2x1c2l2ZU1hdGNoRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBub3QgZm91bmQgaW4gcHJvcGVydHlWYWx1ZXNgKTtcbiAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ2lzX25vdF9zZXQnKSB7XG4gICAgdGhyb3cgbmV3IEluY29uY2x1c2l2ZU1hdGNoRXJyb3IoYE9wZXJhdG9yIGlzX25vdF9zZXQgaXMgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIGNvbnN0IG92ZXJyaWRlVmFsdWUgPSBwcm9wZXJ0eVZhbHVlc1trZXldO1xuICBpZiAob3ZlcnJpZGVWYWx1ZSA9PSBudWxsICYmICFOVUxMX1ZBTFVFU19BTExPV0VEX09QRVJBVE9SUy5pbmNsdWRlcyhvcGVyYXRvcikpIHtcbiAgICAvLyBpZiB0aGUgdmFsdWUgaXMgbnVsbCwganVzdCBmYWlsIHRoZSBmZWF0dXJlIGZsYWcgY29tcGFyaXNvblxuICAgIC8vIHRoaXMgaXNuJ3QgYW4gSW5jb25jbHVzaXZlTWF0Y2hFcnJvciBiZWNhdXNlIHRoZSBwcm9wZXJ0eSB2YWx1ZSB3YXMgcHJvdmlkZWQuXG4gICAgaWYgKHdhcm5GdW5jdGlvbikge1xuICAgICAgd2FybkZ1bmN0aW9uKGBQcm9wZXJ0eSAke2tleX0gY2Fubm90IGhhdmUgYSB2YWx1ZSBvZiBudWxsL3VuZGVmaW5lZCB3aXRoIHRoZSAke29wZXJhdG9yfSBvcGVyYXRvcmApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gY29tcHV0ZUV4YWN0TWF0Y2godmFsdWUsIG92ZXJyaWRlVmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAodmFsID0+IFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKFN0cmluZyhvdmVycmlkZVZhbHVlKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKSA9PT0gU3RyaW5nKG92ZXJyaWRlVmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGFyZShsaHMsIHJocywgb3BlcmF0b3IpIHtcbiAgICBpZiAob3BlcmF0b3IgPT09ICdndCcpIHtcbiAgICAgIHJldHVybiBsaHMgPiByaHM7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ2d0ZScpIHtcbiAgICAgIHJldHVybiBsaHMgPj0gcmhzO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdsdCcpIHtcbiAgICAgIHJldHVybiBsaHMgPCByaHM7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ2x0ZScpIHtcbiAgICAgIHJldHVybiBsaHMgPD0gcmhzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3BlcmF0b3I6ICR7b3BlcmF0b3J9YCk7XG4gICAgfVxuICB9XG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlICdleGFjdCc6XG4gICAgICByZXR1cm4gY29tcHV0ZUV4YWN0TWF0Y2godmFsdWUsIG92ZXJyaWRlVmFsdWUpO1xuICAgIGNhc2UgJ2lzX25vdCc6XG4gICAgICByZXR1cm4gIWNvbXB1dGVFeGFjdE1hdGNoKHZhbHVlLCBvdmVycmlkZVZhbHVlKTtcbiAgICBjYXNlICdpc19zZXQnOlxuICAgICAgcmV0dXJuIGtleSBpbiBwcm9wZXJ0eVZhbHVlcztcbiAgICBjYXNlICdpY29udGFpbnMnOlxuICAgICAgcmV0dXJuIFN0cmluZyhvdmVycmlkZVZhbHVlKS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKSk7XG4gICAgY2FzZSAnbm90X2ljb250YWlucyc6XG4gICAgICByZXR1cm4gIVN0cmluZyhvdmVycmlkZVZhbHVlKS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKSk7XG4gICAgY2FzZSAncmVnZXgnOlxuICAgICAgcmV0dXJuIGlzVmFsaWRSZWdleChTdHJpbmcodmFsdWUpKSAmJiBTdHJpbmcob3ZlcnJpZGVWYWx1ZSkubWF0Y2goU3RyaW5nKHZhbHVlKSkgIT09IG51bGw7XG4gICAgY2FzZSAnbm90X3JlZ2V4JzpcbiAgICAgIHJldHVybiBpc1ZhbGlkUmVnZXgoU3RyaW5nKHZhbHVlKSkgJiYgU3RyaW5nKG92ZXJyaWRlVmFsdWUpLm1hdGNoKFN0cmluZyh2YWx1ZSkpID09PSBudWxsO1xuICAgIGNhc2UgJ2d0JzpcbiAgICBjYXNlICdndGUnOlxuICAgIGNhc2UgJ2x0JzpcbiAgICBjYXNlICdsdGUnOlxuICAgICAge1xuICAgICAgICAvLyA6VFJJQ0tZOiBXZSBhZGp1c3QgY29tcGFyaXNvbiBiYXNlZCBvbiB0aGUgb3ZlcnJpZGUgdmFsdWUgcGFzc2VkIGluLFxuICAgICAgICAvLyB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGJvdGggbnVtZXJpYyBhbmQgc3RyaW5nIGNvbXBhcmlzb25zIGFwcHJvcHJpYXRlbHkuXG4gICAgICAgIGxldCBwYXJzZWRWYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBwYXNzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRWYWx1ZSAhPSBudWxsICYmIG92ZXJyaWRlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIGNoZWNrIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUob3ZlcnJpZGVWYWx1ZSwgU3RyaW5nKHZhbHVlKSwgb3BlcmF0b3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZShvdmVycmlkZVZhbHVlLCBwYXJzZWRWYWx1ZSwgb3BlcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY29tcGFyZShTdHJpbmcob3ZlcnJpZGVWYWx1ZSksIFN0cmluZyh2YWx1ZSksIG9wZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgJ2lzX2RhdGVfYWZ0ZXInOlxuICAgIGNhc2UgJ2lzX2RhdGVfYmVmb3JlJzpcbiAgICAgIHtcbiAgICAgICAgbGV0IHBhcnNlZERhdGUgPSByZWxhdGl2ZURhdGVQYXJzZUZvckZlYXR1cmVGbGFnTWF0Y2hpbmcoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIGlmIChwYXJzZWREYXRlID09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWREYXRlID0gY29udmVydFRvRGF0ZVRpbWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWREYXRlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW5jb25jbHVzaXZlTWF0Y2hFcnJvcihgSW52YWxpZCBkYXRlOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlRGF0ZSA9IGNvbnZlcnRUb0RhdGVUaW1lKG92ZXJyaWRlVmFsdWUpO1xuICAgICAgICBpZiAoWydpc19kYXRlX2JlZm9yZSddLmluY2x1ZGVzKG9wZXJhdG9yKSkge1xuICAgICAgICAgIHJldHVybiBvdmVycmlkZURhdGUgPCBwYXJzZWREYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdmVycmlkZURhdGUgPiBwYXJzZWREYXRlO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgSW5jb25jbHVzaXZlTWF0Y2hFcnJvcihgVW5rbm93biBvcGVyYXRvcjogJHtvcGVyYXRvcn1gKTtcbiAgfVxufVxuZnVuY3Rpb24gbWF0Y2hDb2hvcnQocHJvcGVydHksIHByb3BlcnR5VmFsdWVzLCBjb2hvcnRQcm9wZXJ0aWVzLCBkZWJ1Z01vZGUgPSBmYWxzZSkge1xuICBjb25zdCBjb2hvcnRJZCA9IFN0cmluZyhwcm9wZXJ0eS52YWx1ZSk7XG4gIGlmICghKGNvaG9ydElkIGluIGNvaG9ydFByb3BlcnRpZXMpKSB7XG4gICAgdGhyb3cgbmV3IEluY29uY2x1c2l2ZU1hdGNoRXJyb3IoXCJjYW4ndCBtYXRjaCBjb2hvcnQgd2l0aG91dCBhIGdpdmVuIGNvaG9ydCBwcm9wZXJ0eSB2YWx1ZVwiKTtcbiAgfVxuICBjb25zdCBwcm9wZXJ0eUdyb3VwID0gY29ob3J0UHJvcGVydGllc1tjb2hvcnRJZF07XG4gIHJldHVybiBtYXRjaFByb3BlcnR5R3JvdXAocHJvcGVydHlHcm91cCwgcHJvcGVydHlWYWx1ZXMsIGNvaG9ydFByb3BlcnRpZXMsIGRlYnVnTW9kZSk7XG59XG5mdW5jdGlvbiBtYXRjaFByb3BlcnR5R3JvdXAocHJvcGVydHlHcm91cCwgcHJvcGVydHlWYWx1ZXMsIGNvaG9ydFByb3BlcnRpZXMsIGRlYnVnTW9kZSA9IGZhbHNlKSB7XG4gIGlmICghcHJvcGVydHlHcm91cCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHByb3BlcnR5R3JvdXBUeXBlID0gcHJvcGVydHlHcm91cC50eXBlO1xuICBjb25zdCBwcm9wZXJ0aWVzID0gcHJvcGVydHlHcm91cC52YWx1ZXM7XG4gIGlmICghcHJvcGVydGllcyB8fCBwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGVtcHR5IGdyb3VwcyBhcmUgbm8tb3BzLCBhbHdheXMgbWF0Y2hcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBsZXQgZXJyb3JNYXRjaGluZ0xvY2FsbHkgPSBmYWxzZTtcbiAgaWYgKCd2YWx1ZXMnIGluIHByb3BlcnRpZXNbMF0pIHtcbiAgICAvLyBhIG5lc3RlZCBwcm9wZXJ0eSBncm91cFxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gbWF0Y2hQcm9wZXJ0eUdyb3VwKHByb3AsIHByb3BlcnR5VmFsdWVzLCBjb2hvcnRQcm9wZXJ0aWVzLCBkZWJ1Z01vZGUpO1xuICAgICAgICBpZiAocHJvcGVydHlHcm91cFR5cGUgPT09ICdBTkQnKSB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9SIGdyb3VwXG4gICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBJbmNvbmNsdXNpdmVNYXRjaEVycm9yKSB7XG4gICAgICAgICAgaWYgKGRlYnVnTW9kZSkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgRmFpbGVkIHRvIGNvbXB1dGUgcHJvcGVydHkgJHtwcm9wfSBsb2NhbGx5OiAke2Vycn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3JNYXRjaGluZ0xvY2FsbHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyb3JNYXRjaGluZ0xvY2FsbHkpIHtcbiAgICAgIHRocm93IG5ldyBJbmNvbmNsdXNpdmVNYXRjaEVycm9yKFwiQ2FuJ3QgbWF0Y2ggY29ob3J0IHdpdGhvdXQgYSBnaXZlbiBjb2hvcnQgcHJvcGVydHkgdmFsdWVcIik7XG4gICAgfVxuICAgIC8vIGlmIHdlIGdldCBoZXJlLCBhbGwgbWF0Y2hlZCBpbiBBTkQgY2FzZSwgb3Igbm9uZSBtYXRjaGVkIGluIE9SIGNhc2VcbiAgICByZXR1cm4gcHJvcGVydHlHcm91cFR5cGUgPT09ICdBTkQnO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgbWF0Y2hlcztcbiAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gJ2NvaG9ydCcpIHtcbiAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hDb2hvcnQocHJvcCwgcHJvcGVydHlWYWx1ZXMsIGNvaG9ydFByb3BlcnRpZXMsIGRlYnVnTW9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcC50eXBlID09PSAnZmxhZycpIHtcbiAgICAgICAgICBpZiAoZGVidWdNb2RlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtGRUFUVVJFIEZMQUdTXSBGbGFnIGRlcGVuZGVuY3kgZmlsdGVycyBhcmUgbm90IHN1cHBvcnRlZCBpbiBsb2NhbCBldmFsdWF0aW9uLiBgICsgYFNraXBwaW5nIGNvbmRpdGlvbiB3aXRoIGRlcGVuZGVuY3kgb24gZmxhZyAnJHtwcm9wLmtleSB8fCAndW5rbm93bid9J2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hQcm9wZXJ0eShwcm9wLCBwcm9wZXJ0eVZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmVnYXRpb24gPSBwcm9wLm5lZ2F0aW9uIHx8IGZhbHNlO1xuICAgICAgICBpZiAocHJvcGVydHlHcm91cFR5cGUgPT09ICdBTkQnKSB7XG4gICAgICAgICAgLy8gaWYgbmVnYXRlZCBwcm9wZXJ0eSwgZG8gdGhlIGludmVyc2VcbiAgICAgICAgICBpZiAoIW1hdGNoZXMgJiYgIW5lZ2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXRjaGVzICYmIG5lZ2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9SIGdyb3VwXG4gICAgICAgICAgaWYgKG1hdGNoZXMgJiYgIW5lZ2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFtYXRjaGVzICYmIG5lZ2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgSW5jb25jbHVzaXZlTWF0Y2hFcnJvcikge1xuICAgICAgICAgIGlmIChkZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYEZhaWxlZCB0byBjb21wdXRlIHByb3BlcnR5ICR7cHJvcH0gbG9jYWxseTogJHtlcnJ9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yTWF0Y2hpbmdMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9yTWF0Y2hpbmdMb2NhbGx5KSB7XG4gICAgICB0aHJvdyBuZXcgSW5jb25jbHVzaXZlTWF0Y2hFcnJvcihcImNhbid0IG1hdGNoIGNvaG9ydCB3aXRob3V0IGEgZ2l2ZW4gY29ob3J0IHByb3BlcnR5IHZhbHVlXCIpO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBnZXQgaGVyZSwgYWxsIG1hdGNoZWQgaW4gQU5EIGNhc2UsIG9yIG5vbmUgbWF0Y2hlZCBpbiBPUiBjYXNlXG4gICAgcmV0dXJuIHByb3BlcnR5R3JvdXBUeXBlID09PSAnQU5EJztcbiAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZFJlZ2V4KHJlZ2V4KSB7XG4gIHRyeSB7XG4gICAgbmV3IFJlZ0V4cChyZWdleCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gY29udmVydFRvRGF0ZVRpbWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmICghaXNOYU4oZGF0ZS52YWx1ZU9mKCkpKSB7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEluY29uY2x1c2l2ZU1hdGNoRXJyb3IoYCR7dmFsdWV9IGlzIGluIGFuIGludmFsaWQgZGF0ZSBmb3JtYXRgKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW5jb25jbHVzaXZlTWF0Y2hFcnJvcihgVGhlIGRhdGUgcHJvdmlkZWQgJHt2YWx1ZX0gbXVzdCBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBkYXRlIG9iamVjdGApO1xuICB9XG59XG5mdW5jdGlvbiByZWxhdGl2ZURhdGVQYXJzZUZvckZlYXR1cmVGbGFnTWF0Y2hpbmcodmFsdWUpIHtcbiAgY29uc3QgcmVnZXggPSAvXi0/KD88bnVtYmVyPlswLTldKykoPzxpbnRlcnZhbD5bYS16XSkkLztcbiAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZWdleCk7XG4gIGNvbnN0IHBhcnNlZER0ID0gbmV3IERhdGUobmV3IERhdGUoKS50b0lTT1N0cmluZygpKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgaWYgKCFtYXRjaC5ncm91cHMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBudW1iZXIgPSBwYXJzZUludChtYXRjaC5ncm91cHNbJ251bWJlciddKTtcbiAgICBpZiAobnVtYmVyID49IDEwMDAwKSB7XG4gICAgICAvLyBHdWFyZCBhZ2FpbnN0IG92ZXJmbG93LCBkaXNhbGxvdyBudW1iZXJzIGdyZWF0ZXIgdGhhbiAxMF8wMDBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnZhbCA9IG1hdGNoLmdyb3Vwc1snaW50ZXJ2YWwnXTtcbiAgICBpZiAoaW50ZXJ2YWwgPT0gJ2gnKSB7XG4gICAgICBwYXJzZWREdC5zZXRVVENIb3VycyhwYXJzZWREdC5nZXRVVENIb3VycygpIC0gbnVtYmVyKTtcbiAgICB9IGVsc2UgaWYgKGludGVydmFsID09ICdkJykge1xuICAgICAgcGFyc2VkRHQuc2V0VVRDRGF0ZShwYXJzZWREdC5nZXRVVENEYXRlKCkgLSBudW1iZXIpO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJ2YWwgPT0gJ3cnKSB7XG4gICAgICBwYXJzZWREdC5zZXRVVENEYXRlKHBhcnNlZER0LmdldFVUQ0RhdGUoKSAtIG51bWJlciAqIDcpO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJ2YWwgPT0gJ20nKSB7XG4gICAgICBwYXJzZWREdC5zZXRVVENNb250aChwYXJzZWREdC5nZXRVVENNb250aCgpIC0gbnVtYmVyKTtcbiAgICB9IGVsc2UgaWYgKGludGVydmFsID09ICd5Jykge1xuICAgICAgcGFyc2VkRHQuc2V0VVRDRnVsbFllYXIocGFyc2VkRHQuZ2V0VVRDRnVsbFllYXIoKSAtIG51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuY2xhc3MgUG9zdEhvZ01lbW9yeVN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9tZW1vcnlTdG9yYWdlID0ge307XG4gIH1cbiAgZ2V0UHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21lbW9yeVN0b3JhZ2Vba2V5XTtcbiAgfVxuICBzZXRQcm9wZXJ0eShrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fbWVtb3J5U3RvcmFnZVtrZXldID0gdmFsdWUgIT09IG51bGwgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vLyBTdGFuZGFyZCBsb2NhbCBldmFsdWF0aW9uIHJhdGUgbGltaXQgaXMgNjAwIHBlciBtaW51dGUgKDEwIHBlciBzZWNvbmQpLFxuLy8gc28gdGhlIGZhc3Rlc3QgYSBwb2xsZXIgc2hvdWxkIGV2ZXIgYmUgc2V0IGlzIDEwMG1zLlxuY29uc3QgTUlOSU1VTV9QT0xMSU5HX0lOVEVSVkFMID0gMTAwO1xuY29uc3QgVEhJUlRZX1NFQ09ORFMgPSAzMCAqIDEwMDA7XG5jb25zdCBNQVhfQ0FDSEVfU0laRSA9IDUwICogMTAwMDtcbi8vIFRoZSBhY3R1YWwgZXhwb3J0ZWQgTm9kZWpzIEFQSS5cbmNsYXNzIFBvc3RIb2dCYWNrZW5kQ2xpZW50IGV4dGVuZHMgUG9zdEhvZ0NvcmVTdGF0ZWxlc3Mge1xuICBjb25zdHJ1Y3RvcihhcGlLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKGFwaUtleSwgb3B0aW9ucyk7XG4gICAgdGhpcy5fbWVtb3J5U3RvcmFnZSA9IG5ldyBQb3N0SG9nTWVtb3J5U3RvcmFnZSgpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5vcHRpb25zLmZlYXR1cmVGbGFnc1BvbGxpbmdJbnRlcnZhbCA9IHR5cGVvZiBvcHRpb25zLmZlYXR1cmVGbGFnc1BvbGxpbmdJbnRlcnZhbCA9PT0gJ251bWJlcicgPyBNYXRoLm1heChvcHRpb25zLmZlYXR1cmVGbGFnc1BvbGxpbmdJbnRlcnZhbCwgTUlOSU1VTV9QT0xMSU5HX0lOVEVSVkFMKSA6IFRISVJUWV9TRUNPTkRTO1xuICAgIGlmIChvcHRpb25zLnBlcnNvbmFsQXBpS2V5KSB7XG4gICAgICBpZiAob3B0aW9ucy5wZXJzb25hbEFwaUtleS5pbmNsdWRlcygncGhjXycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBQZXJzb25hbCBBUEkga2V5IGlzIGludmFsaWQuIFRoZXNlIGtleXMgYXJlIHByZWZpeGVkIHdpdGggXCJwaHhfXCIgYW5kIGNhbiBiZSBjcmVhdGVkIGluIFBvc3RIb2cgcHJvamVjdCBzZXR0aW5ncy4nKTtcbiAgICAgIH1cbiAgICAgIC8vIE9ubHkgc3RhcnQgdGhlIHBvbGxlciBpZiBsb2NhbCBldmFsdWF0aW9uIGlzIGVuYWJsZWQgKGRlZmF1bHRzIHRvIHRydWUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICBjb25zdCBzaG91bGRFbmFibGVMb2NhbEV2YWx1YXRpb24gPSBvcHRpb25zLmVuYWJsZUxvY2FsRXZhbHVhdGlvbiAhPT0gZmFsc2U7XG4gICAgICBpZiAoc2hvdWxkRW5hYmxlTG9jYWxFdmFsdWF0aW9uKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZUZsYWdzUG9sbGVyID0gbmV3IEZlYXR1cmVGbGFnc1BvbGxlcih7XG4gICAgICAgICAgcG9sbGluZ0ludGVydmFsOiB0aGlzLm9wdGlvbnMuZmVhdHVyZUZsYWdzUG9sbGluZ0ludGVydmFsLFxuICAgICAgICAgIHBlcnNvbmFsQXBpS2V5OiBvcHRpb25zLnBlcnNvbmFsQXBpS2V5LFxuICAgICAgICAgIHByb2plY3RBcGlLZXk6IGFwaUtleSxcbiAgICAgICAgICB0aW1lb3V0OiBvcHRpb25zLnJlcXVlc3RUaW1lb3V0ID8/IDEwMDAwLFxuICAgICAgICAgIGhvc3Q6IHRoaXMuaG9zdCxcbiAgICAgICAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICAgICAgICBvbkVycm9yOiBlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uTG9hZDogY291bnQgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmVtaXQoJ2xvY2FsRXZhbHVhdGlvbkZsYWdzTG9hZGVkJywgY291bnQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VzdG9tSGVhZGVyczogdGhpcy5nZXRDdXN0b21IZWFkZXJzKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXJyb3JUcmFja2luZyA9IG5ldyBFcnJvclRyYWNraW5nKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuZGlzdGluY3RJZEhhc1NlbnRGbGFnQ2FsbHMgPSB7fTtcbiAgICB0aGlzLm1heENhY2hlU2l6ZSA9IG9wdGlvbnMubWF4Q2FjaGVTaXplIHx8IE1BWF9DQUNIRV9TSVpFO1xuICB9XG4gIGdldFBlcnNpc3RlZFByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tZW1vcnlTdG9yYWdlLmdldFByb3BlcnR5KGtleSk7XG4gIH1cbiAgc2V0UGVyc2lzdGVkUHJvcGVydHkoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9tZW1vcnlTdG9yYWdlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICB9XG4gIGZldGNoKHVybCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmV0Y2ggPyB0aGlzLm9wdGlvbnMuZmV0Y2godXJsLCBvcHRpb25zKSA6IGZldGNoKHVybCwgb3B0aW9ucyk7XG4gIH1cbiAgZ2V0TGlicmFyeVZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHZlcnNpb247XG4gIH1cbiAgZ2V0Q3VzdG9tVXNlckFnZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLmdldExpYnJhcnlJZCgpfS8ke3RoaXMuZ2V0TGlicmFyeVZlcnNpb24oKX1gO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIub3B0SW4oKTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci5vcHRPdXQoKTtcbiAgfVxuICBkZWJ1ZyhlbmFibGVkID0gdHJ1ZSkge1xuICAgIHN1cGVyLmRlYnVnKGVuYWJsZWQpO1xuICAgIHRoaXMuZmVhdHVyZUZsYWdzUG9sbGVyPy5kZWJ1ZyhlbmFibGVkKTtcbiAgfVxuICBjYXB0dXJlKHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMubG9nTXNnSWZEZWJ1ZygoKSA9PiBjb25zb2xlLndhcm4oJ0NhbGxlZCBjYXB0dXJlKCkgd2l0aCBhIHN0cmluZyBhcyB0aGUgZmlyc3QgYXJndW1lbnQgd2hlbiBhbiBvYmplY3Qgd2FzIGV4cGVjdGVkLicpKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGlzdGluY3RJZCxcbiAgICAgIGV2ZW50LFxuICAgICAgcHJvcGVydGllcyxcbiAgICAgIGdyb3VwcyxcbiAgICAgIHNlbmRGZWF0dXJlRmxhZ3MsXG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBkaXNhYmxlR2VvaXAsXG4gICAgICB1dWlkXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IF9jYXB0dXJlID0gcHJvcHMgPT4ge1xuICAgICAgc3VwZXIuY2FwdHVyZVN0YXRlbGVzcyhkaXN0aW5jdElkLCBldmVudCwgcHJvcHMsIHtcbiAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICBkaXNhYmxlR2VvaXAsXG4gICAgICAgIHV1aWRcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gOlRSSUNLWTogSWYgd2UgZmx1c2gsIG9yIG5lZWQgdG8gc2h1dCBkb3duLCB0byBub3QgbG9zZSBldmVudHMgd2Ugd2FudCB0aGlzIHByb21pc2UgdG8gcmVzb2x2ZSBiZWZvcmUgd2UgZmx1c2hcbiAgICBjb25zdCBjYXB0dXJlUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHNlbmRGZWF0dXJlRmxhZ3MpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIHNlbmRpbmcgZmVhdHVyZSBmbGFncywgd2UgZXZhbHVhdGUgdGhlbSBsb2NhbGx5IGlmIHRoZSB1c2VyIHByZWZlcnMgaXQsIG90aGVyd2lzZSB3ZSBmYWxsIGJhY2sgdG8gcmVtb3RlIGV2YWx1YXRpb25cbiAgICAgICAgY29uc3Qgc2VuZEZlYXR1cmVGbGFnc09wdGlvbnMgPSB0eXBlb2Ygc2VuZEZlYXR1cmVGbGFncyA9PT0gJ29iamVjdCcgPyBzZW5kRmVhdHVyZUZsYWdzIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRGZWF0dXJlRmxhZ3NGb3JFdmVudChkaXN0aW5jdElkLCBncm91cHMsIGRpc2FibGVHZW9pcCwgc2VuZEZlYXR1cmVGbGFnc09wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50ID09PSAnJGZlYXR1cmVfZmxhZ19jYWxsZWQnKSB7XG4gICAgICAgIC8vIElmIHdlJ3JlIGNhcHR1cmluZyBhICRmZWF0dXJlX2ZsYWdfY2FsbGVkIGV2ZW50LCB3ZSBkb24ndCB3YW50IHRvIGVucmljaCB0aGUgZXZlbnQgd2l0aCBjYWNoZWQgZmxhZ3MgdGhhdCBtYXkgYmUgb3V0IG9mIGRhdGUuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9KS50aGVuKGZsYWdzID0+IHtcbiAgICAgIC8vIERlcml2ZSB0aGUgcmVsZXZhbnQgZmxhZyBwcm9wZXJ0aWVzIHRvIGFkZFxuICAgICAgY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGlmIChmbGFncykge1xuICAgICAgICBmb3IgKGNvbnN0IFtmZWF0dXJlLCB2YXJpYW50XSBvZiBPYmplY3QuZW50cmllcyhmbGFncykpIHtcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc1tgJGZlYXR1cmUvJHtmZWF0dXJlfWBdID0gdmFyaWFudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYWN0aXZlRmxhZ3MgPSBPYmplY3Qua2V5cyhmbGFncyB8fCB7fSkuZmlsdGVyKGZsYWcgPT4gZmxhZ3M/LltmbGFnXSAhPT0gZmFsc2UpLnNvcnQoKTtcbiAgICAgIGlmIChhY3RpdmVGbGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzWyckYWN0aXZlX2ZlYXR1cmVfZmxhZ3MnXSA9IGFjdGl2ZUZsYWdzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIGdldHRpbmcgdGhlIGZsYWcgaW5mbyAtIHdlIHNob3VsZCBjYXB0dXJlIHRoZSBldmVudCBhbnl3YXlzXG4gICAgICByZXR1cm4ge307XG4gICAgfSkudGhlbihhZGRpdGlvbmFsUHJvcGVydGllcyA9PiB7XG4gICAgICAvLyBObyBtYXR0ZXIgd2hhdCAtIGNhcHR1cmUgdGhlIGV2ZW50XG4gICAgICBfY2FwdHVyZSh7XG4gICAgICAgIC4uLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLFxuICAgICAgICAuLi5wcm9wZXJ0aWVzLFxuICAgICAgICAkZ3JvdXBzOiBncm91cHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRkUGVuZGluZ1Byb21pc2UoY2FwdHVyZVByb21pc2UpO1xuICB9XG4gIGFzeW5jIGNhcHR1cmVJbW1lZGlhdGUocHJvcHMpIHtcbiAgICBpZiAodHlwZW9mIHByb3BzID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5sb2dNc2dJZkRlYnVnKCgpID0+IGNvbnNvbGUud2FybignQ2FsbGVkIGNhcHR1cmUoKSB3aXRoIGEgc3RyaW5nIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB3aGVuIGFuIG9iamVjdCB3YXMgZXhwZWN0ZWQuJykpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkaXN0aW5jdElkLFxuICAgICAgZXZlbnQsXG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgZ3JvdXBzLFxuICAgICAgc2VuZEZlYXR1cmVGbGFncyxcbiAgICAgIHRpbWVzdGFtcCxcbiAgICAgIGRpc2FibGVHZW9pcCxcbiAgICAgIHV1aWRcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3QgX2NhcHR1cmUgPSBwcm9wcyA9PiB7XG4gICAgICByZXR1cm4gc3VwZXIuY2FwdHVyZVN0YXRlbGVzc0ltbWVkaWF0ZShkaXN0aW5jdElkLCBldmVudCwgcHJvcHMsIHtcbiAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICBkaXNhYmxlR2VvaXAsXG4gICAgICAgIHV1aWRcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2FwdHVyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChzZW5kRmVhdHVyZUZsYWdzKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBzZW5kaW5nIGZlYXR1cmUgZmxhZ3MsIHdlIGV2YWx1YXRlIHRoZW0gbG9jYWxseSBpZiB0aGUgdXNlciBwcmVmZXJzIGl0LCBvdGhlcndpc2Ugd2UgZmFsbCBiYWNrIHRvIHJlbW90ZSBldmFsdWF0aW9uXG4gICAgICAgIGNvbnN0IHNlbmRGZWF0dXJlRmxhZ3NPcHRpb25zID0gdHlwZW9mIHNlbmRGZWF0dXJlRmxhZ3MgPT09ICdvYmplY3QnID8gc2VuZEZlYXR1cmVGbGFncyA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0RmVhdHVyZUZsYWdzRm9yRXZlbnQoZGlzdGluY3RJZCwgZ3JvdXBzLCBkaXNhYmxlR2VvaXAsIHNlbmRGZWF0dXJlRmxhZ3NPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudCA9PT0gJyRmZWF0dXJlX2ZsYWdfY2FsbGVkJykge1xuICAgICAgICAvLyBJZiB3ZSdyZSBjYXB0dXJpbmcgYSAkZmVhdHVyZV9mbGFnX2NhbGxlZCBldmVudCwgd2UgZG9uJ3Qgd2FudCB0byBlbnJpY2ggdGhlIGV2ZW50IHdpdGggY2FjaGVkIGZsYWdzIHRoYXQgbWF5IGJlIG91dCBvZiBkYXRlLlxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfSkudGhlbihmbGFncyA9PiB7XG4gICAgICAvLyBEZXJpdmUgdGhlIHJlbGV2YW50IGZsYWcgcHJvcGVydGllcyB0byBhZGRcbiAgICAgIGNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0ge307XG4gICAgICBpZiAoZmxhZ3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBbZmVhdHVyZSwgdmFyaWFudF0gb2YgT2JqZWN0LmVudHJpZXMoZmxhZ3MpKSB7XG4gICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXNbYCRmZWF0dXJlLyR7ZmVhdHVyZX1gXSA9IHZhcmlhbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGl2ZUZsYWdzID0gT2JqZWN0LmtleXMoZmxhZ3MgfHwge30pLmZpbHRlcihmbGFnID0+IGZsYWdzPy5bZmxhZ10gIT09IGZhbHNlKS5zb3J0KCk7XG4gICAgICBpZiAoYWN0aXZlRmxhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc1snJGFjdGl2ZV9mZWF0dXJlX2ZsYWdzJ10gPSBhY3RpdmVGbGFncztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBnZXR0aW5nIHRoZSBmbGFnIGluZm8gLSB3ZSBzaG91bGQgY2FwdHVyZSB0aGUgZXZlbnQgYW55d2F5c1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH0pLnRoZW4oYWRkaXRpb25hbFByb3BlcnRpZXMgPT4ge1xuICAgICAgLy8gTm8gbWF0dGVyIHdoYXQgLSBjYXB0dXJlIHRoZSBldmVudFxuICAgICAgX2NhcHR1cmUoe1xuICAgICAgICAuLi5hZGRpdGlvbmFsUHJvcGVydGllcyxcbiAgICAgICAgLi4ucHJvcGVydGllcyxcbiAgICAgICAgJGdyb3VwczogZ3JvdXBzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBhd2FpdCBjYXB0dXJlUHJvbWlzZTtcbiAgfVxuICBpZGVudGlmeSh7XG4gICAgZGlzdGluY3RJZCxcbiAgICBwcm9wZXJ0aWVzLFxuICAgIGRpc2FibGVHZW9pcFxuICB9KSB7XG4gICAgLy8gQ2F0Y2ggcHJvcGVydGllcyBwYXNzZWQgYXMgJHNldCBhbmQgbW92ZSB0aGVtIHRvIHRoZSB0b3AgbGV2ZWxcbiAgICAvLyBwcm9tb3RlICRzZXQgYW5kICRzZXRfb25jZSB0byB0b3AgbGV2ZWxcbiAgICBjb25zdCB1c2VyUHJvcHNPbmNlID0gcHJvcGVydGllcz8uJHNldF9vbmNlO1xuICAgIGRlbGV0ZSBwcm9wZXJ0aWVzPy4kc2V0X29uY2U7XG4gICAgLy8gaWYgbm8gJHNldCBpcyBwcm92aWRlZCB3ZSBhc3N1bWUgYWxsIHByb3BlcnRpZXMgYXJlICRzZXRcbiAgICBjb25zdCB1c2VyUHJvcHMgPSBwcm9wZXJ0aWVzPy4kc2V0IHx8IHByb3BlcnRpZXM7XG4gICAgc3VwZXIuaWRlbnRpZnlTdGF0ZWxlc3MoZGlzdGluY3RJZCwge1xuICAgICAgJHNldDogdXNlclByb3BzLFxuICAgICAgJHNldF9vbmNlOiB1c2VyUHJvcHNPbmNlXG4gICAgfSwge1xuICAgICAgZGlzYWJsZUdlb2lwXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgaWRlbnRpZnlJbW1lZGlhdGUoe1xuICAgIGRpc3RpbmN0SWQsXG4gICAgcHJvcGVydGllcyxcbiAgICBkaXNhYmxlR2VvaXBcbiAgfSkge1xuICAgIC8vIHByb21vdGUgJHNldCBhbmQgJHNldF9vbmNlIHRvIHRvcCBsZXZlbFxuICAgIGNvbnN0IHVzZXJQcm9wc09uY2UgPSBwcm9wZXJ0aWVzPy4kc2V0X29uY2U7XG4gICAgZGVsZXRlIHByb3BlcnRpZXM/LiRzZXRfb25jZTtcbiAgICAvLyBpZiBubyAkc2V0IGlzIHByb3ZpZGVkIHdlIGFzc3VtZSBhbGwgcHJvcGVydGllcyBhcmUgJHNldFxuICAgIGNvbnN0IHVzZXJQcm9wcyA9IHByb3BlcnRpZXM/LiRzZXQgfHwgcHJvcGVydGllcztcbiAgICBhd2FpdCBzdXBlci5pZGVudGlmeVN0YXRlbGVzc0ltbWVkaWF0ZShkaXN0aW5jdElkLCB7XG4gICAgICAkc2V0OiB1c2VyUHJvcHMsXG4gICAgICAkc2V0X29uY2U6IHVzZXJQcm9wc09uY2VcbiAgICB9LCB7XG4gICAgICBkaXNhYmxlR2VvaXBcbiAgICB9KTtcbiAgfVxuICBhbGlhcyhkYXRhKSB7XG4gICAgc3VwZXIuYWxpYXNTdGF0ZWxlc3MoZGF0YS5hbGlhcywgZGF0YS5kaXN0aW5jdElkLCB1bmRlZmluZWQsIHtcbiAgICAgIGRpc2FibGVHZW9pcDogZGF0YS5kaXNhYmxlR2VvaXBcbiAgICB9KTtcbiAgfVxuICBhc3luYyBhbGlhc0ltbWVkaWF0ZShkYXRhKSB7XG4gICAgYXdhaXQgc3VwZXIuYWxpYXNTdGF0ZWxlc3NJbW1lZGlhdGUoZGF0YS5hbGlhcywgZGF0YS5kaXN0aW5jdElkLCB1bmRlZmluZWQsIHtcbiAgICAgIGRpc2FibGVHZW9pcDogZGF0YS5kaXNhYmxlR2VvaXBcbiAgICB9KTtcbiAgfVxuICBpc0xvY2FsRXZhbHVhdGlvblJlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVGbGFnc1BvbGxlcj8uaXNMb2NhbEV2YWx1YXRpb25SZWFkeSgpID8/IGZhbHNlO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JMb2NhbEV2YWx1YXRpb25SZWFkeSh0aW1lb3V0TXMgPSBUSElSVFlfU0VDT05EUykge1xuICAgIGlmICh0aGlzLmlzTG9jYWxFdmFsdWF0aW9uUmVhZHkoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmZlYXR1cmVGbGFnc1BvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH0sIHRpbWVvdXRNcyk7XG4gICAgICBjb25zdCBjbGVhbnVwID0gdGhpcy5fZXZlbnRzLm9uKCdsb2NhbEV2YWx1YXRpb25GbGFnc0xvYWRlZCcsIGNvdW50ID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHJlc29sdmUoY291bnQgPiAwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldEZlYXR1cmVGbGFnKGtleSwgZGlzdGluY3RJZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGdyb3VwcyxcbiAgICAgIGRpc2FibGVHZW9pcFxuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGxldCB7XG4gICAgICBvbmx5RXZhbHVhdGVMb2NhbGx5LFxuICAgICAgc2VuZEZlYXR1cmVGbGFnRXZlbnRzLFxuICAgICAgcGVyc29uUHJvcGVydGllcyxcbiAgICAgIGdyb3VwUHJvcGVydGllc1xuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGFkanVzdGVkUHJvcGVydGllcyA9IHRoaXMuYWRkTG9jYWxQZXJzb25BbmRHcm91cFByb3BlcnRpZXMoZGlzdGluY3RJZCwgZ3JvdXBzLCBwZXJzb25Qcm9wZXJ0aWVzLCBncm91cFByb3BlcnRpZXMpO1xuICAgIHBlcnNvblByb3BlcnRpZXMgPSBhZGp1c3RlZFByb3BlcnRpZXMuYWxsUGVyc29uUHJvcGVydGllcztcbiAgICBncm91cFByb3BlcnRpZXMgPSBhZGp1c3RlZFByb3BlcnRpZXMuYWxsR3JvdXBQcm9wZXJ0aWVzO1xuICAgIC8vIHNldCBkZWZhdWx0c1xuICAgIGlmIChvbmx5RXZhbHVhdGVMb2NhbGx5ID09IHVuZGVmaW5lZCkge1xuICAgICAgb25seUV2YWx1YXRlTG9jYWxseSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc2VuZEZlYXR1cmVGbGFnRXZlbnRzID09IHVuZGVmaW5lZCkge1xuICAgICAgc2VuZEZlYXR1cmVGbGFnRXZlbnRzID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZWF0dXJlRmxhZ3NQb2xsZXI/LmdldEZlYXR1cmVGbGFnKGtleSwgZGlzdGluY3RJZCwgZ3JvdXBzLCBwZXJzb25Qcm9wZXJ0aWVzLCBncm91cFByb3BlcnRpZXMpO1xuICAgIGNvbnN0IGZsYWdXYXNMb2NhbGx5RXZhbHVhdGVkID0gcmVzcG9uc2UgIT09IHVuZGVmaW5lZDtcbiAgICBsZXQgcmVxdWVzdElkID0gdW5kZWZpbmVkO1xuICAgIGxldCBmbGFnRGV0YWlsID0gdW5kZWZpbmVkO1xuICAgIGlmICghZmxhZ1dhc0xvY2FsbHlFdmFsdWF0ZWQgJiYgIW9ubHlFdmFsdWF0ZUxvY2FsbHkpIHtcbiAgICAgIGNvbnN0IHJlbW90ZVJlc3BvbnNlID0gYXdhaXQgc3VwZXIuZ2V0RmVhdHVyZUZsYWdEZXRhaWxTdGF0ZWxlc3Moa2V5LCBkaXN0aW5jdElkLCBncm91cHMsIHBlcnNvblByb3BlcnRpZXMsIGdyb3VwUHJvcGVydGllcywgZGlzYWJsZUdlb2lwKTtcbiAgICAgIGlmIChyZW1vdGVSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBmbGFnRGV0YWlsID0gcmVtb3RlUmVzcG9uc2UucmVzcG9uc2U7XG4gICAgICByZXNwb25zZSA9IGdldEZlYXR1cmVGbGFnVmFsdWUoZmxhZ0RldGFpbCk7XG4gICAgICByZXF1ZXN0SWQgPSByZW1vdGVSZXNwb25zZT8ucmVxdWVzdElkO1xuICAgIH1cbiAgICBjb25zdCBmZWF0dXJlRmxhZ1JlcG9ydGVkS2V5ID0gYCR7a2V5fV8ke3Jlc3BvbnNlfWA7XG4gICAgaWYgKHNlbmRGZWF0dXJlRmxhZ0V2ZW50cyAmJiAoIShkaXN0aW5jdElkIGluIHRoaXMuZGlzdGluY3RJZEhhc1NlbnRGbGFnQ2FsbHMpIHx8ICF0aGlzLmRpc3RpbmN0SWRIYXNTZW50RmxhZ0NhbGxzW2Rpc3RpbmN0SWRdLmluY2x1ZGVzKGZlYXR1cmVGbGFnUmVwb3J0ZWRLZXkpKSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZGlzdGluY3RJZEhhc1NlbnRGbGFnQ2FsbHMpLmxlbmd0aCA+PSB0aGlzLm1heENhY2hlU2l6ZSkge1xuICAgICAgICB0aGlzLmRpc3RpbmN0SWRIYXNTZW50RmxhZ0NhbGxzID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmRpc3RpbmN0SWRIYXNTZW50RmxhZ0NhbGxzW2Rpc3RpbmN0SWRdKSkge1xuICAgICAgICB0aGlzLmRpc3RpbmN0SWRIYXNTZW50RmxhZ0NhbGxzW2Rpc3RpbmN0SWRdLnB1c2goZmVhdHVyZUZsYWdSZXBvcnRlZEtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3RpbmN0SWRIYXNTZW50RmxhZ0NhbGxzW2Rpc3RpbmN0SWRdID0gW2ZlYXR1cmVGbGFnUmVwb3J0ZWRLZXldO1xuICAgICAgfVxuICAgICAgdGhpcy5jYXB0dXJlKHtcbiAgICAgICAgZGlzdGluY3RJZCxcbiAgICAgICAgZXZlbnQ6ICckZmVhdHVyZV9mbGFnX2NhbGxlZCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAkZmVhdHVyZV9mbGFnOiBrZXksXG4gICAgICAgICAgJGZlYXR1cmVfZmxhZ19yZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgJGZlYXR1cmVfZmxhZ19pZDogZmxhZ0RldGFpbD8ubWV0YWRhdGE/LmlkLFxuICAgICAgICAgICRmZWF0dXJlX2ZsYWdfdmVyc2lvbjogZmxhZ0RldGFpbD8ubWV0YWRhdGE/LnZlcnNpb24sXG4gICAgICAgICAgJGZlYXR1cmVfZmxhZ19yZWFzb246IGZsYWdEZXRhaWw/LnJlYXNvbj8uZGVzY3JpcHRpb24gPz8gZmxhZ0RldGFpbD8ucmVhc29uPy5jb2RlLFxuICAgICAgICAgIGxvY2FsbHlfZXZhbHVhdGVkOiBmbGFnV2FzTG9jYWxseUV2YWx1YXRlZCxcbiAgICAgICAgICBbYCRmZWF0dXJlLyR7a2V5fWBdOiByZXNwb25zZSxcbiAgICAgICAgICAkZmVhdHVyZV9mbGFnX3JlcXVlc3RfaWQ6IHJlcXVlc3RJZFxuICAgICAgICB9LFxuICAgICAgICBncm91cHMsXG4gICAgICAgIGRpc2FibGVHZW9pcFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBhc3luYyBnZXRGZWF0dXJlRmxhZ1BheWxvYWQoa2V5LCBkaXN0aW5jdElkLCBtYXRjaFZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZ3JvdXBzLFxuICAgICAgZGlzYWJsZUdlb2lwXG4gICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgbGV0IHtcbiAgICAgIG9ubHlFdmFsdWF0ZUxvY2FsbHksXG4gICAgICBzZW5kRmVhdHVyZUZsYWdFdmVudHMsXG4gICAgICBwZXJzb25Qcm9wZXJ0aWVzLFxuICAgICAgZ3JvdXBQcm9wZXJ0aWVzXG4gICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgYWRqdXN0ZWRQcm9wZXJ0aWVzID0gdGhpcy5hZGRMb2NhbFBlcnNvbkFuZEdyb3VwUHJvcGVydGllcyhkaXN0aW5jdElkLCBncm91cHMsIHBlcnNvblByb3BlcnRpZXMsIGdyb3VwUHJvcGVydGllcyk7XG4gICAgcGVyc29uUHJvcGVydGllcyA9IGFkanVzdGVkUHJvcGVydGllcy5hbGxQZXJzb25Qcm9wZXJ0aWVzO1xuICAgIGdyb3VwUHJvcGVydGllcyA9IGFkanVzdGVkUHJvcGVydGllcy5hbGxHcm91cFByb3BlcnRpZXM7XG4gICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxvY2FsRXZhbHVhdGlvbkVuYWJsZWQgPSB0aGlzLmZlYXR1cmVGbGFnc1BvbGxlciAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChsb2NhbEV2YWx1YXRpb25FbmFibGVkKSB7XG4gICAgICAvLyBUcnkgdG8gZ2V0IG1hdGNoIHZhbHVlIGxvY2FsbHkgaWYgbm90IHByb3ZpZGVkXG4gICAgICBpZiAoIW1hdGNoVmFsdWUpIHtcbiAgICAgICAgbWF0Y2hWYWx1ZSA9IGF3YWl0IHRoaXMuZ2V0RmVhdHVyZUZsYWcoa2V5LCBkaXN0aW5jdElkLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBvbmx5RXZhbHVhdGVMb2NhbGx5OiB0cnVlLFxuICAgICAgICAgIHNlbmRGZWF0dXJlRmxhZ0V2ZW50czogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2hWYWx1ZSkge1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmVhdHVyZUZsYWdzUG9sbGVyPy5jb21wdXRlRmVhdHVyZUZsYWdQYXlsb2FkTG9jYWxseShrZXksIG1hdGNoVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvL31cbiAgICAvLyBzZXQgZGVmYXVsdHNcbiAgICBpZiAob25seUV2YWx1YXRlTG9jYWxseSA9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9ubHlFdmFsdWF0ZUxvY2FsbHkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNlbmRGZWF0dXJlRmxhZ0V2ZW50cyA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlbmRGZWF0dXJlRmxhZ0V2ZW50cyA9IHRydWU7XG4gICAgfVxuICAgIC8vIHNldCBkZWZhdWx0c1xuICAgIGlmIChvbmx5RXZhbHVhdGVMb2NhbGx5ID09IHVuZGVmaW5lZCkge1xuICAgICAgb25seUV2YWx1YXRlTG9jYWxseSA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkV2FzTG9jYWxseUV2YWx1YXRlZCA9IHJlc3BvbnNlICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKCFwYXlsb2FkV2FzTG9jYWxseUV2YWx1YXRlZCAmJiAhb25seUV2YWx1YXRlTG9jYWxseSkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBzdXBlci5nZXRGZWF0dXJlRmxhZ1BheWxvYWRTdGF0ZWxlc3Moa2V5LCBkaXN0aW5jdElkLCBncm91cHMsIHBlcnNvblByb3BlcnRpZXMsIGdyb3VwUHJvcGVydGllcywgZGlzYWJsZUdlb2lwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIGFzeW5jIGdldFJlbW90ZUNvbmZpZ1BheWxvYWQoZmxhZ0tleSkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnBlcnNvbmFsQXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BlcnNvbmFsIEFQSSBrZXkgaXMgcmVxdWlyZWQgZm9yIHJlbW90ZSBjb25maWcgcGF5bG9hZCBkZWNyeXB0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcmVxdWVzdFJlbW90ZUNvbmZpZ1BheWxvYWQoZmxhZ0tleSk7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIC8vIFRoZSBwYXlsb2FkIGZyb20gdGhlIGVuZHBvaW50IGlzIHN0b3JlZCBhcyBhIEpTT04gZW5jb2RlZCBzdHJpbmcuIFNvIHdoZW4gd2UgcmV0dXJuXG4gICAgLy8gaXQsIGl0J3MgZWZmZWN0aXZlbHkgZG91YmxlIGVuY29kZWQuIEFzIGZhciBhcyB3ZSBrbm93LCB3ZSBzaG91bGQgbmV2ZXIgZ2V0IHNpbmdsZS1lbmNvZGVkXG4gICAgLy8gSlNPTiwgYnV0IHdlJ2xsIGJlIGRlZmVuc2l2ZSBoZXJlIGp1c3QgaW4gY2FzZS5cbiAgICBpZiAodHlwZW9mIHBhcnNlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIElmIHRoZSBwYXJzZWQgdmFsdWUgaXMgYSBzdHJpbmcsIHRyeSBwYXJzaW5nIGl0IGFnYWluIHRvIGhhbmRsZSBkb3VibGUtZW5jb2RlZCBKU09OXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHBhcnNlZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIHNlY29uZCBwYXJzZSBmYWlscywgcmV0dXJuIHRoZSBzdHJpbmcgYXMgaXNcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBhc3luYyBpc0ZlYXR1cmVFbmFibGVkKGtleSwgZGlzdGluY3RJZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZlYXQgPSBhd2FpdCB0aGlzLmdldEZlYXR1cmVGbGFnKGtleSwgZGlzdGluY3RJZCwgb3B0aW9ucyk7XG4gICAgaWYgKGZlYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuICEhZmVhdCB8fCBmYWxzZTtcbiAgfVxuICBhc3luYyBnZXRBbGxGbGFncyhkaXN0aW5jdElkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldEFsbEZsYWdzQW5kUGF5bG9hZHMoZGlzdGluY3RJZCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmZlYXR1cmVGbGFncyB8fCB7fTtcbiAgfVxuICBhc3luYyBnZXRBbGxGbGFnc0FuZFBheWxvYWRzKGRpc3RpbmN0SWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBncm91cHMsXG4gICAgICBkaXNhYmxlR2VvaXAsXG4gICAgICBmbGFnS2V5c1xuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGxldCB7XG4gICAgICBvbmx5RXZhbHVhdGVMb2NhbGx5LFxuICAgICAgcGVyc29uUHJvcGVydGllcyxcbiAgICAgIGdyb3VwUHJvcGVydGllc1xuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGFkanVzdGVkUHJvcGVydGllcyA9IHRoaXMuYWRkTG9jYWxQZXJzb25BbmRHcm91cFByb3BlcnRpZXMoZGlzdGluY3RJZCwgZ3JvdXBzLCBwZXJzb25Qcm9wZXJ0aWVzLCBncm91cFByb3BlcnRpZXMpO1xuICAgIHBlcnNvblByb3BlcnRpZXMgPSBhZGp1c3RlZFByb3BlcnRpZXMuYWxsUGVyc29uUHJvcGVydGllcztcbiAgICBncm91cFByb3BlcnRpZXMgPSBhZGp1c3RlZFByb3BlcnRpZXMuYWxsR3JvdXBQcm9wZXJ0aWVzO1xuICAgIC8vIHNldCBkZWZhdWx0c1xuICAgIGlmIChvbmx5RXZhbHVhdGVMb2NhbGx5ID09IHVuZGVmaW5lZCkge1xuICAgICAgb25seUV2YWx1YXRlTG9jYWxseSA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbEV2YWx1YXRpb25SZXN1bHQgPSBhd2FpdCB0aGlzLmZlYXR1cmVGbGFnc1BvbGxlcj8uZ2V0QWxsRmxhZ3NBbmRQYXlsb2FkcyhkaXN0aW5jdElkLCBncm91cHMsIHBlcnNvblByb3BlcnRpZXMsIGdyb3VwUHJvcGVydGllcywgZmxhZ0tleXMpO1xuICAgIGxldCBmZWF0dXJlRmxhZ3MgPSB7fTtcbiAgICBsZXQgZmVhdHVyZUZsYWdQYXlsb2FkcyA9IHt9O1xuICAgIGxldCBmYWxsYmFja1RvRmxhZ3MgPSB0cnVlO1xuICAgIGlmIChsb2NhbEV2YWx1YXRpb25SZXN1bHQpIHtcbiAgICAgIGZlYXR1cmVGbGFncyA9IGxvY2FsRXZhbHVhdGlvblJlc3VsdC5yZXNwb25zZTtcbiAgICAgIGZlYXR1cmVGbGFnUGF5bG9hZHMgPSBsb2NhbEV2YWx1YXRpb25SZXN1bHQucGF5bG9hZHM7XG4gICAgICBmYWxsYmFja1RvRmxhZ3MgPSBsb2NhbEV2YWx1YXRpb25SZXN1bHQuZmFsbGJhY2tUb0ZsYWdzO1xuICAgIH1cbiAgICBpZiAoZmFsbGJhY2tUb0ZsYWdzICYmICFvbmx5RXZhbHVhdGVMb2NhbGx5KSB7XG4gICAgICBjb25zdCByZW1vdGVFdmFsdWF0aW9uUmVzdWx0ID0gYXdhaXQgc3VwZXIuZ2V0RmVhdHVyZUZsYWdzQW5kUGF5bG9hZHNTdGF0ZWxlc3MoZGlzdGluY3RJZCwgZ3JvdXBzLCBwZXJzb25Qcm9wZXJ0aWVzLCBncm91cFByb3BlcnRpZXMsIGRpc2FibGVHZW9pcCwgZmxhZ0tleXMpO1xuICAgICAgZmVhdHVyZUZsYWdzID0ge1xuICAgICAgICAuLi5mZWF0dXJlRmxhZ3MsXG4gICAgICAgIC4uLihyZW1vdGVFdmFsdWF0aW9uUmVzdWx0LmZsYWdzIHx8IHt9KVxuICAgICAgfTtcbiAgICAgIGZlYXR1cmVGbGFnUGF5bG9hZHMgPSB7XG4gICAgICAgIC4uLmZlYXR1cmVGbGFnUGF5bG9hZHMsXG4gICAgICAgIC4uLihyZW1vdGVFdmFsdWF0aW9uUmVzdWx0LnBheWxvYWRzIHx8IHt9KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZlYXR1cmVGbGFncyxcbiAgICAgIGZlYXR1cmVGbGFnUGF5bG9hZHNcbiAgICB9O1xuICB9XG4gIGdyb3VwSWRlbnRpZnkoe1xuICAgIGdyb3VwVHlwZSxcbiAgICBncm91cEtleSxcbiAgICBwcm9wZXJ0aWVzLFxuICAgIGRpc3RpbmN0SWQsXG4gICAgZGlzYWJsZUdlb2lwXG4gIH0pIHtcbiAgICBzdXBlci5ncm91cElkZW50aWZ5U3RhdGVsZXNzKGdyb3VwVHlwZSwgZ3JvdXBLZXksIHByb3BlcnRpZXMsIHtcbiAgICAgIGRpc2FibGVHZW9pcFxuICAgIH0sIGRpc3RpbmN0SWQpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlbG9hZHMgdGhlIGZlYXR1cmUgZmxhZyBkZWZpbml0aW9ucyBmcm9tIHRoZSBzZXJ2ZXIgZm9yIGxvY2FsIGV2YWx1YXRpb24uXHJcbiAgICogVGhpcyBpcyB1c2VmdWwgdG8gY2FsbCBpZiB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCB0aGUgZmVhdHVyZSBmbGFncyBhcmUgdXAgdG8gZGF0ZSBiZWZvcmUgY2FsbGluZyBnZXRGZWF0dXJlRmxhZy5cclxuICAgKi9cbiAgYXN5bmMgcmVsb2FkRmVhdHVyZUZsYWdzKCkge1xuICAgIGF3YWl0IHRoaXMuZmVhdHVyZUZsYWdzUG9sbGVyPy5sb2FkRmVhdHVyZUZsYWdzKHRydWUpO1xuICB9XG4gIGFzeW5jIF9zaHV0ZG93bihzaHV0ZG93blRpbWVvdXRNcykge1xuICAgIHRoaXMuZmVhdHVyZUZsYWdzUG9sbGVyPy5zdG9wUG9sbGVyKCk7XG4gICAgcmV0dXJuIHN1cGVyLl9zaHV0ZG93bihzaHV0ZG93blRpbWVvdXRNcyk7XG4gIH1cbiAgYXN5bmMgX3JlcXVlc3RSZW1vdGVDb25maWdQYXlsb2FkKGZsYWdLZXkpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5wZXJzb25hbEFwaUtleSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5ob3N0fS9hcGkvcHJvamVjdHMvQGN1cnJlbnQvZmVhdHVyZV9mbGFncy8ke2ZsYWdLZXl9L3JlbW90ZV9jb25maWcvYDtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4udGhpcy5nZXRDdXN0b21IZWFkZXJzKCksXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLm9wdGlvbnMucGVyc29uYWxBcGlLZXl9YFxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGFib3J0VGltZW91dCA9IG51bGw7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXF1ZXN0VGltZW91dCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLnJlcXVlc3RUaW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGFib3J0VGltZW91dCA9IHNhZmVTZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfSwgdGhpcy5vcHRpb25zLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIG9wdGlvbnMuc2lnbmFsID0gY29udHJvbGxlci5zaWduYWw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLl9ldmVudHMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoYWJvcnRUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhYm9ydFRpbWVvdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBleHRyYWN0UHJvcGVydGllc0Zyb21FdmVudChldmVudFByb3BlcnRpZXMsIGdyb3Vwcykge1xuICAgIGlmICghZXZlbnRQcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwZXJzb25Qcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgZ3JvdXBQcm9wZXJ0aWVzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcGVyc29uUHJvcGVydGllcyA9IHt9O1xuICAgIGNvbnN0IGdyb3VwUHJvcGVydGllcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGV2ZW50UHJvcGVydGllcykpIHtcbiAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCBhbmQgdGhlIGtleSBleGlzdHMgaW4gZ3JvdXBzLCB0cmVhdCBpdCBhcyBncm91cCBwcm9wZXJ0aWVzXG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgZ3JvdXBzICYmIGtleSBpbiBncm91cHMpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBQcm9wcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtncm91cEtleSwgZ3JvdXBWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgZ3JvdXBQcm9wc1tTdHJpbmcoZ3JvdXBLZXkpXSA9IFN0cmluZyhncm91cFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBncm91cFByb3BlcnRpZXNbU3RyaW5nKGtleSldID0gZ3JvdXBQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSB0cmVhdCBhcyBwZXJzb24gcHJvcGVydHlcbiAgICAgICAgcGVyc29uUHJvcGVydGllc1tTdHJpbmcoa2V5KV0gPSBTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGVyc29uUHJvcGVydGllcyxcbiAgICAgIGdyb3VwUHJvcGVydGllc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZ2V0RmVhdHVyZUZsYWdzRm9yRXZlbnQoZGlzdGluY3RJZCwgZ3JvdXBzLCBkaXNhYmxlR2VvaXAsIHNlbmRGZWF0dXJlRmxhZ3NPcHRpb25zKSB7XG4gICAgLy8gVXNlIHByb3BlcnRpZXMgZGlyZWN0bHkgZnJvbSBvcHRpb25zIGlmIHRoZXkgZXhpc3RcbiAgICBjb25zdCBmaW5hbFBlcnNvblByb3BlcnRpZXMgPSBzZW5kRmVhdHVyZUZsYWdzT3B0aW9ucz8ucGVyc29uUHJvcGVydGllcyB8fCB7fTtcbiAgICBjb25zdCBmaW5hbEdyb3VwUHJvcGVydGllcyA9IHNlbmRGZWF0dXJlRmxhZ3NPcHRpb25zPy5ncm91cFByb3BlcnRpZXMgfHwge307XG4gICAgY29uc3QgZmxhZ0tleXMgPSBzZW5kRmVhdHVyZUZsYWdzT3B0aW9ucz8uZmxhZ0tleXM7XG4gICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIG9ubHkgZXZhbHVhdGUgbG9jYWxseVxuICAgIGNvbnN0IG9ubHlFdmFsdWF0ZUxvY2FsbHkgPSBzZW5kRmVhdHVyZUZsYWdzT3B0aW9ucz8ub25seUV2YWx1YXRlTG9jYWxseSA/PyBmYWxzZTtcbiAgICAvLyBJZiBvbmx5RXZhbHVhdGVMb2NhbGx5IGlzIHRydWUsIG9ubHkgdXNlIGxvY2FsIGV2YWx1YXRpb25cbiAgICBpZiAob25seUV2YWx1YXRlTG9jYWxseSkge1xuICAgICAgaWYgKCh0aGlzLmZlYXR1cmVGbGFnc1BvbGxlcj8uZmVhdHVyZUZsYWdzPy5sZW5ndGggfHwgMCkgPiAwKSB7XG4gICAgICAgIGNvbnN0IGdyb3Vwc1dpdGhTdHJpbmdWYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZ3JvdXBzIHx8IHt9KSkge1xuICAgICAgICAgIGdyb3Vwc1dpdGhTdHJpbmdWYWx1ZXNba2V5XSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QWxsRmxhZ3MoZGlzdGluY3RJZCwge1xuICAgICAgICAgIGdyb3VwczogZ3JvdXBzV2l0aFN0cmluZ1ZhbHVlcyxcbiAgICAgICAgICBwZXJzb25Qcm9wZXJ0aWVzOiBmaW5hbFBlcnNvblByb3BlcnRpZXMsXG4gICAgICAgICAgZ3JvdXBQcm9wZXJ0aWVzOiBmaW5hbEdyb3VwUHJvcGVydGllcyxcbiAgICAgICAgICBkaXNhYmxlR2VvaXAsXG4gICAgICAgICAgb25seUV2YWx1YXRlTG9jYWxseTogdHJ1ZSxcbiAgICAgICAgICBmbGFnS2V5c1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG9ubHlFdmFsdWF0ZUxvY2FsbHkgaXMgdHJ1ZSBidXQgd2UgZG9uJ3QgaGF2ZSBsb2NhbCBmbGFncywgcmV0dXJuIGVtcHR5XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJlZmVyIGxvY2FsIGV2YWx1YXRpb24gaWYgYXZhaWxhYmxlIChkZWZhdWx0IGJlaGF2aW9yOyBJJ2QgcmF0aGVyIG5vdCBwZW5hbGl6ZSB1c2VycyB3aG8gaGF2ZW4ndCB1cGRhdGVkIHRvIHRoZSBuZXcgQVBJIGJ1dCBzdGlsbCB3YW50IHRvIHVzZSBsb2NhbCBldmFsdWF0aW9uKVxuICAgIGlmICgodGhpcy5mZWF0dXJlRmxhZ3NQb2xsZXI/LmZlYXR1cmVGbGFncz8ubGVuZ3RoIHx8IDApID4gMCkge1xuICAgICAgY29uc3QgZ3JvdXBzV2l0aFN0cmluZ1ZhbHVlcyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZ3JvdXBzIHx8IHt9KSkge1xuICAgICAgICBncm91cHNXaXRoU3RyaW5nVmFsdWVzW2tleV0gPSBTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QWxsRmxhZ3MoZGlzdGluY3RJZCwge1xuICAgICAgICBncm91cHM6IGdyb3Vwc1dpdGhTdHJpbmdWYWx1ZXMsXG4gICAgICAgIHBlcnNvblByb3BlcnRpZXM6IGZpbmFsUGVyc29uUHJvcGVydGllcyxcbiAgICAgICAgZ3JvdXBQcm9wZXJ0aWVzOiBmaW5hbEdyb3VwUHJvcGVydGllcyxcbiAgICAgICAgZGlzYWJsZUdlb2lwLFxuICAgICAgICBvbmx5RXZhbHVhdGVMb2NhbGx5OiB0cnVlLFxuICAgICAgICBmbGFnS2V5c1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZhbGwgYmFjayB0byByZW1vdGUgZXZhbHVhdGlvbiBpZiBsb2NhbCBldmFsdWF0aW9uIGlzIG5vdCBhdmFpbGFibGVcbiAgICByZXR1cm4gKGF3YWl0IHN1cGVyLmdldEZlYXR1cmVGbGFnc1N0YXRlbGVzcyhkaXN0aW5jdElkLCBncm91cHMsIGZpbmFsUGVyc29uUHJvcGVydGllcywgZmluYWxHcm91cFByb3BlcnRpZXMsIGRpc2FibGVHZW9pcCkpLmZsYWdzO1xuICB9XG4gIGFkZExvY2FsUGVyc29uQW5kR3JvdXBQcm9wZXJ0aWVzKGRpc3RpbmN0SWQsIGdyb3VwcywgcGVyc29uUHJvcGVydGllcywgZ3JvdXBQcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgYWxsUGVyc29uUHJvcGVydGllcyA9IHtcbiAgICAgIGRpc3RpbmN0X2lkOiBkaXN0aW5jdElkLFxuICAgICAgLi4uKHBlcnNvblByb3BlcnRpZXMgfHwge30pXG4gICAgfTtcbiAgICBjb25zdCBhbGxHcm91cFByb3BlcnRpZXMgPSB7fTtcbiAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwTmFtZSBvZiBPYmplY3Qua2V5cyhncm91cHMpKSB7XG4gICAgICAgIGFsbEdyb3VwUHJvcGVydGllc1tncm91cE5hbWVdID0ge1xuICAgICAgICAgICRncm91cF9rZXk6IGdyb3Vwc1tncm91cE5hbWVdLFxuICAgICAgICAgIC4uLihncm91cFByb3BlcnRpZXM/Lltncm91cE5hbWVdIHx8IHt9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYWxsUGVyc29uUHJvcGVydGllcyxcbiAgICAgIGFsbEdyb3VwUHJvcGVydGllc1xuICAgIH07XG4gIH1cbiAgY2FwdHVyZUV4Y2VwdGlvbihlcnJvciwgZGlzdGluY3RJZCwgYWRkaXRpb25hbFByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBzeW50aGV0aWNFeGNlcHRpb24gPSBuZXcgRXJyb3IoJ1Bvc3RIb2cgc3ludGhldGljRXhjZXB0aW9uJyk7XG4gICAgRXJyb3JUcmFja2luZy5idWlsZEV2ZW50TWVzc2FnZShlcnJvciwge1xuICAgICAgc3ludGhldGljRXhjZXB0aW9uXG4gICAgfSwgZGlzdGluY3RJZCwgYWRkaXRpb25hbFByb3BlcnRpZXMpLnRoZW4obXNnID0+IHtcbiAgICAgIHRoaXMuY2FwdHVyZShtc2cpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNhcHR1cmVFeGNlcHRpb25JbW1lZGlhdGUoZXJyb3IsIGRpc3RpbmN0SWQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgY29uc3Qgc3ludGhldGljRXhjZXB0aW9uID0gbmV3IEVycm9yKCdQb3N0SG9nIHN5bnRoZXRpY0V4Y2VwdGlvbicpO1xuICAgIGNvbnN0IGV2dE1zZyA9IGF3YWl0IEVycm9yVHJhY2tpbmcuYnVpbGRFdmVudE1lc3NhZ2UoZXJyb3IsIHtcbiAgICAgIHN5bnRoZXRpY0V4Y2VwdGlvblxuICAgIH0sIGRpc3RpbmN0SWQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jYXB0dXJlSW1tZWRpYXRlKGV2dE1zZyk7XG4gIH1cbn1cblxuLy8gUG9ydGlvbnMgb2YgdGhpcyBmaWxlIGFyZSBkZXJpdmVkIGZyb20gZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0IGJ5IFNvZnR3YXJlLCBJbmMuIGRiYSBTZW50cnlcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBmb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3Nub3Zlci9UcmFjZUtpdCwgYW5kIHdhcyBsYXJnZWx5XG4vLyByZS13cml0dGVuIGFzIHBhcnQgb2YgcmF2ZW4gLSBqcy5cbi8vXG4vLyBUaGlzIGNvZGUgd2FzIGxhdGVyIGNvcGllZCB0byB0aGUgSmF2YVNjcmlwdCBtb25vIC0gcmVwbyBhbmQgZnVydGhlciBtb2RpZmllZCBhbmRcbi8vIHJlZmFjdG9yZWQgb3ZlciB0aGUgeWVhcnMuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgT251ciBDYW4gQ2FrbWFrIG9udXIuY2FrbWFrQGdtYWlsLmNvbSBhbmQgYWxsIFRyYWNlS2l0IGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXModGhlICdTb2Z0d2FyZScpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZCAvIG9yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzXG4vLyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5JTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbmNvbnN0IFdFQlBBQ0tfRVJST1JfUkVHRVhQID0gL1xcKGVycm9yOiAoLiopXFwpLztcbmNvbnN0IFNUQUNLVFJBQ0VfRlJBTUVfTElNSVQgPSA1MDtcbmNvbnN0IFVOS05PV05fRlVOQ1RJT04gPSAnPyc7XG4vKiogTm9kZSBTdGFjayBsaW5lIHBhcnNlciAqL1xuZnVuY3Rpb24gbm9kZShnZXRNb2R1bGUpIHtcbiAgY29uc3QgRklMRU5BTUVfTUFUQ0ggPSAvXlxccypbLV17NCx9JC87XG4gIGNvbnN0IEZVTExfTUFUQ0ggPSAvYXQgKD86YXN5bmMgKT8oPzooLis/KVxccytcXCgpPyg/OiguKyk6KFxcZCspOihcXGQrKT98KFteKV0rKSlcXCk/LztcbiAgcmV0dXJuIGxpbmUgPT4ge1xuICAgIGNvbnN0IGxpbmVNYXRjaCA9IGxpbmUubWF0Y2goRlVMTF9NQVRDSCk7XG4gICAgaWYgKGxpbmVNYXRjaCkge1xuICAgICAgbGV0IG9iamVjdDtcbiAgICAgIGxldCBtZXRob2Q7XG4gICAgICBsZXQgZnVuY3Rpb25OYW1lO1xuICAgICAgbGV0IHR5cGVOYW1lO1xuICAgICAgbGV0IG1ldGhvZE5hbWU7XG4gICAgICBpZiAobGluZU1hdGNoWzFdKSB7XG4gICAgICAgIGZ1bmN0aW9uTmFtZSA9IGxpbmVNYXRjaFsxXTtcbiAgICAgICAgbGV0IG1ldGhvZFN0YXJ0ID0gZnVuY3Rpb25OYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChmdW5jdGlvbk5hbWVbbWV0aG9kU3RhcnQgLSAxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgbWV0aG9kU3RhcnQtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kU3RhcnQgPiAwKSB7XG4gICAgICAgICAgb2JqZWN0ID0gZnVuY3Rpb25OYW1lLnNsaWNlKDAsIG1ldGhvZFN0YXJ0KTtcbiAgICAgICAgICBtZXRob2QgPSBmdW5jdGlvbk5hbWUuc2xpY2UobWV0aG9kU3RhcnQgKyAxKTtcbiAgICAgICAgICBjb25zdCBvYmplY3RFbmQgPSBvYmplY3QuaW5kZXhPZignLk1vZHVsZScpO1xuICAgICAgICAgIGlmIChvYmplY3RFbmQgPiAwKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWUuc2xpY2Uob2JqZWN0RW5kICsgMSk7XG4gICAgICAgICAgICBvYmplY3QgPSBvYmplY3Quc2xpY2UoMCwgb2JqZWN0RW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHlwZU5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIHR5cGVOYW1lID0gb2JqZWN0O1xuICAgICAgICBtZXRob2ROYW1lID0gbWV0aG9kO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGhvZCA9PT0gJzxhbm9ueW1vdXM+Jykge1xuICAgICAgICBtZXRob2ROYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZnVuY3Rpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWUgfHwgVU5LTk9XTl9GVU5DVElPTjtcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gdHlwZU5hbWUgPyBgJHt0eXBlTmFtZX0uJHttZXRob2ROYW1lfWAgOiBtZXRob2ROYW1lO1xuICAgICAgfVxuICAgICAgbGV0IGZpbGVuYW1lID0gbGluZU1hdGNoWzJdPy5zdGFydHNXaXRoKCdmaWxlOi8vJykgPyBsaW5lTWF0Y2hbMl0uc2xpY2UoNykgOiBsaW5lTWF0Y2hbMl07XG4gICAgICBjb25zdCBpc05hdGl2ZSA9IGxpbmVNYXRjaFs1XSA9PT0gJ25hdGl2ZSc7XG4gICAgICAvLyBJZiBpdCdzIGEgV2luZG93cyBwYXRoLCB0cmltIHRoZSBsZWFkaW5nIHNsYXNoIHNvIHRoYXQgYC9DOi9mb29gIGJlY29tZXMgYEM6L2Zvb2BcbiAgICAgIGlmIChmaWxlbmFtZT8ubWF0Y2goL1xcL1tBLVpdOi8pKSB7XG4gICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZpbGVuYW1lICYmIGxpbmVNYXRjaFs1XSAmJiAhaXNOYXRpdmUpIHtcbiAgICAgICAgZmlsZW5hbWUgPSBsaW5lTWF0Y2hbNV07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWUgPyBkZWNvZGVVUkkoZmlsZW5hbWUpIDogdW5kZWZpbmVkLFxuICAgICAgICBtb2R1bGU6IGdldE1vZHVsZSA/IGdldE1vZHVsZShmaWxlbmFtZSkgOiB1bmRlZmluZWQsXG4gICAgICAgIGZ1bmN0aW9uOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgIGxpbmVubzogX3BhcnNlSW50T3JVbmRlZmluZWQobGluZU1hdGNoWzNdKSxcbiAgICAgICAgY29sbm86IF9wYXJzZUludE9yVW5kZWZpbmVkKGxpbmVNYXRjaFs0XSksXG4gICAgICAgIGluX2FwcDogZmlsZW5hbWVJc0luQXBwKGZpbGVuYW1lIHx8ICcnLCBpc05hdGl2ZSksXG4gICAgICAgIHBsYXRmb3JtOiAnbm9kZTpqYXZhc2NyaXB0J1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGxpbmUubWF0Y2goRklMRU5BTUVfTUFUQ0gpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWxlbmFtZTogbGluZSxcbiAgICAgICAgcGxhdGZvcm06ICdub2RlOmphdmFzY3JpcHQnXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xufVxuLyoqXHJcbiAqIERvZXMgdGhpcyBmaWxlbmFtZSBsb29rIGxpa2UgaXQncyBwYXJ0IG9mIHRoZSBhcHAgY29kZT9cclxuICovXG5mdW5jdGlvbiBmaWxlbmFtZUlzSW5BcHAoZmlsZW5hbWUsIGlzTmF0aXZlID0gZmFsc2UpIHtcbiAgY29uc3QgaXNJbnRlcm5hbCA9IGlzTmF0aXZlIHx8IGZpbGVuYW1lICYmXG4gIC8vIEl0J3Mgbm90IGludGVybmFsIGlmIGl0J3MgYW4gYWJzb2x1dGUgbGludXggcGF0aFxuICAhZmlsZW5hbWUuc3RhcnRzV2l0aCgnLycpICYmXG4gIC8vIEl0J3Mgbm90IGludGVybmFsIGlmIGl0J3MgYW4gYWJzb2x1dGUgd2luZG93cyBwYXRoXG4gICFmaWxlbmFtZS5tYXRjaCgvXltBLVpdOi8pICYmXG4gIC8vIEl0J3Mgbm90IGludGVybmFsIGlmIHRoZSBwYXRoIGlzIHN0YXJ0aW5nIHdpdGggYSBkb3RcbiAgIWZpbGVuYW1lLnN0YXJ0c1dpdGgoJy4nKSAmJlxuICAvLyBJdCdzIG5vdCBpbnRlcm5hbCBpZiB0aGUgZnJhbWUgaGFzIGEgcHJvdG9jb2wuIEluIG5vZGUsIHRoaXMgaXMgdXN1YWxseSB0aGUgY2FzZSBpZiB0aGUgZmlsZSBnb3QgcHJlLXByb2Nlc3NlZCB3aXRoIGEgYnVuZGxlciBsaWtlIHdlYnBhY2tcbiAgIWZpbGVuYW1lLm1hdGNoKC9eW2EtekEtWl0oW2EtekEtWjAtOS5cXC0rXSkqOlxcL1xcLy8pOyAvLyBTY2hlbWEgZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM2NDE3ODJcbiAgLy8gaW5fYXBwIGlzIGFsbCB0aGF0J3Mgbm90IGFuIGludGVybmFsIE5vZGUgZnVuY3Rpb24gb3IgYSBtb2R1bGUgd2l0aGluIG5vZGVfbW9kdWxlc1xuICAvLyBub3RlIHRoYXQgaXNOYXRpdmUgYXBwZWFycyB0byByZXR1cm4gdHJ1ZSBldmVuIGZvciBub2RlIGNvcmUgbGlicmFyaWVzXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3JhdmVuLW5vZGUvaXNzdWVzLzE3NlxuICByZXR1cm4gIWlzSW50ZXJuYWwgJiYgZmlsZW5hbWUgIT09IHVuZGVmaW5lZCAmJiAhZmlsZW5hbWUuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcy8nKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUludE9yVW5kZWZpbmVkKGlucHV0KSB7XG4gIHJldHVybiBwYXJzZUludChpbnB1dCB8fCAnJywgMTApIHx8IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIG5vZGVTdGFja0xpbmVQYXJzZXIoZ2V0TW9kdWxlKSB7XG4gIHJldHVybiBbOTAsIG5vZGUoZ2V0TW9kdWxlKV07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGFja1BhcnNlcihnZXRNb2R1bGUpIHtcbiAgY29uc3QgcGFyc2VycyA9IFtub2RlU3RhY2tMaW5lUGFyc2VyKGdldE1vZHVsZSldO1xuICBjb25zdCBzb3J0ZWRQYXJzZXJzID0gcGFyc2Vycy5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSkubWFwKHAgPT4gcFsxXSk7XG4gIHJldHVybiAoc3RhY2ssIHNraXBGaXJzdExpbmVzID0gMCkgPT4ge1xuICAgIGNvbnN0IGZyYW1lcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGZvciAobGV0IGkgPSBza2lwRmlyc3RMaW5lczsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICAvLyBJZ25vcmUgbGluZXMgb3ZlciAxa2IgYXMgdGhleSBhcmUgdW5saWtlbHkgdG8gYmUgc3RhY2sgZnJhbWVzLlxuICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzU0NTlcbiAgICAgIC8vIFJlbW92ZSB3ZWJwYWNrIChlcnJvcjogKikgd3JhcHBlcnNcbiAgICAgIGNvbnN0IGNsZWFuZWRMaW5lID0gV0VCUEFDS19FUlJPUl9SRUdFWFAudGVzdChsaW5lKSA/IGxpbmUucmVwbGFjZShXRUJQQUNLX0VSUk9SX1JFR0VYUCwgJyQxJykgOiBsaW5lO1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvNzgxM1xuICAgICAgLy8gU2tpcCBFcnJvcjogbGluZXNcbiAgICAgIGlmIChjbGVhbmVkTGluZS5tYXRjaCgvXFxTKkVycm9yOiAvKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgcGFyc2VyIG9mIHNvcnRlZFBhcnNlcnMpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBwYXJzZXIoY2xlYW5lZExpbmUpO1xuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZXMubGVuZ3RoID49IFNUQUNLVFJBQ0VfRlJBTUVfTElNSVQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXZlcnNlQW5kU3RyaXBGcmFtZXMoZnJhbWVzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VBbmRTdHJpcEZyYW1lcyhzdGFjaykge1xuICBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBsb2NhbFN0YWNrID0gQXJyYXkuZnJvbShzdGFjayk7XG4gIGxvY2FsU3RhY2sucmV2ZXJzZSgpO1xuICByZXR1cm4gbG9jYWxTdGFjay5zbGljZSgwLCBTVEFDS1RSQUNFX0ZSQU1FX0xJTUlUKS5tYXAoZnJhbWUgPT4gKHtcbiAgICAuLi5mcmFtZSxcbiAgICBmaWxlbmFtZTogZnJhbWUuZmlsZW5hbWUgfHwgZ2V0TGFzdFN0YWNrRnJhbWUobG9jYWxTdGFjaykuZmlsZW5hbWUsXG4gICAgZnVuY3Rpb246IGZyYW1lLmZ1bmN0aW9uIHx8IFVOS05PV05fRlVOQ1RJT05cbiAgfSkpO1xufVxuZnVuY3Rpb24gZ2V0TGFzdFN0YWNrRnJhbWUoYXJyKSB7XG4gIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdIHx8IHt9O1xufVxuXG5FcnJvclRyYWNraW5nLnN0YWNrUGFyc2VyID0gY3JlYXRlU3RhY2tQYXJzZXIoY3JlYXRlR2V0TW9kdWxlRnJvbUZpbGVuYW1lKCkpO1xuRXJyb3JUcmFja2luZy5mcmFtZU1vZGlmaWVycyA9IFthZGRTb3VyY2VDb250ZXh0XTtcbmNsYXNzIFBvc3RIb2cgZXh0ZW5kcyBQb3N0SG9nQmFja2VuZENsaWVudCB7XG4gIGdldExpYnJhcnlJZCgpIHtcbiAgICByZXR1cm4gJ3Bvc3Rob2ctbm9kZSc7XG4gIH1cbn1cblxuZXhwb3J0IHsgUG9zdEhvZywgUG9zdEhvZ1NlbnRyeUludGVncmF0aW9uLCBjcmVhdGVFdmVudFByb2Nlc3Nvciwgc2VudHJ5SW50ZWdyYXRpb24sIHNldHVwRXhwcmVzc0Vycm9ySGFuZGxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/posthog-node/lib/node/index.mjs\n");

/***/ })

};
;